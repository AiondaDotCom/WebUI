(function(global) { 'use strict'; class EventEmitter { constructor() { this.listeners = new Map();} on(event, listener) { if (!this.listeners.has(event)) { this.listeners.set(event, new Set());} this.listeners.get(event).add(listener); return this;} off(event, listener) { const eventListeners = this.listeners.get(event); if (eventListeners) { eventListeners.delete(listener); if (eventListeners.size === 0) { this.listeners.delete(event);} } return this;} once(event, listener) { const onceWrapper = (data) => { this.off(event, onceWrapper); listener(data);}; return this.on(event, onceWrapper);} emit(event, data) { const eventListeners = this.listeners.get(event); if (!eventListeners || eventListeners.size === 0) { if (this.debugMode || (typeof window !== 'undefined' && window.AIONDA_DEBUG)) { console.debug(`[EventEmitter] Event '${event}' emitted but no listeners registered`);} return false;} const startTime = performance.now ? performance.now() : Date.now(); let successCount = 0; let errorCount = 0; eventListeners.forEach(listener => { try { listener(data); successCount++;} catch (error) { errorCount++; console.error(`Error in event listener for '${event}':`, error); if (event !== 'error') { this.emit('error', { originalEvent: event, error, data });} } }); if (this.debugMode || (typeof window !== 'undefined' && window.AIONDA_DEBUG)) { const duration = (performance.now ? performance.now() : Date.now()) - startTime; if (duration > 10) { console.warn(`[EventEmitter] Slow event processing for '${event}': ${duration.toFixed(2)}ms`, { event, listenerCount: eventListeners.size, successCount, errorCount });} } return true;} removeAllListeners(event) { if (event) { this.listeners.delete(event);} else { this.listeners.clear();} return this;} listenerCount(event) { const eventListeners = this.listeners.get(event); return eventListeners ? eventListeners.size : 0;} eventNames() { return Array.from(this.listeners.keys());} setDebugMode(enabled = true) { this.debugMode = enabled; return this;} getDebugInfo() { const info = { totalEvents: this.listeners.size, events: {}, totalListeners: 0 }; this.listeners.forEach((listeners, event) => { info.events[event] = { listenerCount: listeners.size, listeners: Array.from(listeners).map(listener => ({ name: listener.name || 'anonymous', code: listener.toString().substring(0, 100) + (listener.toString().length > 100 ? '...' : '') })) }; info.totalListeners += listeners.size;}); return info;} inspect() { const info = this.getDebugInfo(); console.group('🔍 EventEmitter Inspector'); console.log('📊 Overview:', { totalEvents: info.totalEvents, totalListeners: info.totalListeners }); Object.entries(info.events).forEach(([event, details]) => { console.log(`🎧 Event '${event}':`, details);}); console.groupEnd(); return info;} validateEventName(event) { if (typeof event !== 'string') { console.warn(`[EventEmitter] Event name should be a string, got ${typeof event}:`, event);} if (event.includes(' ')) { console.warn(`[EventEmitter] Event name contains spaces: '${event}'. Consider using camelCase or kebab-case.`);} if (event.length > 50) { console.warn(`[EventEmitter] Event name is very long (${event.length} chars): '${event}'. Consider shorter names.`);} } on(event, listener) { if (this.debugMode || (typeof window !== 'undefined' && window.AIONDA_DEBUG)) { this.validateEventName(event); if (typeof listener !== 'function') { throw new Error(`[EventEmitter] Listener must be a function, got ${typeof listener}`);} } if (!this.listeners.has(event)) { this.listeners.set(event, new Set());} this.listeners.get(event).add(listener); return this;} off(event, listener) { const eventListeners = this.listeners.get(event); if (eventListeners) { const wasRemoved = eventListeners.delete(listener); if (eventListeners.size === 0) { this.listeners.delete(event);} if (this.debugMode && !wasRemoved) { console.warn(`[EventEmitter] Attempted to remove non-existent listener for event '${event}'`);} } return this;} removeAllListeners(event) { if (event) { const hadListeners = this.listeners.has(event); this.listeners.delete(event); if (this.debugMode && hadListeners) { console.debug(`[EventEmitter] Removed all listeners for event '${event}'`);} } else { const totalRemoved = this.listeners.size; this.listeners.clear(); if (this.debugMode && totalRemoved > 0) { console.debug(`[EventEmitter] Removed all listeners for ${totalRemoved} events`);} } return this;} } class SecurityUtils { static escapeHtml(text) { if (text == null || text === '') return ''; const div = document.createElement('div'); div.textContent = String(text); return div.innerHTML;} static sanitizeHtml(html) { if (html == null || html === '') return ''; const temp = document.createElement('div'); temp.innerHTML = String(html); const scripts = temp.querySelectorAll('script'); scripts.forEach(script => script.remove()); const dangerousAttrs = [ 'onclick', 'onload', 'onerror', 'onmouseover', 'onfocus', 'onblur', 'onkeydown', 'onkeyup', 'onkeypress', 'onsubmit', 'onchange', 'javascript:', 'vbscript:', 'data:', 'about:' ]; const allElements = temp.querySelectorAll('*'); allElements.forEach(element => { dangerousAttrs.forEach(attr => { element.removeAttribute(attr);}); ['href', 'src'].forEach(attr => { const value = element.getAttribute(attr); if (value) { const lowerValue = value.toLowerCase().trim(); if (lowerValue.startsWith('javascript:') || lowerValue.startsWith('vbscript:') || lowerValue.startsWith('data:') || lowerValue.startsWith('about:')) { element.removeAttribute(attr);} } });}); return temp.innerHTML;} static sanitizeInput(value, options = {}) { if (value == null) return ''; let sanitized = String(value); if (options.trim !== false) { sanitized = sanitized.trim();} if (options.maxLength && sanitized.length > options.maxLength) { sanitized = sanitized.substring(0, options.maxLength);} if (options.escapeHtml !== false) { sanitized = this.escapeHtml(sanitized);} if (options.filter && typeof options.filter === 'function') { sanitized = options.filter(sanitized);} return sanitized;} static createSafeElement(tagName, attributes = {}, textContent = '') { const element = document.createElement(tagName); Object.entries(attributes).forEach(([key, value]) => { if (value != null) { element.setAttribute(key, this.escapeHtml(String(value)));} }); if (textContent) { element.textContent = String(textContent);} return element;} static isSafeForTemplate(value) { if (value == null) return true; const str = String(value); const dangerousPatterns = [ /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, /javascript:/gi, /vbscript:/gi, /on\w+\s*=/gi, /<iframe\b[^>]*>/gi, /<object\b[^>]*>/gi, /<embed\b[^>]*>/gi, /<link\b[^>]*>/gi, /<meta\b[^>]*>/gi ]; return !dangerousPatterns.some(pattern => pattern.test(str));} static generateNonce() { const array = new Uint8Array(16); crypto.getRandomValues(array); return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');} static isSafeUrl(url) { if (!url) return true; try { const parsedUrl = new URL(url, window.location.origin); const allowedProtocols = ['http:', 'https:', '']; return allowedProtocols.includes(parsedUrl.protocol);} catch { return false;} } static sanitizeCssValue(cssValue) { if (!cssValue) return ''; const str = String(cssValue); const dangerousPatterns = [ /expression\s*\(/gi, /javascript:/gi, /vbscript:/gi, /url\s*\(\s*['"]*javascript:/gi, /url\s*\(\s*['"]*data:/gi, /url\s*\(\s*['"]*vbscript:/gi, /@import/gi, /binding\s*:/gi ]; if (dangerousPatterns.some(pattern => pattern.test(str))) { return '';} return str;} static isRateLimited(key, maxAttempts = 10, windowMs = 60000) { const now = Date.now(); const rateLimitKey = `rateLimit_${key}`; try { const stored = sessionStorage.getItem(rateLimitKey); const data = stored ? JSON.parse(stored) : { attempts: 0, resetTime: now + windowMs }; if (now > data.resetTime) { data.attempts = 0; data.resetTime = now + windowMs;} if (data.attempts >= maxAttempts) { return true;} data.attempts++; sessionStorage.setItem(rateLimitKey, JSON.stringify(data)); return false;} catch { return false;} } } class I18n extends EventEmitter { static instance = null; constructor(config = {}) { super(); if (I18n.instance) { return I18n.instance;} this.locale = config.locale || this.detectLocale(); this.fallbackLocale = config.fallbackLocale || 'en'; this.translations = new Map(); this.pluralRules = new Map(); this.loadDefaults(); I18n.instance = this;} static getInstance(config = {}) { if (!I18n.instance) { I18n.instance = new I18n(config);} return I18n.instance;} detectLocale() { if (typeof window !== 'undefined' && window.navigator) { return window.navigator.language || window.navigator.userLanguage || 'en';} return 'en';} loadDefaults() { this.addTranslations('en', { 'common.ok': 'OK', 'common.cancel': 'Cancel', 'common.close': 'Close', 'common.save': 'Save', 'common.delete': 'Delete', 'common.edit': 'Edit', 'common.add': 'Add', 'common.remove': 'Remove', 'common.search': 'Search', 'common.loading': 'Loading...', 'common.today': 'Today', 'common.clear': 'Clear', 'common.apply': 'Apply', 'common.reset': 'Reset', 'grid.columns': 'Columns', 'grid.of': 'of', 'grid.columnsVisible': 'columns visible', 'grid.rowNumber': '#', 'grid.noData': 'No data to display', 'grid.matches': 'matches', 'grid.showHideColumns': 'Show/Hide Columns', 'grid.showAll': 'Show All', 'grid.hideAll': 'Hide All', 'grid.saveConfig': 'Save Config', 'grid.hideColumn': 'Hide Column', 'grid.showColumn': 'Show Column', 'grid.showAllColumns': 'Show All Columns', 'grid.hideAllOtherColumns': 'Hide All Other Columns', 'grid.columnSettings': 'Column Settings...', 'grid.filter.number.placeholder': 'e.g. >1000, <5000', 'grid.filter.date.placeholder': 'e.g. 2024, Jan', 'grid.filter.boolean.placeholder': 'true/false', 'grid.filter.search.placeholder': 'Search {field}...', 'validation.required': 'This field is required', 'validation.email': 'Please enter a valid email address', 'validation.url': 'Please enter a valid URL', 'validation.number': 'Please enter a valid number', 'validation.date': 'Please enter a valid date', 'validation.minLength': 'Minimum length is {min} characters', 'validation.maxLength': 'Maximum length is {max} characters', 'validation.minValue': 'Value must be at least {min}', 'validation.maxValue': 'Value must be at most {max}', 'validation.negative': 'Negative values are not allowed', 'validation.decimal': 'Decimal values are not allowed', 'validation.format': 'Invalid format', 'validation.dateRequired': 'Date is required', 'validation.dateFormat': 'Invalid date format', 'validation.dateMin': 'Date must be on or after minimum date', 'validation.dateMax': 'Date must be on or before maximum date', 'validation.checkboxRequired': 'This field must be checked', 'validation.radioRequired': 'This field is required', 'combobox.noItems': 'No items to display', 'messagebox.enterValue': 'Enter value...', 'date.months': [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ], 'date.monthsShort': [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ], 'date.days': [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ], 'date.daysShort': [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ], 'date.daysMin': [ 'Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa' ], 'window.close': 'Close', 'window.maximize': 'Maximize', 'window.minimize': 'Minimize', 'window.restore': 'Restore', 'aria.closeButton': 'Close', 'aria.menuButton': 'Menu', 'aria.loading': 'Loading', 'aria.sortAscending': 'Sort ascending', 'aria.sortDescending': 'Sort descending', 'aria.expandRow': 'Expand row', 'aria.collapseRow': 'Collapse row' }); this.addPluralRule('en', (n) => n === 1 ? 'one' : 'other');} addTranslations(locale, translations) { if (!this.translations.has(locale)) { this.translations.set(locale, new Map());} const localeMap = this.translations.get(locale); const flattenObject = (obj, prefix = '') => { Object.keys(obj).forEach(key => { const fullKey = prefix ? `${prefix}.${key}` : key; const value = obj[key]; if (typeof value === 'object' && !Array.isArray(value) && value !== null) { flattenObject(value, fullKey);} else { localeMap.set(fullKey, value);} });}; flattenObject(translations); this.emit('translationsAdded', { locale, translations });} addPluralRule(locale, rule) { this.pluralRules.set(locale, rule);} setLocale(locale) { const oldLocale = this.locale; this.locale = locale; this.emit('localeChanged', { oldLocale, newLocale: locale }); return this;} getLocale() { return this.locale;} t(key, params = {}, options = {}) { const locale = options.locale || this.locale; const count = params.count; let actualKey = key; if (typeof count === 'number' && this.pluralRules.has(locale)) { const pluralForm = this.pluralRules.get(locale)(count); const pluralKey = `${key}.${pluralForm}`; if (this.hasTranslation(pluralKey, locale)) { actualKey = pluralKey;} } let translation = this.getTranslation(actualKey, locale); if (translation === null && locale !== this.fallbackLocale) { translation = this.getTranslation(actualKey, this.fallbackLocale);} if (translation === null) { translation = key;} if (params && typeof translation === 'string') { translation = this.interpolate(translation, params);} return translation;} getTranslation(key, locale) { const localeMap = this.translations.get(locale); if (!localeMap) return null; return localeMap.get(key) || null;} hasTranslation(key, locale = this.locale) { const localeMap = this.translations.get(locale); return localeMap ? localeMap.has(key) : false;} interpolate(template, params) { return template.replace(/\{(\w+)\}/g, (match, key) => { return params.hasOwnProperty(key) ? params[key] : match;});} plural(key, count, params = {}) { return this.t(key, { ...params, count });} formatDate(date, options = {}) { if (!(date instanceof Date)) return ''; try { return new Intl.DateTimeFormat(this.locale, options).format(date);} catch (e) { return date.toLocaleDateString();} } formatNumber(number, options = {}) { if (typeof number !== 'number') return ''; try { return new Intl.NumberFormat(this.locale, options).format(number);} catch (e) { return number.toString();} } getMonthNames(format = 'long') { const key = format === 'short' ? 'date.monthsShort' : 'date.months'; return this.t(key) || [];} getDayNames(format = 'long') { let key; switch (format) { case 'short': key = 'date.daysShort'; break; case 'min': key = 'date.daysMin'; break; default: key = 'date.days'; break;} return this.t(key) || [];} formatCurrency(amount, currency = 'USD', options = {}) { if (typeof amount !== 'number') return ''; try { return new Intl.NumberFormat(this.locale, { style: 'currency', currency, ...options }).format(amount);} catch (e) { return `${currency} ${amount}`;} } getAvailableLocales() { return Array.from(this.translations.keys());} exportTranslations(locale = this.locale) { const localeMap = this.translations.get(locale); if (!localeMap) return {}; const result = {}; localeMap.forEach((value, key) => { this.setNestedProperty(result, key, value);}); return result;} setNestedProperty(obj, path, value) { const keys = path.split('.'); let current = obj; for (let i = 0; i < keys.length - 1; i++) { const key = keys[i]; if (!current[key] || typeof current[key] !== 'object') { current[key] = {};} current = current[key];} current[keys[keys.length - 1]] = value;} } const i18n = I18n.getInstance(); const t = (key, params, options) => i18n.t(key, params, options); let componentIdCounter = 0; class Component extends EventEmitter { constructor(config = {}) { super(); this.version = '1.0.0'; this.apiVersion = '1.0'; this._deprecated = new Map(); config = config || {}; this._autoRenderTarget = config.renderTo; const mergedConfig = this.mergeConfig(config); delete mergedConfig.renderTo; Object.assign(this, mergedConfig); this.el = null; this.rendered = false; this.destroyed = false; this.initialized = false; this.initialized = true; if (this._autoRenderTarget) { const autoRenderTarget = this._autoRenderTarget; setTimeout(() => { if (!this.destroyed && !this.rendered && typeof this.renderTo === 'function') { this.renderTo(autoRenderTarget);} }, 0);} } getDefaultConfig() { return { id: this.generateId(), cls: '', width: undefined, height: undefined, hidden: false, disabled: false, responsive: true, style: {}, locale: undefined };} mergeConfig(config) { const defaults = this.getDefaultConfig(); const merged = Object.assign({}, defaults, config); if (defaults.style && config.style) { merged.style = Object.assign({}, defaults.style, config.style);} return merged;} generateId() { return `aionda-component-${++componentIdCounter}`;} getBaseClasses() { const classes = ['aionda-component']; if (this.cls) { classes.push(...this.cls.split(' ').filter(Boolean));} if (this.hidden) classes.push('aionda-hidden'); if (this.disabled) classes.push('aionda-disabled'); if (this.responsive) classes.push('aionda-responsive'); return classes;} applyStyles() { if (!this.el) return; if (this.width !== undefined) { this.el.style.width = typeof this.width === 'number' ? `${this.width}px` : this.width;} if (this.height !== undefined) { this.el.style.height = typeof this.height === 'number' ? `${this.height}px` : this.height;} Object.assign(this.el.style, this.style);} render() { if (this.destroyed) { throw new Error('Cannot render destroyed component');} if (this.rendered && this.el) { return this.el;} const template = this.createTemplate(); const wrapper = document.createElement('div'); wrapper.innerHTML = template.trim(); this.el = wrapper.firstElementChild; if (!this.el) { throw new Error('Component template must return a valid HTML element');} this.el.id = this.id; const originalClasses = this.el.className.split(' ').filter(Boolean); const baseClasses = this.getBaseClasses(); const allClasses = [...originalClasses, ...baseClasses]; this.el.className = allClasses.join(' '); this.applyStyles(); this.setupEventListeners(); this.rendered = true; this.emit('render'); return this.el;} renderTo(target) { const element = this.render(); const container = typeof target === 'string' ? document.querySelector(target) : target; if (!container) { throw new Error(`Render target not found: ${target}`);} container.appendChild(element); return element;} createTemplate() { throw new Error('createTemplate() must be implemented by subclass');} setupEventListeners() { if (BrowserDetect.isIE() || BrowserDetect.isOldEdge()) { this.addIECompatibilityFixes();} } addIECompatibilityFixes() { if (this.el) { const focusableElements = this.el.querySelectorAll('input, button, select, textarea, [tabindex]'); focusableElements.forEach(element => { if (!element.hasAttribute('tabindex') && !element.disabled) { element.setAttribute('tabindex', '0');} });} } show() { this.hidden = false; if (this.el) { this.el.classList.remove('aionda-hidden');} this.emit('show'); return this;} hide() { this.hidden = true; if (this.el) { this.el.classList.add('aionda-hidden');} this.emit('hide'); return this;} enable() { this.disabled = false; if (this.el) { this.el.classList.remove('aionda-disabled');} return this;} disable() { this.disabled = true; if (this.el) { this.el.classList.add('aionda-disabled');} return this;} addClass(cls) { if (this.el) { this.el.classList.add(cls);} return this;} removeClass(cls) { if (this.el) { this.el.classList.remove(cls);} return this;} hasClass(cls) { return this.el?.classList.contains(cls) || false;} getEl() { return this.el;} destroy() { if (this.destroyed) return; this.emit('destroy'); if (this.el && this.el.parentNode) { this.el.parentNode.removeChild(this.el);} this.removeAllListeners(); this.destroyed = true; this.rendered = false; this.el = null;} isDestroyed() { return this.destroyed;} isRendered() { return this.rendered;} isInitialized() { return this.initialized;} async waitForInitialization() { if (this.initialized) return this; return new Promise((resolve) => { const onInit = () => { this.off('initialized', onInit); resolve(this);}; this.on('initialized', onInit);});} getVersion() { return this.version;} getApiVersion() { return this.apiVersion;} isCompatibleWith(requiredVersion) { const [major, minor] = this.version.split('.').map(Number); const [reqMajor, reqMinor] = requiredVersion.split('.').map(Number); if (major !== reqMajor) return false; return minor >= reqMinor;} _warnDeprecated(methodName, newMethod, version) { if (this._deprecated.has(methodName)) return; this._deprecated.set(methodName, true); const message = `Warning: ${methodName} is deprecated${version ? ` since v${version}` : ''}${newMethod ? `. Use ${newMethod} instead.` : '.'}`; if (console && console.warn) { console.warn(message, this);} } escapeHtml(text) { return SecurityUtils.escapeHtml(text);} sanitizeHtml(html) { return SecurityUtils.sanitizeHtml(html);} sanitizeInput(value, options) { return SecurityUtils.sanitizeInput(value, options);} isSafeForTemplate(value) { return SecurityUtils.isSafeForTemplate(value);} t(key, params = {}, options = {}) { const locale = this.locale || options.locale; return i18n.t(key, params, { ...options, locale });} getLocale() { return this.locale || i18n.getLocale();} setLocale(locale) { const oldLocale = this.locale; this.locale = locale; this.emit('localeChanged', { oldLocale, newLocale: locale }); return this;} formatDate(date, options = {}) { return i18n.formatDate(date, options);} formatNumber(number, options = {}) { return i18n.formatNumber(number, options);} formatCurrency(amount, currency = 'USD', options = {}) { return i18n.formatCurrency(amount, currency, options);} getEl() { this._warnDeprecated('getEl()', 'direct property access (component.el)', '1.1.0'); return this.el;} isDestroyed() { this._warnDeprecated('isDestroyed()', 'direct property access (component.destroyed)', '1.1.0'); return this.destroyed;} isRendered() { this._warnDeprecated('isRendered()', 'direct property access (component.rendered)', '1.1.0'); return this.rendered;} isInitialized() { this._warnDeprecated('isInitialized()', 'direct property access (component.initialized)', '1.1.0'); return this.initialized;} } class Store extends EventEmitter { constructor(config = {}) { super(); config = config || {}; this.data = config.data || []; this.loading = false; this.proxy = config.proxy; this.sorters = config.sorters || []; this.filters = config.filters || []; if (config.autoLoad && this.proxy) { this.load();} } async load() { if (!this.proxy || !this.proxy.read) { console.warn('No proxy configured for store'); return Promise.resolve([]);} this.loading = true; this.emit('beforeload'); try { const data = await this.proxy.read(); this.data = data; this.loading = false; this.emit('load', { data }); return data;} catch (error) { this.loading = false; this.emit('exception', { error }); throw error;} } loadData(data) { this.data = Array.isArray(data) ? data : []; this.emit('load', { data: this.data }); this.emit('update');} setData(data) { return this.loadData(data);} add(record) { this.data.push(record); this.emit('add', { record, index: this.data.length - 1 }); this.emit('update'); return this;} remove(record) { const index = this.data.indexOf(record); if (index !== -1) { this.data.splice(index, 1); this.emit('remove', { record, index }); this.emit('update');} return this;} removeAt(index) { if (index >= 0 && index < this.data.length) { const record = this.data[index]; this.data.splice(index, 1); this.emit('remove', { record, index }); this.emit('update'); return record;} return null;} getCount() { return this.getRecords().length;} getAt(index) { const records = this.getRecords(); return records[index];} getById(id) { return this.data.find(record => record.id === id);} indexOf(record) { return this.getRecords().indexOf(record);} getData() { return this.data;} getRecords() { let result = [...this.data]; if (this.filters.length > 0) { result = this.applyFilters(result);} if (this.sorters.length > 0) { result = this.applySorters(result);} return result;} getFilteredData() { return this.getRecords();} sort(sorters) { this.sorters = Array.isArray(sorters) ? sorters : [sorters]; this.emit('sort', { sorters: this.sorters }); return this;} filter(filters, replace = false) { const newFilters = Array.isArray(filters) ? filters : [filters]; if (replace) { this.filters = newFilters;} else { newFilters.forEach(newFilter => { const existingIndex = this.filters.findIndex(f => f.property === newFilter.property); if (existingIndex >= 0) { this.filters[existingIndex] = newFilter;} else { this.filters.push(newFilter);} });} this.emit('filter', { filters: this.filters }); return this;} clearFilters() { this.filters = []; this.emit('filter', { filters: this.filters }); return this;} clearSorters() { this.sorters = []; this.emit('sort', { sorters: this.sorters }); return this;} update(record, newData) { if (newData === undefined && record && record.id !== undefined) { const index = this.data.findIndex(r => r.id === record.id); if (index !== -1) { const changes = {}; for (const key in record) { if (key !== 'id' && this.data[index][key] !== record[key]) { changes[key] = record[key];} } Object.assign(this.data[index], record); this.emit('recordupdate', { record: this.data[index], index, changes }); this.emit('update');} return this;} const index = this.data.indexOf(record); if (index !== -1) { Object.assign(this.data[index], newData); this.emit('recordupdate', { record: this.data[index], index, changes: newData }); this.emit('update');} return this;} updateAt(index, newData) { if (index >= 0 && index < this.data.length) { Object.assign(this.data[index], newData); this.emit('recordupdate', { record: this.data[index], index, changes: newData }); this.emit('update'); return this.data[index];} return null;} clear() { this.data = []; this.emit('clear'); this.emit('update'); return this;} applyFilters(records) { return records.filter(record => { return this.filters.every(filter => { const value = record[filter.property]; const filterValue = filter.value; const operator = filter.operator || 'eq'; switch (operator) { case 'eq': return value === filterValue; case 'ne': return value !== filterValue; case 'gt': return value > filterValue; case 'gte': return value >= filterValue; case 'lt': return value < filterValue; case 'lte': return value <= filterValue; case 'like': return String(value).toLowerCase().includes(String(filterValue).toLowerCase()); case 'in': return Array.isArray(filterValue) ? filterValue.includes(value) : false; default: return true;} });});} applySorters(records) { return records.sort((a, b) => { for (const sorter of this.sorters) { const aValue = a[sorter.property]; const bValue = b[sorter.property]; let comparison = 0; if (aValue < bValue) comparison = -1; else if (aValue > bValue) comparison = 1; if (comparison !== 0) { return sorter.direction === 'DESC' ? -comparison : comparison;} } return 0;});} toTree(parentField = 'parentId', childrenField = 'children', rootValue = null) { const data = this.getRecords(); const tree = []; const map = new Map(); data.forEach(record => { if (record.id !== undefined && record.id !== null) { map.set(record.id, { ...record, [childrenField]: [] });} }); data.forEach(record => { if (record.id === undefined || record.id === null) return; const node = map.get(record.id); const parentId = record[parentField]; if (parentId === rootValue || parentId === undefined || parentId === null) { tree.push(node);} else { const parent = map.get(parentId); if (parent) { parent[childrenField].push(node);} } }); return tree;} fromTree(treeData, parentField = 'parentId', childrenField = 'children', parentId = null) { const flat = []; if (!Array.isArray(treeData)) return flat; treeData.forEach(node => { const flatNode = { ...node }; flatNode[parentField] = parentId; if (flatNode[childrenField]) { const children = flatNode[childrenField]; delete flatNode[childrenField]; flat.push(flatNode); const childFlat = this.fromTree(children, parentField, childrenField, node.id); flat.push(...childFlat);} else { flat.push(flatNode);} }); return flat;} getNodeChildren(nodeId, parentField = 'parentId') { const children = []; const data = this.getRecords(); const findChildren = (parentId) => { data.forEach(record => { if (record[parentField] === parentId) { children.push(record); findChildren(record.id);} });}; findChildren(nodeId); return children;} getNodePath(nodeId, parentField = 'parentId') { const path = []; const data = this.getRecords(); const nodeMap = new Map(); data.forEach(record => { if (record.id !== undefined && record.id !== null) { nodeMap.set(record.id, record);} }); let currentNode = nodeMap.get(nodeId); while (currentNode) { path.unshift(currentNode); const parentId = currentNode[parentField]; currentNode = parentId ? nodeMap.get(parentId) : null;} return path;} getRootNodes(parentField = 'parentId', rootValue = null) { return this.getRecords().filter(record => record[parentField] === rootValue || record[parentField] === undefined || record[parentField] === null );} getDirectChildren(nodeId, parentField = 'parentId') { return this.getRecords().filter(record => record[parentField] === nodeId);} hasChildren(nodeId, parentField = 'parentId') { return this.getRecords().some(record => record[parentField] === nodeId);} moveNode(nodeId, newParentId, parentField = 'parentId') { const node = this.getById(nodeId); if (node) { node[parentField] = newParentId; this.emit('nodemove', { nodeId, newParentId, node }); this.emit('update');} } addChildNode(nodeData, parentId = null, parentField = 'parentId') { const node = { ...nodeData }; node[parentField] = parentId; this.add(node); this.emit('nodeadd', { node, parentId }); return node;} removeNodeWithChildren(nodeId, parentField = 'parentId') { const children = this.getNodeChildren(nodeId, parentField); const node = this.getById(nodeId); children.forEach(child => this.remove(child)); if (node) { this.remove(node); this.emit('noderemove', { nodeId, node, childrenRemoved: children.length });} } static createTreeStore(data, options = {}) { const config = { data: data || [], ...options }; const store = new Store(config); store.getTreeData = function(childrenField = 'children') { if (this.data.length > 0 && this.data[0][childrenField]) { return this.getRecords();} return this.toTree('parentId', childrenField);}; return store;} } class ThemeManager extends EventEmitter { constructor(options = {}) { super(); this.options = { storageKey: 'aionda-webui-theme', autoDetect: true, autoInit: true, defaultTheme: 'light', themes: { light: { name: 'light', displayName: 'Light', className: 'theme-light', colors: { primary: '#3B82F6', secondary: '#6B7280', accent: '#10B981', background: '#FFFFFF', surface: '#F9FAFB', text: '#111827', textSecondary: '#6B7280' } }, dark: { name: 'dark', displayName: 'Dark', className: 'theme-dark dark', colors: { primary: '#60A5FA', secondary: '#9CA3AF', accent: '#34D399', background: '#111827', surface: '#1F2937', text: '#F9FAFB', textSecondary: '#D1D5DB' } } }, ...options }; this.currentTheme = null; this.systemPreference = null; this.themeChangeListeners = new Set(); this.initialized = false; this.destroyed = false; if (this.options.autoInit !== false) { this.initialize();} } initialize() { if (this.initialized || this.destroyed) { return;} this.detectSystemPreference(); this.loadPersistedTheme(); this.setupSystemListener(); this.applyTheme(); this.initialized = true;} init() { return this.initialize();} detectSystemPreference() { const matchMedia = (typeof window !== 'undefined' && window.matchMedia) || (typeof global !== 'undefined' && global.matchMedia); if (matchMedia) { const prefersDark = matchMedia('(prefers-color-scheme: dark)'); this.systemPreference = prefersDark.matches ? 'dark' : 'light'; return this.systemPreference;} this.systemPreference = 'light'; return this.systemPreference;} detectSystemTheme() { return this.detectSystemPreference();} setupSystemListener() { const matchMedia = (typeof window !== 'undefined' && window.matchMedia) || (typeof global !== 'undefined' && global.matchMedia); if (matchMedia) { const prefersDark = matchMedia('(prefers-color-scheme: dark)'); const handleSystemChange = (e) => { const newPreference = e.matches ? 'dark' : 'light'; this.systemPreference = newPreference; if (this.options.autoDetect && !this.hasPersistedTheme()) { this.setTheme(newPreference, false);} this.emit('systemPreferenceChanged', { preference: newPreference, currentTheme: this.currentTheme });}; if (prefersDark.addEventListener) { prefersDark.addEventListener('change', handleSystemChange);} } } loadPersistedTheme() { if (typeof localStorage !== 'undefined') { try { const stored = localStorage.getItem(this.options.storageKey); if (stored) { const themeData = JSON.parse(stored); if (this.isValidTheme(themeData.name)) { this.currentTheme = themeData.name; return;} } } catch (error) { console.warn('ThemeManager: Failed to load persisted theme:', error);} } this.currentTheme = this.options.autoDetect && this.systemPreference ? this.systemPreference : this.options.defaultTheme;} hasPersistedTheme() { if (typeof localStorage !== 'undefined') { try { return localStorage.getItem(this.options.storageKey) !== null;} catch (error) { return false;} } return false;} persistTheme(themeName) { if (typeof localStorage !== 'undefined') { try { const themeData = { name: themeName, timestamp: Date.now() }; localStorage.setItem(this.options.storageKey, JSON.stringify(themeData));} catch (error) { console.warn('ThemeManager: Failed to persist theme:', error);} } } setTheme(themeName, persist = true) { if (!this.isValidTheme(themeName)) { console.warn(`ThemeManager: Invalid theme "${themeName}"`); return false;} const previousTheme = this.currentTheme; this.currentTheme = themeName; if (persist) { this.persistTheme(themeName);} this.applyTheme(); this.emit('themeChanged', { theme: themeName, previousTheme: previousTheme, themeData: this.getTheme(themeName) }); return true;} toggleTheme() { const currentTheme = this.getCurrentTheme(); const availableThemes = Object.keys(this.options.themes); const currentIndex = availableThemes.indexOf(currentTheme); const nextIndex = (currentIndex + 1) % availableThemes.length; const nextTheme = availableThemes[nextIndex]; return this.setTheme(nextTheme);} applyTheme() { const doc = (typeof document !== 'undefined' && document) || (typeof global !== 'undefined' && global.document); if (!doc || !doc.documentElement) { return;} const theme = this.getTheme(this.currentTheme); if (!theme) { return;} this.removeAllThemeClasses(); const classes = theme.className.split(' ').filter(cls => cls.trim()); if (doc.documentElement.classList) { doc.documentElement.classList.add(...classes);} this.applyCSSVariables(theme); this.emit('themeApplied', { theme: this.currentTheme, themeData: theme });} removeAllThemeClasses() { const doc = (typeof document !== 'undefined' && document) || (typeof global !== 'undefined' && global.document); if (!doc || !doc.documentElement || !doc.documentElement.classList) { return;} const allClasses = Object.values(this.options.themes) .flatMap(theme => theme.className.split(' ')) .filter(cls => cls.trim()); doc.documentElement.classList.remove(...allClasses);} applyCSSVariables(theme) { if (!theme.colors) { return;} const doc = (typeof document !== 'undefined' && document) || (typeof global !== 'undefined' && global.document); if (!doc || !doc.documentElement || !doc.documentElement.style) { return;} const root = doc.documentElement; Object.entries(theme.colors).forEach(([key, value]) => { root.style.setProperty(`--theme-${key}`, value);});} addTheme(themeName, themeConfig) { if (!themeName || typeof themeConfig !== 'object') { throw new Error('ThemeManager: Invalid theme configuration');} const theme = { name: themeName, displayName: themeConfig.displayName || themeName, className: themeConfig.className || `theme-${themeName}`, colors: themeConfig.colors || {}, extends: themeConfig.extends, ...themeConfig }; if (theme.extends && this.options.themes[theme.extends]) { const parentTheme = this.options.themes[theme.extends]; theme.colors = { ...parentTheme.colors, ...theme.colors };} this.options.themes[themeName] = theme; this.emit('themeAdded', { theme: themeName, themeData: theme }); return theme;} removeTheme(themeName) { if (themeName === this.currentTheme) { console.warn('ThemeManager: Cannot remove currently active theme'); return false;} if (!this.options.themes[themeName]) { return false;} delete this.options.themes[themeName]; this.emit('themeRemoved', { theme: themeName }); return true;} getCurrentTheme() { return this.currentTheme;} getTheme(themeName = null) { themeName = themeName || this.currentTheme; return this.options.themes[themeName] || null;} getAvailableThemes() { return Object.keys(this.options.themes);} getThemeData(themeName = null) { return this.getTheme(themeName);} isValidTheme(themeName) { return Boolean(this.options.themes[themeName]);} getSystemPreference() { return this.systemPreference;} enableAutoDetect() { this.options.autoDetect = true; if (!this.hasPersistedTheme()) { this.setTheme(this.systemPreference, false);} } disableAutoDetect() { this.options.autoDetect = false;} reset() { if (typeof localStorage !== 'undefined') { try { localStorage.removeItem(this.options.storageKey);} catch (error) { console.warn('ThemeManager: Failed to clear persisted theme:', error);} } this.currentTheme = this.options.autoDetect ? this.systemPreference : this.options.defaultTheme; this.applyTheme(); this.emit('themeReset', { theme: this.currentTheme });} getThemeForComponent(component) { if (!component || typeof component !== 'object') { return this.getTheme();} if (component.theme && this.isValidTheme(component.theme)) { return this.getTheme(component.theme);} if (component.parentComponent) { return this.getThemeForComponent(component.parentComponent);} return this.getTheme();} applyThemeToElement(element, themeName = null) { if (!element || typeof element.classList === 'undefined') { return false;} const theme = this.getTheme(themeName); if (!theme) { return false;} const themeClasses = Object.values(this.options.themes) .flatMap(t => t.className.split(' ')) .filter(cls => cls.trim()); element.classList.remove(...themeClasses); const classes = theme.className.split(' ').filter(cls => cls.trim()); element.classList.add(...classes); return true;} isDark() { return this.currentTheme === 'dark';} isLight() { return this.currentTheme === 'light';} isDestroyed() { return this.destroyed;} destroy() { this.removeAllListeners(); this.themeChangeListeners.clear(); this.currentTheme = null; this.systemPreference = null; this.destroyed = true; this.initialized = false;} } const themeManager = new ThemeManager(); const BrowserDetect = { isIE: () => { return navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > -1;}, isOldEdge: () => { return navigator.userAgent.indexOf('Edge') !== -1 && navigator.userAgent.indexOf('Edg') === -1;}, isSafari: () => { return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);}, isFirefox: () => { return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;}, supportsModernFeatures: () => { return ( typeof Map !== 'undefined' && typeof Set !== 'undefined' && typeof Promise !== 'undefined' && typeof Array.from !== 'undefined' );} }; class Polyfills { static init() { this.polyfillClosest(); this.polyfillMatches(); this.polyfillRemove(); this.polyfillCustomEvents(); this.polyfillObjectAssign(); this.polyfillArrayFrom(); this.polyfillArrayIncludes(); this.polyfillStringIncludes(); this.polyfillScrollIntoView(); this.polyfillIntersectionObserver(); this.polyfillPromise(); this.polyfillFetch();} static polyfillClosest() { if (!Element.prototype.closest) { Element.prototype.closest = function(selector) { let element = this; while (element && element.nodeType === 1) { if (element.matches(selector)) { return element;} element = element.parentElement || element.parentNode;} return null;};} } static polyfillMatches() { if (!Element.prototype.matches) { Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.msMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.webkitMatchesSelector || function(selector) { const matches = (this.document || this.ownerDocument).querySelectorAll(selector); let i = matches.length; while (--i >= 0 && matches.item(i) !== this) {} return i > -1;};} } static polyfillRemove() { if (!Element.prototype.remove) { Element.prototype.remove = function() { if (this.parentNode) { this.parentNode.removeChild(this);} };} } static polyfillCustomEvents() { if (typeof window.CustomEvent !== 'function') { function CustomEvent(event, params) { params = params || { bubbles: false, cancelable: false, detail: undefined }; const evt = document.createEvent('CustomEvent'); evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail); return evt;} CustomEvent.prototype = window.Event.prototype; window.CustomEvent = CustomEvent;} } static polyfillObjectAssign() { if (typeof Object.assign !== 'function') { Object.assign = function(target, varArgs) { if (target == null) { throw new TypeError('Cannot convert undefined or null to object');} const to = Object(target); for (let index = 1; index < arguments.length; index++) { const nextSource = arguments[index]; if (nextSource != null) { for (const nextKey in nextSource) { if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) { to[nextKey] = nextSource[nextKey];} } } } return to;};} } static polyfillArrayFrom() { if (!Array.from) { Array.from = function(arrayLike, mapFn, thisArg) { const C = this; const items = Object(arrayLike); if (arrayLike == null) { throw new TypeError('Array.from requires an array-like object - not null or undefined');} const mapFunction = mapFn === undefined ? undefined : mapFn; if (typeof mapFunction !== 'undefined' && typeof mapFunction !== 'function') { throw new TypeError('Array.from: when provided, the second argument must be a function');} const len = parseInt(items.length); const A = typeof C === 'function' ? Object(new C(len)) : new Array(len); let k = 0; while (k < len) { const kValue = items[k]; const mappedValue = typeof mapFunction === 'undefined' ? kValue : mapFunction.call(thisArg, kValue, k); A[k] = mappedValue; k += 1;} A.length = len; return A;};} } static polyfillArrayIncludes() { if (!Array.prototype.includes) { Array.prototype.includes = function(searchElement, fromIndex) { const o = Object(this); const len = parseInt(o.length) || 0; if (len === 0) return false; const n = parseInt(fromIndex) || 0; let k; if (n >= 0) { k = n;} else { k = len + n; if (k < 0) {k = 0;} } function sameValueZero(x, y) { return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));} for (; k < len; k++) { if (sameValueZero(o[k], searchElement)) { return true;} } return false;};} } static polyfillStringIncludes() { if (!String.prototype.includes) { String.prototype.includes = function(search, start) { if (typeof start !== 'number') { start = 0;} if (start + search.length > this.length) { return false;} else { return this.indexOf(search, start) !== -1;} };} } static polyfillScrollIntoView() { if (!Element.prototype.scrollIntoView || BrowserDetect.isIE() || BrowserDetect.isOldEdge()) { Element.prototype.scrollIntoView = function(options) { const element = this; const container = element.offsetParent || document.documentElement; if (typeof options === 'boolean') { options = { block: options ? 'start' : 'end' };} options = options || { block: 'start' }; const elementRect = element.getBoundingClientRect(); const containerRect = container.getBoundingClientRect(); let scrollTop = container.scrollTop; if (options.block === 'start') { scrollTop = elementRect.top - containerRect.top + container.scrollTop;} else if (options.block === 'end') { scrollTop = elementRect.bottom - containerRect.bottom + container.scrollTop;} else if (options.block === 'nearest') { if (elementRect.top < containerRect.top) { scrollTop = elementRect.top - containerRect.top + container.scrollTop;} else if (elementRect.bottom > containerRect.bottom) { scrollTop = elementRect.bottom - containerRect.bottom + container.scrollTop;} } container.scrollTop = scrollTop;};} } static polyfillIntersectionObserver() { if (!window.IntersectionObserver) { window.IntersectionObserver = class { constructor(callback, options = {}) { this.callback = callback; this.options = options; this.observedElements = new Set();} observe(element) { this.observedElements.add(element); setTimeout(() => { this.callback([{ target: element, isIntersecting: true, intersectionRatio: 1, boundingClientRect: element.getBoundingClientRect(), intersectionRect: element.getBoundingClientRect(), rootBounds: null, time: Date.now() }]);}, 0);} unobserve(element) { this.observedElements.delete(element);} disconnect() { this.observedElements.clear();} };} } static polyfillPromise() { if (typeof Promise === 'undefined') { window.Promise = class { constructor(executor) { this.state = 'pending'; this.value = undefined; this.handlers = []; const resolve = (value) => { if (this.state === 'pending') { this.state = 'fulfilled'; this.value = value; this.handlers.forEach(handler => handler.onFulfilled(value));} }; const reject = (reason) => { if (this.state === 'pending') { this.state = 'rejected'; this.value = reason; this.handlers.forEach(handler => handler.onRejected(reason));} }; try { executor(resolve, reject);} catch (error) { reject(error);} } then(onFulfilled, onRejected) { return new Promise((resolve, reject) => { const handler = { onFulfilled: (value) => { try { const result = onFulfilled ? onFulfilled(value) : value; resolve(result);} catch (error) { reject(error);} }, onRejected: (reason) => { try { const result = onRejected ? onRejected(reason) : reason; reject(result);} catch (error) { reject(error);} } }; if (this.state === 'fulfilled') { setTimeout(() => handler.onFulfilled(this.value), 0);} else if (this.state === 'rejected') { setTimeout(() => handler.onRejected(this.value), 0);} else { this.handlers.push(handler);} });} catch(onRejected) { return this.then(null, onRejected);} static resolve(value) { return new Promise(resolve => resolve(value));} static reject(reason) { return new Promise((resolve, reject) => reject(reason));} };} } static polyfillFetch() { if (!window.fetch) { window.fetch = function(url, options = {}) { return new Promise((resolve, reject) => { const xhr = new XMLHttpRequest(); const method = options.method || 'GET'; xhr.open(method, url); if (options.headers) { Object.keys(options.headers).forEach(key => { xhr.setRequestHeader(key, options.headers[key]);});} xhr.onload = () => { const response = { ok: xhr.status >= 200 && xhr.status < 300, status: xhr.status, statusText: xhr.statusText, headers: new Map(), text: () => Promise.resolve(xhr.responseText), json: () => Promise.resolve(JSON.parse(xhr.responseText)) }; resolve(response);}; xhr.onerror = () => reject(new Error('Network error')); xhr.ontimeout = () => reject(new Error('Request timeout')); xhr.send(options.body);});};} } } class CSSCompat { static init() { this.addVendorPrefixes(); this.fixFlexbox(); this.fixGrid(); this.addCompatibilityClasses();} static addVendorPrefixes() { const style = document.createElement('style'); style.textContent = ` .transform-none { -webkit-transform: none; -moz-transform: none; -ms-transform: none; transform: none;} .transition-all { -webkit-transition: all 0.15s ease-in-out; -moz-transition: all 0.15s ease-in-out; -ms-transition: all 0.15s ease-in-out; transition: all 0.15s ease-in-out;} .shadow-lg { -webkit-box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); -moz-box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);} .select-none { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;} `; document.head.appendChild(style);} static fixFlexbox() { if (BrowserDetect.isIE()) { const style = document.createElement('style'); style.textContent = ` .flex { display: -ms-flexbox; display: flex;} .flex-1 { -ms-flex: 1 1 0%; flex: 1 1 0%;} .items-center { -ms-flex-align: center; align-items: center;} .justify-center { -ms-flex-pack: center; justify-content: center;} .justify-between { -ms-flex-pack: justify; justify-content: space-between;} `; document.head.appendChild(style);} } static fixGrid() { if (BrowserDetect.isIE() || BrowserDetect.isOldEdge()) { const style = document.createElement('style'); style.textContent = ` .grid { display: -ms-grid; display: grid;} .grid-fallback { display: flex; flex-wrap: wrap;} .grid-fallback > * { flex: 1 1 auto;} `; document.head.appendChild(style);} } static addCompatibilityClasses() { const html = document.documentElement; if (BrowserDetect.isIE()) { html.classList.add('browser-ie');} if (BrowserDetect.isOldEdge()) { html.classList.add('browser-old-edge');} if (BrowserDetect.isSafari()) { html.classList.add('browser-safari');} if (BrowserDetect.isFirefox()) { html.classList.add('browser-firefox');} } } class EventCompat { static getEvent(event) { return event || window.event;} static getTarget(event) { return event.target || event.srcElement;} static preventDefault(event) { if (event.preventDefault) { event.preventDefault();} else { event.returnValue = false;} } static stopPropagation(event) { if (event.stopPropagation) { event.stopPropagation();} else { event.cancelBubble = true;} } static addEventListener(element, event, handler, useCapture = false) { if (element.addEventListener) { element.addEventListener(event, handler, useCapture);} else if (element.attachEvent) { element.attachEvent('on' + event, handler);} else { element['on' + event] = handler;} } static removeEventListener(element, event, handler, useCapture = false) { if (element.removeEventListener) { element.removeEventListener(event, handler, useCapture);} else if (element.detachEvent) { element.detachEvent('on' + event, handler);} else { element['on' + event] = null;} } } class DOMCompat { static getComputedStyle(element, property) { if (window.getComputedStyle) { return window.getComputedStyle(element)[property];} else if (element.currentStyle) { return element.currentStyle[property];} return null;} static setStyle(element, property, value) { const prefixes = ['', '-webkit-', '-moz-', '-ms-', '-o-']; prefixes.forEach(prefix => { const prefixedProperty = prefix + property; if (prefixedProperty in element.style) { element.style[prefixedProperty] = value;} });} static getOffset(element) { let top = 0; let left = 0; while (element) { top += element.offsetTop || 0; left += element.offsetLeft || 0; element = element.offsetParent;} return { top, left };} static contains(parent, child) { if (parent.contains) { return parent.contains(child);} else { while (child) { if (child === parent) { return true;} child = child.parentNode;} return false;} } } function initBrowserCompat() { if (window.aiondaBrowserCompatInitialized) { return;} try { Polyfills.init(); CSSCompat.init(); window.aiondaBrowserCompatInitialized = true; console.log('Aionda WebUI: Browser compatibility initialized');} catch (error) { console.warn('Aionda WebUI: Browser compatibility initialization failed:', error);} } if (typeof window !== 'undefined') { if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initBrowserCompat);} else { initBrowserCompat();} } class Panel extends Component { constructor(config = {}) { super(config); this.version = '1.0.1'; this.apiVersion = '1.0'; this.items = []; this.headerEl = null; this.bodyEl = null; this.titleEl = null; this.menu = config.menu || null; this.contextMenu = config.contextMenu || null; if (config && config.items) { config.items.forEach(item => this.add(item));} } getDefaultConfig() { return { ...super.getDefaultConfig(), title: '', collapsible: false, collapsed: false, header: true, headerHeight: 48, padding: true, border: true, shadow: false, bodyStyle: {}, menu: null, contextMenu: null };} createTemplate() { const headerTemplate = this.header ? this.createHeaderTemplate() : ''; const bodyTemplate = this.createBodyTemplate(); return ` <div class="aionda-panel bg-white dark:bg-gray-800 flex flex-col overflow-hidden ${this.getAdditionalPanelClasses().join(' ')}" role="region" aria-labelledby="${this.id}-header"> ${headerTemplate} ${bodyTemplate} </div> `;} createHeaderTemplate() { if (!this.header) return ''; const collapseButton = this.collapsible ? ` <button class="aionda-panel-collapse-btn p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded transition-colors" type="button" aria-expanded="${!this.collapsed}" aria-controls="${this.id}-body" aria-label="${this.collapsed ? 'Expand panel' : 'Collapse panel'}"> <svg class="w-4 h-4 transform transition-transform ${this.collapsed ? '' : 'rotate-90'}" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path> </svg> </button> ` : ''; return ` <div class="aionda-panel-header flex items-center justify-between px-4 border-b border-gray-200 dark:border-gray-600 bg-gray-50 dark:bg-gray-700" style="height: ${this.headerHeight}px; min-height: ${this.headerHeight}px;" id="${this.id}-header"> <div class="flex items-center gap-2"> ${collapseButton} <h3 class="aionda-panel-title font-medium text-gray-900 dark:text-gray-100">${this.title}</h3> </div> <div class="aionda-panel-tools flex items-center gap-1"> <!-- Tools slot --> </div> </div> `;} createBodyTemplate() { const bodyClasses = [ 'aionda-panel-body', 'transition-all duration-200', this.padding ? 'p-4' : '', this.collapsed ? 'hidden' : 'block' ].filter(Boolean); return ` <div class="${bodyClasses.join(' ')}" style="${this.getBodyStyleString()}" id="${this.id}-body" aria-hidden="${this.collapsed}"> <!-- Content will be inserted here --> </div> `;} getPanelClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-panel', 'bg-white', 'dark:bg-gray-800', 'flex', 'flex-col', 'overflow-hidden' ]; if (this.border) classes.push('border', 'border-gray-200', 'dark:border-gray-600'); if (this.shadow) classes.push('shadow-sm'); if (this.responsive) classes.push('w-full'); return classes;} getAdditionalPanelClasses() { const classes = []; if (this.border) classes.push('border', 'border-gray-200', 'dark:border-gray-600'); if (this.shadow) classes.push('shadow-sm'); if (this.responsive) classes.push('w-full'); return classes;} getBodyStyleString() { return Object.entries(this.bodyStyle) .map(([key, value]) => `${key.replace(/([A-Z])/g, '-$1').toLowerCase()}: ${value}`) .join('; ');} render() { if (this.destroyed) { throw new Error('Cannot render destroyed component');} if (this.rendered && this.el) { return this.el;} const template = this.createTemplate(); const wrapper = document.createElement('div'); wrapper.innerHTML = template.trim(); this.el = wrapper.firstElementChild; if (!this.el) { throw new Error('Component template must return a valid HTML element');} this.el.id = this.id; this.el.className = this.getPanelClasses().join(' '); if (this.width !== undefined) { this.el.style.width = typeof this.width === 'number' ? `${this.width}px` : this.width;} if (this.height !== undefined) { this.el.style.height = typeof this.height === 'number' ? `${this.height}px` : this.height;} Object.assign(this.el.style, this.style); this.setupEventListeners(); this.rendered = true; this.emit('render'); return this.el;} setupEventListeners() { super.setupEventListeners(); this.headerEl = this.el.querySelector('.aionda-panel-header'); this.bodyEl = this.el.querySelector('.aionda-panel-body'); this.titleEl = this.el.querySelector('.aionda-panel-title'); this.el.addEventListener('click', (e) => this.onClick(e)); this.el.addEventListener('focus', (e) => this.onFocus(e)); this.el.addEventListener('blur', (e) => this.onBlur(e)); if (this.collapsible) { const collapseEl = this.el.querySelector('.aionda-panel-collapse-btn'); if (collapseEl) { collapseEl.addEventListener('click', () => this.toggleCollapse());} } if (this.bodyEl && this.items.length > 0) { this.items.forEach(item => { if (item.render && typeof item.render === 'function') { const el = item.render(); this.bodyEl.appendChild(el);} else if (item instanceof HTMLElement) { this.bodyEl.appendChild(item);} });} if (this.menu) { this.setMenu(this.menu);} if (this.contextMenu) { this.setContextMenu(this.contextMenu);} } setTitle(title) { this.title = title; if (this.titleEl) { this.titleEl.textContent = title;} this.emit('titleChange', { title }); return this;} getTitle() { return this.title;} collapse() { if (!this.collapsible) return this; if (this.collapsed) return this; this.collapsed = true; if (this.bodyEl) { this.bodyEl.classList.add('hidden'); this.bodyEl.classList.remove('block'); this.bodyEl.setAttribute('aria-hidden', 'true');} const button = this.el && this.el.querySelector('.aionda-panel-collapse-btn'); if (button) { button.setAttribute('aria-expanded', 'false'); button.setAttribute('aria-label', 'Expand panel'); const icon = button.querySelector('svg'); if (icon) { icon.classList.remove('rotate-90');} } this.emit('collapse'); return this;} expand() { if (!this.collapsible) return this; if (!this.collapsed) return this; this.collapsed = false; if (this.bodyEl) { this.bodyEl.classList.remove('hidden'); this.bodyEl.classList.add('block'); this.bodyEl.setAttribute('aria-hidden', 'false');} const button = this.el && this.el.querySelector('.aionda-panel-collapse-btn'); if (button) { button.setAttribute('aria-expanded', 'true'); button.setAttribute('aria-label', 'Collapse panel'); const icon = button.querySelector('svg'); if (icon) { icon.classList.add('rotate-90');} } this.emit('expand'); return this;} toggleCollapse() { return this.collapsed ? this.expand() : this.collapse();} add(component) { this.items.push(component); if (this.bodyEl) { if (component.render && typeof component.render === 'function') { const el = component.render(); this.bodyEl.appendChild(el);} else if (component instanceof HTMLElement) { this.bodyEl.appendChild(component);} } return this;} remove(component) { const index = this.items.indexOf(component); if (index !== -1) { this.items.splice(index, 1); if (this.bodyEl) { if (component.el && component.el.parentNode === this.bodyEl) { this.bodyEl.removeChild(component.el);} else if (component instanceof HTMLElement && component.parentNode === this.bodyEl) { this.bodyEl.removeChild(component);} } } return this;} removeAll() { if (this.bodyEl) { this.items.forEach(component => { if (component.el && component.el.parentNode === this.bodyEl) { this.bodyEl.removeChild(component.el);} else if (component instanceof HTMLElement && component.parentNode === this.bodyEl) { this.bodyEl.removeChild(component);} });} this.items = []; return this;} getItems() { return [...this.items];} setMenu(menu) { this.menu = menu; if (menu && this.headerEl) { const toolsEl = this.headerEl.querySelector('.aionda-panel-tools'); if (toolsEl && menu.render) { const menuEl = menu.render(); toolsEl.appendChild(menuEl);} } return this;} getMenu() { return this.menu;} setContextMenu(menu) { this.contextMenu = menu; if (this.el && menu) { this.el.addEventListener('contextmenu', (e) => { e.preventDefault(); if (menu.showAtEvent) { menu.showAtEvent(e, this.el);} });} return this;} getContextMenu() { return this.contextMenu;} onClick(event) { this.emit('click', { panel: this, event });} onFocus(event) { this.emit('focus', { panel: this, event });} onBlur(event) { this.emit('blur', { panel: this, event });} destroy() { if (this.menu && this.menu.destroy) { this.menu.destroy();} if (this.contextMenu && this.contextMenu.destroy) { this.contextMenu.destroy();} this.items.forEach(item => { if (item.destroy && typeof item.destroy === 'function') { item.destroy();} }); this.items = []; super.destroy();} } class Button extends Component { constructor(config = {}) { super(config); this.buttonEl = null; this.version = '1.0.1'; this.apiVersion = '1.0';} getDefaultConfig() { return { ...super.getDefaultConfig(), text: '', icon: '', iconAlign: 'left', variant: 'primary', size: 'md', outline: false, pressed: false, loading: false, block: false, href: undefined, target: undefined, handler: undefined, ariaLabel: undefined, ariaDescription: undefined };} createTemplate() { const isLink = !!this.href; const tag = isLink ? 'a' : 'button'; const attributes = this.getElementAttributes(); const classes = this.getButtonClasses().join(' '); const content = this.getButtonContent(); return ` <${tag} class="${classes}" ${attributes}> ${content} </${tag}> `;} getElementAttributes() { const attrs = []; if (this.href) { attrs.push(`href="${this.href}"`); if (this.target) { attrs.push(`target="${this.target}"`);} attrs.push(`role="button"`);} else { attrs.push(`type="button"`); if (this.disabled) { attrs.push('disabled'); attrs.push('aria-disabled="true"');} } if (this.pressed) attrs.push('aria-pressed="true"'); if (this.loading) attrs.push('aria-busy="true"'); if (this.ariaLabel) { attrs.push(`aria-label="${this.ariaLabel}"`);} else if (this.text) { attrs.push(`aria-label="${this.text}"`);} if (this.ariaDescription) { attrs.push(`aria-describedby="${this.id}-desc"`);} if (!this.disabled) { attrs.push('tabindex="0"');} return attrs.join(' ');} getButtonClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-button', 'inline-flex', 'items-center', 'justify-center', 'font-medium', 'transition-all', 'duration-150', 'focus:outline-none', 'focus:ring-2', 'focus:ring-offset-2', 'dark:focus:ring-offset-gray-800' ]; switch (this.size) { case 'xs': classes.push('px-2.5', 'py-1.5', 'text-xs', 'rounded'); break; case 'sm': classes.push('px-3', 'py-2', 'text-sm', 'rounded-md'); break; case 'md': classes.push('px-4', 'py-2', 'text-sm', 'rounded-md'); break; case 'lg': classes.push('px-4', 'py-2', 'text-base', 'rounded-md'); break; case 'xl': classes.push('px-6', 'py-3', 'text-base', 'rounded-md'); break;} if (this.outline) { classes.push(...this.getOutlineVariantClasses());} else { classes.push(...this.getSolidVariantClasses());} if (this.pressed) classes.push('aionda-button-pressed'); if (this.loading) classes.push('aionda-button-loading', 'cursor-wait'); if (this.block) classes.push('w-full'); if (this.disabled) classes.push('opacity-50', 'cursor-not-allowed', 'dark:opacity-40'); return classes;} getSolidVariantClasses() { switch (this.variant) { case 'primary': return [ 'bg-blue-600', 'text-white', 'border-transparent', 'hover:bg-blue-700', 'focus:ring-blue-500', 'active:bg-blue-800', 'dark:bg-blue-500', 'dark:hover:bg-blue-600', 'dark:focus:ring-blue-400', 'dark:active:bg-blue-700' ]; case 'secondary': return [ 'bg-gray-600', 'text-white', 'border-transparent', 'hover:bg-gray-700', 'focus:ring-gray-500', 'active:bg-gray-800', 'dark:bg-gray-500', 'dark:hover:bg-gray-600', 'dark:focus:ring-gray-400', 'dark:active:bg-gray-700' ]; case 'success': return [ 'bg-green-600', 'text-white', 'border-transparent', 'hover:bg-green-700', 'focus:ring-green-500', 'active:bg-green-800', 'dark:bg-green-500', 'dark:hover:bg-green-600', 'dark:focus:ring-green-400', 'dark:active:bg-green-700' ]; case 'warning': return [ 'bg-yellow-600', 'text-white', 'border-transparent', 'hover:bg-yellow-700', 'focus:ring-yellow-500', 'active:bg-yellow-800', 'dark:bg-yellow-500', 'dark:hover:bg-yellow-600', 'dark:focus:ring-yellow-400', 'dark:active:bg-yellow-700' ]; case 'danger': return [ 'bg-red-600', 'text-white', 'border-transparent', 'hover:bg-red-700', 'focus:ring-red-500', 'active:bg-red-800', 'dark:bg-red-500', 'dark:hover:bg-red-600', 'dark:focus:ring-red-400', 'dark:active:bg-red-700' ]; case 'info': return [ 'bg-blue-600', 'text-white', 'border-transparent', 'hover:bg-blue-700', 'focus:ring-blue-500', 'active:bg-blue-800', 'dark:bg-blue-500', 'dark:hover:bg-blue-600', 'dark:focus:ring-blue-400', 'dark:active:bg-blue-700' ]; case 'light': return [ 'bg-gray-200', 'text-gray-900', 'border-transparent', 'hover:bg-gray-300', 'focus:ring-gray-500', 'active:bg-gray-400', 'dark:bg-gray-700', 'dark:text-gray-100', 'dark:hover:bg-gray-600', 'dark:focus:ring-gray-400', 'dark:active:bg-gray-800' ]; case 'dark': return [ 'bg-gray-800', 'text-white', 'border-transparent', 'hover:bg-gray-900', 'focus:ring-gray-700', 'active:bg-gray-900', 'dark:bg-gray-200', 'dark:text-gray-900', 'dark:hover:bg-gray-300', 'dark:focus:ring-gray-500', 'dark:active:bg-gray-400' ]; default: return [ 'bg-blue-600', 'text-white', 'border-transparent', 'hover:bg-blue-700', 'focus:ring-blue-500', 'active:bg-blue-800', 'dark:bg-blue-500', 'dark:hover:bg-blue-600', 'dark:focus:ring-blue-400', 'dark:active:bg-blue-700' ];} } getOutlineVariantClasses() { switch (this.variant) { case 'primary': return [ 'border', 'border-blue-600', 'text-blue-600', 'bg-transparent', 'hover:bg-blue-50', 'focus:ring-blue-500', 'active:bg-blue-100', 'dark:border-blue-400', 'dark:text-blue-400', 'dark:hover:bg-blue-900/20', 'dark:focus:ring-blue-400', 'dark:active:bg-blue-900/30' ]; case 'secondary': return [ 'border', 'border-gray-600', 'text-gray-600', 'bg-transparent', 'hover:bg-gray-50', 'focus:ring-gray-500', 'active:bg-gray-100', 'dark:border-gray-400', 'dark:text-gray-400', 'dark:hover:bg-gray-800/20', 'dark:focus:ring-gray-400', 'dark:active:bg-gray-800/30' ]; case 'success': return [ 'border', 'border-green-600', 'text-green-600', 'bg-transparent', 'hover:bg-green-50', 'focus:ring-green-500', 'active:bg-green-100', 'dark:border-green-400', 'dark:text-green-400', 'dark:hover:bg-green-900/20', 'dark:focus:ring-green-400', 'dark:active:bg-green-900/30' ]; case 'warning': return [ 'border', 'border-yellow-600', 'text-yellow-600', 'bg-transparent', 'hover:bg-yellow-50', 'focus:ring-yellow-500', 'active:bg-yellow-100', 'dark:border-yellow-400', 'dark:text-yellow-400', 'dark:hover:bg-yellow-900/20', 'dark:focus:ring-yellow-400', 'dark:active:bg-yellow-900/30' ]; case 'danger': return [ 'border', 'border-red-600', 'text-red-600', 'bg-transparent', 'hover:bg-red-50', 'focus:ring-red-500', 'active:bg-red-100', 'dark:border-red-400', 'dark:text-red-400', 'dark:hover:bg-red-900/20', 'dark:focus:ring-red-400', 'dark:active:bg-red-900/30' ]; default: return [ 'border', 'border-blue-600', 'text-blue-600', 'bg-transparent', 'hover:bg-blue-50', 'focus:ring-blue-500', 'active:bg-blue-100', 'dark:border-blue-400', 'dark:text-blue-400', 'dark:hover:bg-blue-900/20', 'dark:focus:ring-blue-400', 'dark:active:bg-blue-900/30' ];} } getButtonContent() { const iconHtml = this.getIconHtml(); const loadingHtml = this.loading ? this.getLoadingHtml() : ''; const textHtml = this.text ? `<span class="aionda-button-text">${this.text}</span>` : ''; if (this.loading) { return `${loadingHtml}${textHtml ? ` ${textHtml}` : ''}`;} if (!iconHtml && !textHtml) { return '';} if (!iconHtml) { return textHtml;} if (this.iconAlign === 'right') { return `${textHtml}${textHtml ? ' ' : ''}${iconHtml}`;} else { return `${iconHtml}${textHtml ? ` ${textHtml}` : ''}`;} } getIconHtml() { if (!this.icon || this.loading) return ''; return `<span class="aionda-button-icon">${this.icon}</span>`;} getLoadingHtml() { return ` <svg class="aionda-button-spinner animate-spin -ml-1 mr-2 h-4 w-4" xmlns="http: <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle> <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"> </path> </svg> `;} render() { if (this.destroyed) { throw new Error('Cannot render destroyed component');} if (this.rendered && this.el) { return this.el;} const template = this.createTemplate(); const wrapper = document.createElement('div'); wrapper.innerHTML = template.trim(); this.el = wrapper.firstElementChild; if (!this.el) { throw new Error('Component template must return a valid HTML element');} this.el.id = this.id; this.applyStyles(); this.setupEventListeners(); this.updateDisabledState(); this.updateAriaAttributes(); this.rendered = true; this.emit('render'); return this.el;} setupEventListeners() { super.setupEventListeners(); this.buttonEl = this.el; this.buttonEl.addEventListener('click', (event) => this.onClick(event)); this.buttonEl.addEventListener('focus', (event) => this.onFocus(event)); this.buttonEl.addEventListener('blur', (event) => this.onBlur(event)); this.buttonEl.addEventListener('keydown', (event) => this.onKeyDown(event));} onClick(event) { if (this.disabled || this.loading) { event.preventDefault(); event.stopPropagation(); return;} this.emit('click', { field: this, event }); if (this.handler) { this.handler(this, event);} } onFocus(event) { this.emit('focus', { field: this, event });} onBlur(event) { this.emit('blur', { field: this, event });} onKeyDown(event) { if (this.disabled || this.loading) { return;} if (event.key === 'Enter' || event.key === ' ') { event.preventDefault(); this.onClick(event);} this.emit('keydown', { field: this, event, key: event.key });} setText(text) { this.text = text; if (this.rendered) { this.updateContent();} return this;} setIcon(icon) { this.icon = icon; if (this.rendered) { this.updateContent();} return this;} setVariant(variant) { this.variant = variant; if (this.rendered) { this.updateClasses();} return this;} setSize(size) { this.size = size; if (this.rendered) { this.updateClasses();} return this;} setLoading(loading) { this.loading = loading; if (this.rendered) { this.updateContent(); this.updateClasses(); this.updateAriaAttributes();} return this;} setPressed(pressed) { this.pressed = pressed; if (this.rendered) { this.buttonEl.setAttribute('aria-pressed', pressed.toString()); this.updateClasses();} return this;} toggle() { return this.setPressed(!this.pressed);} updateContent() { if (this.buttonEl) { this.buttonEl.innerHTML = this.getButtonContent();} } updateClasses() { if (this.buttonEl) { this.buttonEl.className = this.getButtonClasses().join(' ');} } focus() { this.buttonEl?.focus(); return this;} blur() { this.buttonEl?.blur(); return this;} enable() { this.disabled = false; if (this.rendered) { this.updateDisabledState(); this.updateClasses(); this.updateAriaAttributes();} return this;} disable() { this.disabled = true; if (this.rendered) { this.updateDisabledState(); this.updateClasses(); this.updateAriaAttributes();} return this;} setDisabled(disabled) { return disabled ? this.disable() : this.enable();} updateDisabledState() { if (this.buttonEl && !this.href) { if (this.disabled) { this.buttonEl.setAttribute('disabled', '');} else { this.buttonEl.removeAttribute('disabled');} } } updateAriaAttributes() { if (!this.buttonEl) return; if (this.pressed) { this.buttonEl.setAttribute('aria-pressed', 'true');} else { this.buttonEl.removeAttribute('aria-pressed');} if (this.loading) { this.buttonEl.setAttribute('aria-busy', 'true');} else { this.buttonEl.removeAttribute('aria-busy');} if (this.disabled) { this.buttonEl.setAttribute('aria-disabled', 'true');} else { this.buttonEl.removeAttribute('aria-disabled');} } } class Grid extends Component { constructor(config = {}) { super(config); config = config || {}; this.version = '1.1.0'; this.apiVersion = '1.0'; this.store = config.store; this.columns = config.columns || []; this.columns.forEach(col => { if (col.dataIndex && !col.field) { col.field = col.dataIndex;} if (!col.dataIndex && col.field) { col.dataIndex = col.field;} }); this.selectionMode = config.selectionMode || 'single'; this.editable = config.editable === true; this.sortable = config.sortable === true; this.filterable = config.filterable === true; this.resizable = config.resizable === true; this.striped = config.striped !== false; this.hover = config.hover !== false; this.rowNumbers = config.rowNumbers !== false; this.pageSize = config.pageSize || 50; this.virtualScrolling = config.virtualScrolling !== false; this.itemHeight = config.itemHeight || 32; this.visibleRows = config.visibleRows || 20; this.bufferSize = config.bufferSize || 5; this.filterDebounceMs = config.filterDebounceMs || 300; this.filterDebounceTimer = null; this.cachedFilteredRecords = null; this.cacheInvalidated = true; this.scrollTop = 0; this.startIndex = 0; this.endIndex = 0; this.totalHeight = 0; this.selectedRows = new Set(); this.selectedCells = new Set(); this.editingCell = null; this.sortState = new Map(); this.filters = new Map(); this.columnWidths = new Map(); this.columnOrder = this.columns.map(col => col.field); this.columnVisibility = new Map(); this.dragging = null; this.showColumnDialog = false; this.contextMenu = null; this.contextTargetColumn = null; this.headerEl = null; this.bodyEl = null; this.footerEl = null; this.columns.forEach(col => { if (col.width) { this.columnWidths.set(col.field, col.width);} else if (col.flex) { this.columnWidths.set(col.field, 'flex');} else { this.columnWidths.set(col.field, 120);} this.columnVisibility.set(col.field, col.hidden !== true);}); this.boundInvalidateCache = () => this.invalidateCache(); this.boundHandleStoreRemove = () => this.handleStoreRemove(); this.boundHandleStoreClear = () => this.handleStoreClear(); if (this.store) { this.store.on('load', this.boundInvalidateCache); this.store.on('add', this.boundInvalidateCache); this.store.on('remove', this.boundHandleStoreRemove); this.store.on('update', this.boundInvalidateCache); this.store.on('recordupdate', this.boundInvalidateCache); this.store.on('clear', this.boundHandleStoreClear); this.store.on('sort', this.boundInvalidateCache); this.store.on('filter', this.boundInvalidateCache);} } createTemplate() { return ` <div class="${this.getGridClasses().join(' ')}"> <div class="aionda-grid-toolbar flex items-center justify-between p-2 bg-gray-50 dark:bg-gray-800 border-b border-gray-300 dark:border-gray-600"> <div class="flex items-center space-x-2"> <button class="aionda-column-selector-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-1 focus:ring-blue-500 text-gray-900 dark:text-gray-100" title="Show/Hide Columns"> <span class="mr-1">☰</span>${this.t('grid.columns')} </button> </div> <div class="text-xs text-gray-500 dark:text-gray-400"> <span class="aionda-visible-columns-count">${this.getVisibleColumns().length}</span> ${this.t('grid.of')} ${this.columns.length} ${this.t('grid.columnsVisible')} </div> </div> <table class="w-full" role="grid" aria-label="Data grid"> <thead class="aionda-grid-header"> ${this.createHeaderTemplate()} </thead> <tbody class="aionda-grid-body"> ${this.createBodyTemplate()} </tbody> </table> <div id="${this.id}-status" class="sr-only" aria-live="polite" aria-atomic="true"> <!-- Grid status announcements for screen readers --> </div> <div class="aionda-grid-footer"> ${this.createFooterTemplate()} </div> ${this.createColumnSelectorDialog()} </div> `;} createHeaderTemplate() { let html = '<tr class="aionda-grid-header-row border-b-2 border-gray-300 dark:border-gray-600 bg-gray-100 dark:bg-gray-800 font-semibold">'; if (this.rowNumbers) { html += '<th class="aionda-grid-cell aionda-grid-row-number-header w-12 px-2 py-2 text-center text-gray-500 dark:text-gray-400 border-r border-gray-300 dark:border-gray-600">#</th>';} this.getVisibleOrderedColumns().forEach((col, index) => { const rawWidth = this.columnWidths.get(col.field); const width = this.getColumnWidth(col.field); const sortDirection = this.sortState.get(col.field); const sortIcon = sortDirection ? (sortDirection.direction === 'ASC' ? '↑' : '↓') : ''; const sortClass = sortDirection ? (sortDirection.direction === 'ASC' ? 'sort-asc' : 'sort-desc') : ''; const sortableClass = (this.sortable && col.sortable !== false) ? 'sortable cursor-pointer hover:text-blue-600 dark:hover:text-blue-400' : ''; const styleStr = rawWidth !== 'flex' ? `width: ${width}px; min-width: ${width}px;` : `flex-grow: ${col.flex || 1};`; let ariaSortAttr = ''; if (this.sortable && col.sortable !== false) { if (sortDirection) { ariaSortAttr = `aria-sort="${sortDirection.direction === 'ASC' ? 'ascending' : 'descending'}"`;} } html += ` <th class="aionda-grid-cell aionda-grid-header-cell relative border-r border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-800 ${sortableClass} ${sortClass} text-gray-900 dark:text-gray-100" data-field="${col.field}" data-column-index="${index}" data-sort-field="${col.field}" draggable="true" scope="col" ${ariaSortAttr} style="${styleStr}"> <div class="flex items-center justify-between px-3 py-2"> <span class="aionda-grid-header-text"> <span class="aionda-grid-drag-handle cursor-grab mr-2 text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300">⋮⋮</span> ${col.text || col.field} ${sortIcon} </span> ${this.resizable ? `<div class="aionda-grid-resizer absolute right-0 top-0 bottom-0 w-1 cursor-col-resize hover:bg-blue-500 dark:hover:bg-blue-400" data-resize-field="${col.field}"></div>` : ''} </div> ${this.filterable ? this.createFilterTemplate(col) : ''} </th> `;}); html += '</tr>'; return html;} createFilterTemplate(col) { const filterValue = this.filters.get(col.field) || ''; const hasFilter = filterValue.trim().length > 0; const placeholder = this.getFilterPlaceholder(col); return ` <div class="aionda-grid-filter px-2 pb-2"> <div class="relative"> <input type="text" class="aionda-grid-filter-input w-full px-2 py-1 pr-6 text-xs border border-gray-300 dark:border-gray-600 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 dark:focus:ring-blue-400 bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 ${hasFilter ? 'border-blue-400 dark:border-blue-500 bg-blue-50 dark:bg-blue-900/20' : ''}" placeholder="${placeholder}" value="${filterValue}" data-filter-field="${col.field}" data-filter-type="${col.type || 'text'}"> ${hasFilter ? ` <button class="aionda-filter-clear absolute right-1 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400 dark:text-gray-500 hover:text-red-500 dark:hover:text-red-400 flex items-center justify-center rounded text-xs" data-clear-filter="${col.field}" title="Clear filter">×</button> ` : ` <div class="aionda-filter-icon absolute right-1 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-300 dark:text-gray-600 flex items-center justify-center text-xs">🔍</div> `} </div> ${hasFilter ? `<div class="aionda-filter-matches text-xs text-blue-600 dark:text-blue-400 mt-1 px-1">${this.getFilterMatches(col.field)} matches</div>` : ''} </div> `;} createBodyTemplate() { if (!this.store || this.store.getCount() === 0) { return '<tr><td colspan="100%" class="aionda-grid-empty p-8 text-center text-gray-500 dark:text-gray-400">No data to display</td></tr>';} let html = ''; const records = this.getFilteredAndSortedRecords(); records.forEach((record, rowIndex) => { const isSelected = this.selectedRows.has(rowIndex); const rowClass = [ 'aionda-grid-row border-b border-gray-200 dark:border-gray-700 cursor-pointer', isSelected ? 'selected bg-blue-100 dark:bg-blue-900' : '', this.hover ? 'hover:bg-blue-50 dark:hover:bg-blue-900/50' : '', this.striped && rowIndex % 2 === 1 ? 'bg-gray-50 dark:bg-gray-800' : '' ].filter(Boolean).join(' '); html += `<tr class="${rowClass}" data-row-index="${rowIndex}" aria-rowindex="${rowIndex + 1}" ${isSelected ? 'aria-selected="true"' : ''}>`; if (this.rowNumbers) { html += `<td class="aionda-grid-cell aionda-grid-rownumber w-12 px-2 py-2 text-center text-gray-500 dark:text-gray-400 border-r border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800" aria-colindex="1">${rowIndex + 1}</td>`;} this.getVisibleOrderedColumns().forEach(col => { const rawWidth = this.columnWidths.get(col.field); const width = this.getColumnWidth(col.field); const value = this.getCellValue(record, col); const cellKey = `${rowIndex}-${col.field}`; const isEditing = this.editingCell === cellKey; html += ` <td class="aionda-grid-cell aionda-grid-data-cell border-r border-gray-200 dark:border-gray-700 relative text-gray-900 dark:text-gray-100" data-row="${rowIndex}" data-field="${col.field}" aria-colindex="${this.showRowNumbers ? this.getVisibleOrderedColumns().indexOf(col) + 2 : this.getVisibleOrderedColumns().indexOf(col) + 1}" style="${rawWidth !== 'flex' ? `width: ${width}px; min-width: ${width}px;` : `flex-grow: ${col.flex || 1};`}"> <div class="px-3 py-2"> ${isEditing ? this.createCellEditor(value, col) : this.formatCellValue(value, col)} </div> </td> `;}); html += '</tr>';}); return html;} createCellEditor(value, col) { const inputType = col.type === 'number' ? 'number' : 'text'; return ` <input type="${inputType}" class="aionda-grid-cell-editor" value="${value || ''}" data-edit-row="${this.editingCell ? this.editingCell.split('-')[0] : ''}" data-edit-field="${this.editingCell ? this.editingCell.split('-')[1] : ''}" autofocus> `;} formatCellValue(value, col) { if (value == null) return ''; if (col.renderer && typeof col.renderer === 'function') { return col.renderer(value);} let formattedValue = ''; if (col.type === 'number' && typeof value === 'number') { formattedValue = value.toLocaleString();} else if (col.type === 'date' && value instanceof Date) { formattedValue = value.toLocaleDateString();} else if (col.type === 'boolean') { formattedValue = (value === true || value === 'true') ? '✓' : '✗';} else { formattedValue = String(value);} const filterValue = this.filters.get(col.field); if (filterValue && filterValue.trim()) { formattedValue = this.highlightFilterMatch(formattedValue, filterValue);} return formattedValue;} createFooterTemplate() { if (!this.store) return ''; const totalRecords = this.store.getCount(); const filteredCount = this.getFilteredAndSortedRecords().length; return ` <div class="aionda-grid-footer-row flex items-center justify-between px-4 py-2 bg-gray-50 dark:bg-gray-800 border-t border-gray-300 dark:border-gray-600 text-sm text-gray-600 dark:text-gray-300"> <div class="aionda-grid-info"> ${filteredCount !== totalRecords ? `${filteredCount} of ` : ''}${totalRecords} records </div> <div class="aionda-grid-selection"> ${this.selectedRows.size > 0 ? `${this.selectedRows.size} selected` : ''} </div> </div> `;} getGridClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-grid', 'border border-gray-300 dark:border-gray-600 rounded-lg overflow-hidden bg-white dark:bg-gray-900', 'text-sm select-none' ]; if (this.striped) { classes.push('aionda-grid-striped');} if (this.hover) { classes.push('aionda-grid-hover');} return classes;} setupEventListeners() { super.setupEventListeners(); this.el.gridComponent = this; this.headerEl = this.el.querySelector('.aionda-grid-header'); this.bodyEl = this.el.querySelector('.aionda-grid-body'); this.footerEl = this.el.querySelector('.aionda-grid-footer'); if (BrowserDetect.isIE() || BrowserDetect.isOldEdge()) { this.setupIEEventFixes();} this.el.addEventListener('click', (e) => { const resizer = e.target.closest('.aionda-grid-resizer'); const dragHandle = e.target.closest('.aionda-grid-drag-handle'); const filterClear = e.target.closest('.aionda-filter-clear'); const columnSelector = e.target.closest('.aionda-column-selector-btn'); const dialogBtn = e.target.closest('.aionda-close-dialog, .aionda-show-all-columns, .aionda-hide-all-columns, .aionda-save-column-config'); const headerCell = e.target.closest('.aionda-grid-header-cell'); const row = e.target.closest('.aionda-grid-row'); if (resizer) { e.preventDefault(); e.stopPropagation(); return;} if (dragHandle) { e.preventDefault(); e.stopPropagation(); return;} if (filterClear && filterClear.dataset.clearFilter) { e.preventDefault(); e.stopPropagation(); this.clearFilter(filterClear.dataset.clearFilter); return;} if (columnSelector) { e.preventDefault(); e.stopPropagation(); this.toggleColumnSelector(); return;} if (dialogBtn) { e.preventDefault(); e.stopPropagation(); this.handleDialogButton(dialogBtn); return;} if (headerCell && headerCell.dataset.sortField && this.sortable) { const filterInput = e.target.closest('.aionda-grid-filter-input'); if (!filterInput) { e.preventDefault(); e.stopPropagation(); this.toggleSort(headerCell.dataset.sortField); return;} } if (row && row.dataset.rowIndex !== undefined) { const cellEditor = e.target.closest('.aionda-grid-cell-editor'); if (!cellEditor) { e.preventDefault(); e.stopPropagation(); const rowIndex = parseInt(row.dataset.rowIndex); this.selectRow(rowIndex, e); return;} } }); if (this.editable) { this.el.addEventListener('dblclick', (e) => { const cell = e.target.closest('.aionda-grid-data-cell'); if (cell && cell.dataset.row !== undefined && cell.dataset.field) { e.preventDefault(); e.stopPropagation(); const rowIndex = parseInt(cell.dataset.row); const field = cell.dataset.field; this.startEdit(rowIndex, field);} });} if (this.filterable) { this.el.addEventListener('input', (e) => { const filterInput = e.target.closest('.aionda-grid-filter-input'); if (filterInput && filterInput.dataset.filterField) { this.applyFilter(filterInput.dataset.filterField, filterInput.value);} });} this.el.addEventListener('blur', (e) => { const editor = e.target.closest('.aionda-grid-cell-editor'); if (editor) { this.finishEdit(editor);} }, true); this.el.addEventListener('keydown', (e) => { const editor = e.target.closest('.aionda-grid-cell-editor'); if (editor) { this.handleEditKeydown(e, editor);} }); if (this.resizable) { this.el.addEventListener('mousedown', (e) => { const resizer = e.target.closest('.aionda-grid-resizer'); if (resizer && resizer.dataset.resizeField) { this.startResize(e, resizer.dataset.resizeField);} });} document.addEventListener('mousemove', (e) => this.handleResize(e)); document.addEventListener('mouseup', (e) => this.stopResize(e)); this.el.addEventListener('dragstart', (e) => { const headerCell = e.target.closest('.aionda-grid-header-cell'); if (headerCell && headerCell.dataset.field) { this.startColumnDrag(e, headerCell.dataset.field);} }); this.el.addEventListener('dragover', (e) => { e.preventDefault(); const headerCell = e.target.closest('.aionda-grid-header-cell'); if (headerCell && this.dragging) { this.handleColumnDragOver(e, headerCell);} }); this.el.addEventListener('drop', (e) => { e.preventDefault(); const headerCell = e.target.closest('.aionda-grid-header-cell'); if (headerCell && this.dragging) { this.handleColumnDrop(e, headerCell.dataset.field);} }); this.el.addEventListener('dragend', (e) => { this.endColumnDrag();}); this.setupContextMenu(); this.el.addEventListener('change', (e) => { const checkbox = e.target.closest('.aionda-column-checkbox'); if (checkbox && checkbox.dataset.columnField) { this.toggleColumnVisibility(checkbox.dataset.columnField, checkbox.checked);} }); this.boundDocumentClick = (e) => { if (this.showColumnDialog && !this.el.contains(e.target)) { const isMenuClick = e.target.closest('.aionda-menu, .aionda-menu-item'); if (!isMenuClick) { this.hideColumnSelector();} } }; document.addEventListener('click', this.boundDocumentClick); this.boundDocumentKeydown = (e) => { if (e.key === 'Escape' && this.showColumnDialog) { const visibleMenus = document.querySelectorAll('.aionda-menu:not(.hidden)'); if (visibleMenus.length === 0) { this.hideColumnSelector();} } }; document.addEventListener('keydown', this.boundDocumentKeydown); this.setupKeyboardNavigation();} setupIEEventFixes() { if (this.el) { this.el.addEventListener('mouseover', (e) => { const row = e.target.closest('.aionda-grid-row'); if (row && this.hover) { row.classList.add('hover:bg-blue-50', 'dark:hover:bg-blue-900/50');} }); this.el.addEventListener('mouseout', (e) => { const row = e.target.closest('.aionda-grid-row'); if (row && this.hover) { row.classList.remove('hover:bg-blue-50', 'dark:hover:bg-blue-900/50');} }); if (BrowserDetect.isIE()) { this.el.addEventListener('selectstart', (e) => { if (e.target.closest('.aionda-grid-header-cell[draggable="true"]')) { e.preventDefault();} });} } } handleDialogButton(btn) { if (btn.classList.contains('aionda-close-dialog')) { this.hideColumnSelector();} else if (btn.classList.contains('aionda-show-all-columns')) { this.showAllColumns(); this.updateDialogCheckboxes();} else if (btn.classList.contains('aionda-hide-all-columns')) { this.hideAllColumns(); this.updateDialogCheckboxes();} else if (btn.classList.contains('aionda-save-column-config')) { this.saveColumnConfiguration(); this.hideColumnSelector();} } setupKeyboardNavigation() { this.el.addEventListener('keydown', (e) => { const activeElement = document.activeElement; const isFilterInput = activeElement && activeElement.closest('.aionda-grid-filter-input'); const isCellEditor = activeElement && activeElement.closest('.aionda-grid-cell-editor'); if (isFilterInput || isCellEditor) { return;} const gridFocused = this.el.contains(activeElement) || activeElement === this.el; if (!gridFocused) return; switch (e.key) { case 'Escape': if (this.editingCell) { this.editingCell = null; this.refresh(); e.preventDefault();} break; case 'Delete': if (this.selectedRows.size > 0) { this.emit('deleteRequest', { selections: this.getSelections() }); e.preventDefault();} break;} }); this.el.addEventListener('keydown', (e) => { if (e.key === 'Delete' && this.selectedRows.size > 0) { const activeElement = document.activeElement; const isInput = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA'); const isEditor = activeElement && activeElement.closest('.aionda-grid-cell-editor'); if (!isInput && !isEditor) { this.emit('deleteRequest', { selections: this.getSelections() }); e.preventDefault();} } }, true);} getColumnWidth(field) { const width = this.columnWidths.get(field); return width === 'flex' ? 150 : width;} startResize(event, field) { event.stopPropagation(); this.resizing = { field, startX: event.clientX, startWidth: this.getColumnWidth(field) }; document.body.style.cursor = 'col-resize';} handleResize(event) { if (!this.resizing) return; const deltaX = event.clientX - this.resizing.startX; const newWidth = Math.max(50, this.resizing.startWidth + deltaX); this.columnWidths.set(this.resizing.field, newWidth); this.updateColumnWidths();} stopResize() { if (this.resizing) { this.resizing = null; document.body.style.cursor = '';} } updateColumnWidths() { if (!this.rendered) return; this.columns.forEach(col => { const width = this.getColumnWidth(col.field); const headerCell = this.el.querySelector(`[data-field="${col.field}"]`); const bodyCells = this.el.querySelectorAll(`[data-field="${col.field}"]`); if (headerCell) { headerCell.style.width = `${width}px`; headerCell.style.minWidth = `${width}px`;} bodyCells.forEach(cell => { cell.style.width = `${width}px`; cell.style.minWidth = `${width}px`;});});} toggleSort(field) { const current = this.sortState.get(field); let newDirection; if (!current) { newDirection = 'ASC';} else if (current.direction === 'ASC') { newDirection = 'DESC';} else { this.sortState.delete(field); this.updateSortIndicators(); this.refreshBody(); return;} this.sortState.clear(); this.sortState.set(field, { direction: newDirection }); this.updateSortIndicators(); this.refreshBody();} updateSortIndicators() { if (!this.rendered) return; this.columns.forEach(col => { const headerCell = this.el.querySelector(`th[data-sort-field="${col.field}"]`); if (headerCell && this.sortable && col.sortable !== false) { const sortDirection = this.sortState.get(col.field); headerCell.classList.remove('sort-asc', 'sort-desc'); if (sortDirection) { const sortClass = sortDirection.direction === 'ASC' ? 'sort-asc' : 'sort-desc'; headerCell.classList.add(sortClass); headerCell.setAttribute('aria-sort', sortDirection.direction === 'ASC' ? 'ascending' : 'descending'); const headerText = headerCell.querySelector('.aionda-grid-header-text'); if (headerText) { const sortIcon = sortDirection.direction === 'ASC' ? '↑' : '↓'; const text = (col.text || col.field) + ' ' + sortIcon; const dragHandle = headerText.querySelector('.aionda-grid-drag-handle'); headerText.innerHTML = ''; if (dragHandle) { headerText.appendChild(dragHandle);} else { headerText.innerHTML += '<span class="aionda-grid-drag-handle cursor-grab mr-2 text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300">⋮⋮</span>';} headerText.innerHTML += (col.text || col.field) + ' ' + sortIcon;} } else { headerCell.removeAttribute('aria-sort'); const headerText = headerCell.querySelector('.aionda-grid-header-text'); if (headerText) { const dragHandle = headerText.querySelector('.aionda-grid-drag-handle'); headerText.innerHTML = ''; if (dragHandle) { headerText.appendChild(dragHandle);} else { headerText.innerHTML += '<span class="aionda-grid-drag-handle cursor-grab mr-2 text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300">⋮⋮</span>';} headerText.innerHTML += (col.text || col.field);} } } });} applyFilter(field, value) { if (value.trim()) { this.filters.set(field, value.trim());} else { this.filters.delete(field);} this.refreshBody();} clearFilter(field) { this.filters.delete(field); this.refresh();} getFilterPlaceholder(col) { switch (col.type) { case 'number': return 'e.g. >1000, <5000'; case 'date': return 'e.g. 2024, Jan'; case 'boolean': return 'true/false'; default: return `Search ${col.text || col.field}...`;} } getFilterMatches(field) { const records = this.store ? this.store.getRecords() : []; const filterValue = this.filters.get(field); if (!filterValue) return 0; return records.filter(record => { const cellValue = this.getCellValue(record, { field }); return this.matchesFilter(cellValue, filterValue);}).length;} matchesFilter(cellValue, filterValue) { const cellStr = String(cellValue).toLowerCase(); const filterStr = filterValue.toLowerCase(); if (filterStr.startsWith('>')) { const num = parseFloat(filterStr.substring(1)); return !isNaN(num) && parseFloat(cellValue) > num;} if (filterStr.startsWith('<')) { const num = parseFloat(filterStr.substring(1)); return !isNaN(num) && parseFloat(cellValue) < num;} if (filterStr.startsWith('=')) { return cellStr === filterStr.substring(1);} return cellStr.includes(filterStr);} highlightFilterMatch(text, filterValue) { if (!filterValue || !text) return text; if (filterValue.startsWith('>') || filterValue.startsWith('<') || filterValue.startsWith('=')) { return text;} const regex = new RegExp(`(${this.escapeRegex(filterValue)})`, 'gi'); return text.replace(regex, '<mark class="aionda-filter-highlight">$1</mark>');} escapeRegex(string) { return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');} getFilteredAndSortedRecords() { if (!this.store) return []; let records = this.store.getRecords(); if (this.filters.size > 0) { records = records.filter(record => { return Array.from(this.filters.entries()).every(([field, filterValue]) => { const cellValue = this.getCellValue(record, { field }); return this.matchesFilter(cellValue, filterValue);});});} if (this.sortState.size > 0) { const [field, sortInfo] = Array.from(this.sortState.entries())[0]; records.sort((a, b) => { const aVal = this.getCellValue(a, { field }); const bVal = this.getCellValue(b, { field }); let comparison = 0; if (aVal < bVal) comparison = -1; else if (aVal > bVal) comparison = 1; return sortInfo.direction === 'DESC' ? -comparison : comparison;});} return records;} getCellValue(record, col) { if (col.dataIndex) { return record[col.dataIndex];} return record[col.field];} selectRow(rowIndex, event) { if (this.selectionMode === 'none') return; if (this.selectionMode === 'single') { this.selectedRows.clear(); this.selectedRows.add(rowIndex);} else if (this.selectionMode === 'multi') { if (event.ctrlKey || event.metaKey) { if (this.selectedRows.has(rowIndex)) { this.selectedRows.delete(rowIndex);} else { this.selectedRows.add(rowIndex);} } else if (event.shiftKey && this.selectedRows.size > 0) { const lastSelected = Math.max(...this.selectedRows); const start = Math.min(rowIndex, lastSelected); const end = Math.max(rowIndex, lastSelected); this.selectedRows.clear(); for (let i = start; i <= end; i++) { this.selectedRows.add(i);} } else { this.selectedRows.clear(); this.selectedRows.add(rowIndex);} } this.updateRowSelection(); const records = this.getFilteredAndSortedRecords(); const selectedRecords = Array.from(this.selectedRows).map(index => records[index]).filter(Boolean); this.emit('selectionchange', { selections: selectedRecords, record: selectedRecords.length === 1 ? selectedRecords[0] : null });} updateRowSelection() { if (!this.rendered) return; const rows = this.el.querySelectorAll('.aionda-grid-row'); rows.forEach((row, index) => { if (this.selectedRows.has(index)) { row.classList.add('selected', 'bg-blue-100', 'dark:bg-blue-900'); row.setAttribute('aria-selected', 'true'); if (this.hover) { row.classList.remove('hover:bg-blue-50', 'dark:hover:bg-blue-900/50');} } else { row.classList.remove('selected', 'bg-blue-100', 'dark:bg-blue-900'); row.removeAttribute('aria-selected'); if (this.hover) { row.classList.add('hover:bg-blue-50', 'dark:hover:bg-blue-900/50');} } }); this.updateFooter();} startEdit(rowIndex, field) { if (!this.editable) return; const newEditingCell = `${rowIndex}-${field}`; if (this.editingCell === newEditingCell) { return;} if (this.editingCell && this.editingCell !== newEditingCell) { const existingEditor = this.el.querySelector('.aionda-grid-cell-editor'); if (existingEditor) { this.finishEditInPlace(existingEditor);} } this.editingCell = newEditingCell; this.convertCellToEditor(rowIndex, field);} convertCellToEditor(rowIndex, field) { const cell = this.el.querySelector(`.aionda-grid-data-cell[data-row="${rowIndex}"][data-field="${field}"]`); if (!cell) return; const cellDiv = cell.querySelector('div'); if (!cellDiv) return; const col = this.columns.find(c => c.field === field); const records = this.getFilteredAndSortedRecords(); const record = records[rowIndex]; if (record) { const value = this.getCellValue(record, col); const inputType = col.type === 'number' ? 'number' : 'text'; cellDiv.innerHTML = ` <input type="${inputType}" class="aionda-grid-cell-editor" value="${value || ''}" data-edit-row="${rowIndex}" data-edit-field="${field}" autofocus> `; const editor = cellDiv.querySelector('.aionda-grid-cell-editor'); if (editor) { editor.focus(); editor.select(); editor.addEventListener('blur', (e) => this.finishEdit(editor)); editor.addEventListener('keydown', (e) => this.handleEditKeydown(e, editor));} } } finishEditInPlace(inputEl) { if (!this.editingCell) return; const [rowIndex, field] = this.editingCell.split('-'); const newValue = inputEl.value; const records = this.getFilteredAndSortedRecords(); const record = records[parseInt(rowIndex)]; if (record) { const col = this.columns.find(c => c.field === field); const oldValue = record[field]; let finalValue = newValue; if (col && col.type === 'number') { finalValue = parseFloat(newValue) || 0;} record[field] = finalValue; if (this.store) { const storeIndex = this.store.data.indexOf(record); if (storeIndex !== -1) { this.store.emit('recordupdate', { record, index: storeIndex, changes: { [field]: finalValue }, oldValue, newValue: finalValue }); this.store.emit('update');} } this.emit('cellchange', { record, field, value: finalValue, rowIndex: parseInt(rowIndex), oldValue }); const cell = this.el.querySelector(`.aionda-grid-data-cell[data-row="${rowIndex}"][data-field="${field}"]`); if (cell) { const cellDiv = cell.querySelector('div'); if (cellDiv) { cellDiv.innerHTML = this.formatCellValue(finalValue, col);} } } } finishEdit(inputEl) { if (!this.editingCell) return; const [rowIndex, field] = this.editingCell.split('-'); const newValue = inputEl.value; const records = this.getFilteredAndSortedRecords(); const record = records[parseInt(rowIndex)]; if (record) { const col = this.columns.find(c => c.field === field); const oldValue = record[field]; let finalValue = newValue; if (col && col.type === 'number') { finalValue = parseFloat(newValue) || 0;} record[field] = finalValue; if (this.store) { const storeIndex = this.store.data.indexOf(record); if (storeIndex !== -1) { this.store.emit('recordupdate', { record, index: storeIndex, changes: { [field]: finalValue }, oldValue, newValue: finalValue }); this.store.emit('update');} } this.emit('cellchange', { record, field, value: finalValue, rowIndex: parseInt(rowIndex), oldValue }); const cell = this.el.querySelector(`.aionda-grid-data-cell[data-row="${rowIndex}"][data-field="${field}"]`); if (cell) { const cellDiv = cell.querySelector('div'); if (cellDiv) { cellDiv.innerHTML = this.formatCellValue(finalValue, col);} } } this.editingCell = null;} handleEditKeydown(event, inputEl) { if (event.key === 'Enter') { this.finishEdit(inputEl);} else if (event.key === 'Escape') { this.cancelEdit();} } cancelEdit() { if (!this.editingCell) return; const [rowIndex, field] = this.editingCell.split('-'); const cell = this.el.querySelector(`.aionda-grid-data-cell[data-row="${rowIndex}"][data-field="${field}"]`); if (cell) { const cellDiv = cell.querySelector('div'); if (cellDiv) { const records = this.getFilteredAndSortedRecords(); const record = records[parseInt(rowIndex)]; const col = this.columns.find(c => c.field === field); if (record && col) { const originalValue = this.getCellValue(record, col); cellDiv.innerHTML = this.formatCellValue(originalValue, col);} } } this.editingCell = null;} getOrderedColumns() { return this.columnOrder.map(field => this.columns.find(col => col.field === field) ).filter(Boolean);} getVisibleColumns() { return this.columns.filter(col => this.columnVisibility.get(col.field) === true);} getVisibleOrderedColumns() { return this.columnOrder.map(field => this.columns.find(col => col.field === field) ).filter(col => col && this.columnVisibility.get(col.field) === true);} startColumnDrag(event, field) { this.dragging = { field, startIndex: this.columnOrder.indexOf(field) }; const headerCell = event.target.closest('.aionda-grid-header-cell'); headerCell.style.opacity = '0.5'; headerCell.classList.add('cursor-grabbing'); event.dataTransfer.effectAllowed = 'move'; event.dataTransfer.setData('text/plain', field);} handleColumnDragOver(event, headerCell) { const rect = headerCell.getBoundingClientRect(); const midPoint = rect.left + rect.width / 2; this.el.querySelectorAll('.aionda-drop-indicator').forEach(el => el.remove()); const indicator = document.createElement('div'); indicator.className = 'aionda-drop-indicator absolute top-0 bottom-0 w-0.5 bg-blue-500 z-20'; if (event.clientX < midPoint) { indicator.style.left = '0px'; headerCell.style.position = 'relative'; headerCell.appendChild(indicator);} else { indicator.style.right = '0px'; headerCell.style.position = 'relative'; headerCell.appendChild(indicator);} } handleColumnDrop(event, targetField) { if (!this.dragging || this.dragging.field === targetField) { this.endColumnDrag(); return;} const sourceField = this.dragging.field; const sourceIndex = this.columnOrder.indexOf(sourceField); const targetIndex = this.columnOrder.indexOf(targetField); const headerCell = event.target.closest('.aionda-grid-header-cell'); const rect = headerCell.getBoundingClientRect(); const midPoint = rect.left + rect.width / 2; const dropBefore = event.clientX < midPoint; this.columnOrder.splice(sourceIndex, 1); let newIndex = targetIndex; if (sourceIndex < targetIndex && !dropBefore) { newIndex = targetIndex;} else if (sourceIndex < targetIndex && dropBefore) { newIndex = targetIndex - 1;} else if (sourceIndex > targetIndex && dropBefore) { newIndex = targetIndex;} else if (sourceIndex > targetIndex && !dropBefore) { newIndex = targetIndex + 1;} this.columnOrder.splice(newIndex, 0, sourceField); this.endColumnDrag(); this.refresh(); this.emit('columnreorder', { field: sourceField, oldIndex: sourceIndex, newIndex: newIndex, newOrder: [...this.columnOrder] });} endColumnDrag() { this.el.querySelectorAll('.aionda-drop-indicator').forEach(el => el.remove()); if (this.dragging) { const draggedCell = this.el.querySelector(`[data-field="${this.dragging.field}"]`); if (draggedCell) { draggedCell.style.opacity = ''; draggedCell.classList.remove('cursor-grabbing');} } this.dragging = null;} refresh() { if (!this.rendered) return; const currentDialogHTML = this.createColumnSelectorDialog(); const existingDialog = this.el.querySelector('.aionda-column-dialog'); if ((currentDialogHTML && !existingDialog) || (!currentDialogHTML && existingDialog)) { if (existingDialog) { existingDialog.remove();} if (currentDialogHTML) { this.el.insertAdjacentHTML('beforeend', currentDialogHTML);} } this.headerEl.innerHTML = this.createHeaderTemplate(); this.bodyEl.innerHTML = this.createBodyTemplate(); this.footerEl.innerHTML = this.createFooterTemplate(); this.updateVisibleColumnCount(); this.updateColumnWidths(); this.updateRowSelection();} refreshBody() { if (!this.rendered) return; this.bodyEl.innerHTML = this.createBodyTemplate(); this.footerEl.innerHTML = this.createFooterTemplate(); this.updateRowSelection(); this.updateFilterMatches();} updateFooter() { if (!this.footerEl) return; this.footerEl.innerHTML = this.createFooterTemplate();} updateFilterMatches() { if (!this.rendered) return; this.columns.forEach(col => { const filterValue = this.filters.get(col.field) || ''; const hasFilter = filterValue.trim().length > 0; const filterContainer = this.el.querySelector(`[data-filter-field="${col.field}"]`)?.closest('.aionda-grid-filter'); if (filterContainer) { const input = filterContainer.querySelector('.aionda-grid-filter-input'); if (input) { if (hasFilter) { input.classList.add('border-blue-400', 'dark:border-blue-500', 'bg-blue-50', 'dark:bg-blue-900/20');} else { input.classList.remove('border-blue-400', 'dark:border-blue-500', 'bg-blue-50', 'dark:bg-blue-900/20');} } const existingButton = filterContainer.querySelector('.aionda-filter-clear, .aionda-filter-icon'); if (existingButton) { existingButton.remove();} const inputContainer = filterContainer.querySelector('.relative'); if (hasFilter) { const clearBtn = document.createElement('button'); clearBtn.className = 'aionda-filter-clear absolute right-1 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400 dark:text-gray-500 hover:text-red-500 dark:hover:text-red-400 flex items-center justify-center rounded text-xs'; clearBtn.setAttribute('data-clear-filter', col.field); clearBtn.setAttribute('title', 'Clear filter'); clearBtn.textContent = '×'; inputContainer.appendChild(clearBtn);} else { const icon = document.createElement('div'); icon.className = 'aionda-filter-icon absolute right-1 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-300 dark:text-gray-600 flex items-center justify-center text-xs'; icon.textContent = '🔍'; inputContainer.appendChild(icon);} const existingMatches = filterContainer.querySelector('.aionda-filter-matches'); if (existingMatches) { existingMatches.remove();} if (hasFilter) { const matchesDiv = document.createElement('div'); matchesDiv.className = 'aionda-filter-matches text-xs text-blue-600 dark:text-blue-400 mt-1 px-1'; matchesDiv.textContent = `${this.getFilterMatches(col.field)} matches`; filterContainer.appendChild(matchesDiv);} } });} getStore() { return this.store;} getSelections() { const records = this.getFilteredAndSortedRecords(); return Array.from(this.selectedRows).map(index => records[index]).filter(Boolean);} getSelectedRecords() { return this.getSelections();} getSelection() { return this.getSelections();} clearSelections() { this.selectedRows.clear(); this.updateRowSelection();} clearSelection() { this.selectedRows.clear(); this.updateRowSelection(); this.emit('selectionchange', { selections: [], record: null });} clearFilters() { this.filters.clear(); if (this.rendered) { const filterInputs = this.el.querySelectorAll('.aionda-grid-filter-input'); filterInputs.forEach(input => { input.value = '';});} this.refresh();} selectAll() { if (this.selectionMode === 'multi') { const recordCount = this.getFilteredAndSortedRecords().length; this.selectedRows.clear(); for (let i = 0; i < recordCount; i++) { this.selectedRows.add(i);} this.updateRowSelection(); const records = this.getFilteredAndSortedRecords(); const selectedRecords = Array.from(this.selectedRows).map(index => records[index]).filter(Boolean); this.emit('selectionchange', { selections: selectedRecords, record: selectedRecords.length === 1 ? selectedRecords[0] : null });} } toggleColumnVisibility(field, visible) { this.columnVisibility.set(field, visible); this.refresh(); this.updateVisibleColumnCount(); this.emit('columnvisibilitychange', { field, visible, visibleColumns: this.getVisibleColumns().map(col => col.field) });} showColumn(field) { this.toggleColumnVisibility(field, true);} hideColumn(field) { this.toggleColumnVisibility(field, false);} showAllColumns() { this.columns.forEach(col => { this.columnVisibility.set(col.field, true);}); this.refresh(); this.updateVisibleColumnCount(); this.emit('columnvisibilitychange', { action: 'showAll', visibleColumns: this.getVisibleColumns().map(col => col.field) });} hideAllColumns() { this.columns.forEach(col => { this.columnVisibility.set(col.field, false);}); this.refresh(); this.updateVisibleColumnCount(); this.emit('columnvisibilitychange', { action: 'hideAll', visibleColumns: [] });} toggleColumnSelector() { this.showColumnDialog = !this.showColumnDialog; this.refresh();} showColumnSelector() { this.showColumnDialog = true; this.refresh();} hideColumnSelector() { this.showColumnDialog = false; this.refresh();} createColumnSelectorDialog() { if (!this.showColumnDialog) return ''; return ` <div class="aionda-column-dialog fixed inset-0 bg-black bg-opacity-50 dark:bg-black dark:bg-opacity-70 flex items-center justify-center z-50"> <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg w-96 max-h-96 overflow-hidden"> <div class="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-600"> <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">Show/Hide Columns</h3> <button class="aionda-close-dialog text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300"> <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path> </svg> </button> </div> <div class="p-4 max-h-64 overflow-y-auto"> <div class="space-y-2"> ${this.columns.map(col => ` <label class="flex items-center cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 p-2 rounded"> <input type="checkbox" class="aionda-column-checkbox mr-3" data-column-field="${col.field}" ${this.columnVisibility.get(col.field) ? 'checked' : ''}> <span class="text-sm text-gray-700 dark:text-gray-300">${col.text || col.field}</span> </label> `).join('')} </div> </div> <div class="flex items-center justify-between p-4 border-t border-gray-200 dark:border-gray-600 bg-gray-50 dark:bg-gray-700"> <div class="flex space-x-2"> <button class="aionda-show-all-columns px-3 py-1 text-xs bg-blue-600 dark:bg-blue-700 text-white rounded hover:bg-blue-700 dark:hover:bg-blue-600">Show All</button> <button class="aionda-hide-all-columns px-3 py-1 text-xs bg-gray-600 dark:bg-gray-500 text-white rounded hover:bg-gray-700 dark:hover:bg-gray-400">Hide All</button> </div> <div class="flex space-x-2"> <button class="aionda-save-column-config px-3 py-1 text-xs bg-green-600 dark:bg-green-700 text-white rounded hover:bg-green-700 dark:hover:bg-green-600">Save Config</button> <button class="aionda-close-dialog px-3 py-1 text-xs bg-gray-400 dark:bg-gray-600 text-white rounded hover:bg-gray-500 dark:hover:bg-gray-500">Close</button> </div> </div> </div> </div> `;} updateVisibleColumnCount() { if (!this.rendered) return; const countEl = this.el.querySelector('.aionda-visible-columns-count'); if (countEl) { countEl.textContent = this.getVisibleColumns().length;} } updateDialogCheckboxes() { if (!this.rendered || !this.showColumnDialog) return; this.columns.forEach(col => { const checkbox = this.el.querySelector(`[data-column-field="${col.field}"]`); if (checkbox) { checkbox.checked = this.columnVisibility.get(col.field);} });} getColumnConfiguration() { return { visibility: Object.fromEntries(this.columnVisibility), order: [...this.columnOrder], widths: Object.fromEntries(this.columnWidths) };} setColumnConfiguration(config) { if (config.visibility) { this.columnVisibility = new Map(Object.entries(config.visibility));} if (config.order) { this.columnOrder = [...config.order];} if (config.widths) { this.columnWidths = new Map(Object.entries(config.widths));} this.refresh(); this.updateVisibleColumnCount();} saveColumnConfiguration(key = 'aionda-grid-columns') { const config = this.getColumnConfiguration(); try { localStorage.setItem(key, JSON.stringify(config)); return true;} catch (e) { console.warn('Failed to save column configuration:', e); return false;} } loadColumnConfiguration(key = 'aionda-grid-columns') { try { const saved = localStorage.getItem(key); if (saved) { const config = JSON.parse(saved); this.setColumnConfiguration(config); return true;} } catch (e) { console.warn('Failed to load column configuration:', e);} return false;} setupContextMenu() { this.el.addEventListener('contextmenu', (e) => { const headerCell = e.target.closest('.aionda-grid-header-cell'); const dataRow = e.target.closest('.aionda-grid-row'); if (headerCell && headerCell.dataset.field) { e.preventDefault(); this.showContextMenu(e, headerCell.dataset.field);} else if (dataRow && dataRow.dataset.rowIndex !== undefined) { e.preventDefault(); const rowIndex = parseInt(dataRow.dataset.rowIndex); this.showRowContextMenu(e, rowIndex);} });} showContextMenu(event, field) { if (this.contextMenu) { this.contextMenu.destroy();} const isVisible = this.columnVisibility.get(field); const menuItems = [ { text: isVisible ? 'Hide Column' : 'Show Column', handler: () => this.toggleColumnVisibility(field, !isVisible) }, { separator: true }, { text: 'Show All Columns', handler: () => this.showAllColumns() }, { text: 'Hide All Other Columns', handler: () => { this.hideAllColumns(); this.showColumn(field);} }, { separator: true }, { text: 'Column Settings...', handler: () => this.showColumnSelector() } ]; this.contextMenu = new Menu({ items: menuItems, contextMenu: true, floating: true }); this.contextMenu.showAt({ x: event.clientX, y: event.clientY });} showRowContextMenu(event, rowIndex) { if (this.contextMenu) { this.contextMenu.destroy();} if (!this.selectedRows.has(rowIndex)) { this.selectedRows.clear(); this.selectedRows.add(rowIndex); this.updateRowSelection();} const records = this.getFilteredAndSortedRecords(); const selectedRecord = records[rowIndex]; const selectedCount = this.selectedRows.size; const menuItems = [ { text: selectedCount > 1 ? `Select All ${selectedCount} Rows` : 'Select Row', handler: () => { if (selectedCount === 1 && this.selectionMode === 'multi') { this.selectAll();} }, disabled: selectedCount > 1 }, { text: 'Deselect All', handler: () => this.clearSelection(), disabled: selectedCount === 0 }, { separator: true }, { text: selectedCount > 1 ? `Copy ${selectedCount} Rows` : 'Copy Row', handler: () => this.copyRowsToClipboard() }, { text: selectedCount > 1 ? `Delete ${selectedCount} Rows` : 'Delete Row', handler: () => this.deleteSelectedRows(), cssClass: 'text-red-600 dark:text-red-400' }, { separator: true }, { text: 'Edit Cell...', handler: () => this.showCellEditDialog(rowIndex), disabled: !this.editable }, { text: 'Row Details...', handler: () => this.showRowDetails(selectedRecord) } ]; this.contextMenu = new Menu({ items: menuItems, contextMenu: true, floating: true }); this.contextMenu.showAt({ x: event.clientX, y: event.clientY });} copyRowsToClipboard() { const records = this.getFilteredAndSortedRecords(); const selectedRecords = Array.from(this.selectedRows).map(index => records[index]).filter(Boolean); if (selectedRecords.length === 0) return; const visibleColumns = this.getVisibleOrderedColumns(); const headers = visibleColumns.map(col => col.text || col.field); const csvData = [headers.join('\t')]; selectedRecords.forEach(record => { const row = visibleColumns.map(col => { const value = this.getCellValue(record, col); return value != null ? String(value) : '';}); csvData.push(row.join('\t'));}); const csvText = csvData.join('\n'); if (navigator.clipboard) { navigator.clipboard.writeText(csvText).then(() => { this.emit('rowsCopied', { count: selectedRecords.length, data: csvText });});} else { const textArea = document.createElement('textarea'); textArea.value = csvText; document.body.appendChild(textArea); textArea.select(); document.execCommand('copy'); document.body.removeChild(textArea); this.emit('rowsCopied', { count: selectedRecords.length, data: csvText });} } deleteSelectedRows() { const records = this.getFilteredAndSortedRecords(); const selectedRecords = Array.from(this.selectedRows).map(index => records[index]).filter(Boolean); if (selectedRecords.length === 0) return; this.emit('deleteRequest', { selections: selectedRecords, indices: Array.from(this.selectedRows) });} showCellEditDialog(rowIndex) { const visibleColumns = this.getVisibleOrderedColumns(); if (visibleColumns.length > 0) { this.startEdit(rowIndex, visibleColumns[0].field);} } showRowDetails(record) { this.emit('rowDetails', { record });} invalidateCache() { this.cacheInvalidated = true; this.cachedFilteredRecords = null; this.refresh();} handleStoreRemove() { const hadSelections = this.selectedRows.size > 0; this.selectedRows.clear(); this.invalidateCache(); if (hadSelections) { this.emit('selectionchange', { selections: [], record: null });} } handleStoreClear() { const hadSelections = this.selectedRows.size > 0; this.selectedRows.clear(); this.invalidateCache(); if (hadSelections) { this.emit('selectionchange', { selections: [], record: null });} } destroy() { if (this.boundDocumentClick) { document.removeEventListener('click', this.boundDocumentClick); this.boundDocumentClick = null;} if (this.boundDocumentKeydown) { document.removeEventListener('keydown', this.boundDocumentKeydown); this.boundDocumentKeydown = null;} document.removeEventListener('mousemove', this.handleResize); document.removeEventListener('mouseup', this.stopResize); if (this.contextMenu) { this.contextMenu.destroy(); this.contextMenu = null;} if (this.filterDebounceTimer) { clearTimeout(this.filterDebounceTimer); this.filterDebounceTimer = null;} if (this.store) { this.store.off('load', this.boundInvalidateCache); this.store.off('add', this.boundInvalidateCache); this.store.off('remove', this.boundHandleStoreRemove); this.store.off('update', this.boundInvalidateCache); this.store.off('recordupdate', this.boundInvalidateCache); this.store.off('clear', this.boundHandleStoreClear); this.store.off('sort', this.boundInvalidateCache); this.store.off('filter', this.boundInvalidateCache);} this.selectedRows.clear(); this.selectedCells.clear(); this.filters.clear(); this.sortState.clear(); this.columnWidths.clear(); this.columnVisibility.clear(); super.destroy();} } class Form extends Component { constructor(config = {}) { super(config); config = config || {}; this.version = '1.0.2'; this.apiVersion = '1.0'; this.url = config.url; this.method = config.method || 'POST'; this.layout = config.layout || 'vertical'; this.labelAlign = config.labelAlign || 'top'; this.labelWidth = config.labelWidth || 120; this.fieldDefaults = config.fieldDefaults || {}; this.trackResetOnLoad = config.trackResetOnLoad || false; this.standardSubmit = config.standardSubmit || false; this.timeout = config.timeout || 30000; this.fields = new Map(); this.values = new Map(); this.originalValues = new Map(); this.errors = new Map(); this.submitting = false; this.valid = true; this.validators = new Map(); this.formEl = null; this.items = []; if (config.items) { this.pendingItems = config.items; config.items.forEach(item => { const field = this.createField(item); this.items.push(field);});} else { this.pendingItems = [];} if (config.fields) { config.fields.forEach(field => { this.add(field);});} } createTemplate() { const classes = this.getFormClasses(); return ` <form class="${classes.join(' ')}" novalidate role="form" aria-label="${this.title || 'Form'}" aria-describedby="${this.id}-status"> <div class="aionda-form-body"> <!-- Form fields will be inserted here --> </div> <div class="aionda-form-buttons hidden"> <!-- Form buttons will be inserted here --> </div> <div id="${this.id}-status" class="aionda-form-status sr-only" aria-live="polite" aria-atomic="true"> <!-- Status messages for screen readers --> </div> </form> `;} getFormClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-form', 'bg-white', 'dark:bg-gray-800' ]; if (this.layout === 'horizontal') { classes.push('aionda-form-horizontal');} else if (this.layout === 'inline') { classes.push('aionda-form-inline', 'flex', 'flex-wrap', 'gap-4');} else { classes.push('aionda-form-vertical', 'space-y-4');} return classes;} setupEventListeners() { super.setupEventListeners(); this.formEl = this.el; this.bodyEl = this.el.querySelector('.aionda-form-body'); this.buttonsEl = this.el.querySelector('.aionda-form-buttons'); if (this.pendingItems && this.pendingItems.length > 0) { this.pendingItems.forEach((itemConfig, index) => { const field = this.items[index]; if (field && field.name) { this.registerField(field, itemConfig);} }); this.pendingItems = [];} this.formEl.addEventListener('submit', (e) => { e.preventDefault(); this.submit();}); this.on('fieldchange', (data) => { this.onFieldChange(data.field, data.value, data.oldValue);}); this.on('fieldvalid', (data) => { this.errors.delete(data.field); this.updateValidationState();}); this.on('fieldinvalid', (data) => { this.errors.set(data.field, data.message); this.updateValidationState();});} add(fieldConfig) { let field; if (fieldConfig.render && typeof fieldConfig.render === 'function') { field = fieldConfig;} else { field = this.createField(fieldConfig);} this.items.push(field); this.registerField(field, fieldConfig); return field;} createField(config) { const cmp = config.cmp || 'textfield'; const fieldClasses = { textfield: TextField, numberfield: NumberField, combobox: ComboBox, checkbox: Checkbox, datefield: DateField, textarea: TextArea, radiogroup: RadioGroup }; const FieldClass = fieldClasses[cmp]; if (FieldClass) { return new FieldClass(config);} const mockField = { name: config.name, fieldLabel: config.fieldLabel || config.label, value: config.value || '', checked: config.checked || false, cmp: cmp, el: null, listeners: new Map(), allowBlank: config.allowBlank !== false, render: () => { const div = document.createElement('div'); div.className = `aionda-${cmp}`; div.innerHTML = `<div class="text-gray-500 p-4 border border-dashed border-gray-300 rounded"> Field: ${config.name} (${cmp}) - Component not yet implemented </div>`; mockField.el = div; return div;}, setValue: (value) => { const oldValue = mockField.value; mockField.value = value; if (mockField.cmp === 'checkbox') { mockField.checked = value;} else if (mockField.cmp === 'radiogroup') { mockField.selectedValue = value;} mockField.emit('change', { value, oldValue });}, getValue: () => { if (mockField.cmp === 'checkbox') { return mockField.checked ? 'on' : '';} else if (mockField.cmp === 'radiogroup') { return mockField.selectedValue || '';} return mockField.value;}, isChecked: () => mockField.checked, on: (event, handler) => { if (!mockField.listeners.has(event)) { mockField.listeners.set(event, new Set());} mockField.listeners.get(event).add(handler);}, emit: (event, data) => { const handlers = mockField.listeners.get(event); if (handlers) { handlers.forEach(handler => handler(data));} } }; return mockField;} registerField(field, fieldConfig) { if (!field.name) return; this.fields.set(field.name, field); Object.assign(field, this.fieldDefaults, fieldConfig); field.form = this; if (fieldConfig.validators || fieldConfig.validator) { const validators = Array.isArray(fieldConfig.validators) ? fieldConfig.validators : [fieldConfig.validator || fieldConfig.validators]; this.validators.set(field.name, validators.filter(Boolean));} if (fieldConfig.value !== undefined) { this.values.set(field.name, fieldConfig.value); this.originalValues.set(field.name, fieldConfig.value);} else if (fieldConfig.checked !== undefined && field.cmp === 'checkbox') { const value = fieldConfig.checked ? 'on' : ''; this.values.set(field.name, value); this.originalValues.set(field.name, value); field.checked = fieldConfig.checked;} if (this.bodyEl && field.render) { if (!field.el) { const fieldEl = field.render(); this.bodyEl.appendChild(fieldEl);} else if (!field.el.parentNode) { this.bodyEl.appendChild(field.el);} } this.setupFieldListeners(field);} setupFieldListeners(field) { if (!field.on) return; field.on('change', (data) => { this.onFieldChange(field.name, data.value, data.oldValue);}); field.on('valid', () => { this.emit('fieldvalid', { field: field.name });}); field.on('invalid', (data) => { this.emit('fieldinvalid', { field: field.name, message: data.message });});} onFieldChange(fieldName, newValue, oldValue) { this.values.set(fieldName, newValue); this.validateField(fieldName); this.updateDirtyState(); this.emit('change', { field: fieldName, value: newValue, oldValue: oldValue });} validateField(fieldName) { const field = this.fields.get(fieldName); const value = this.values.get(fieldName); const validators = this.validators.get(fieldName) || []; if (!field) return true; if (field.validate && typeof field.validate === 'function') { const isValid = field.validate(); if (!isValid) { return false;} } else { if (field.allowBlank === false && (!value || value.toString().trim() === '')) { const fieldValidators = this.validators.get(fieldName) || []; const requiredValidator = fieldValidators.find(v => v && v.type === 'required'); const message = requiredValidator?.message || 'This field is required'; this.emit('fieldinvalid', { field: fieldName, message }); return false;} for (const validator of validators) { const result = this.runValidator(validator, value, field); if (result !== true) { this.emit('fieldinvalid', { field: fieldName, message: result }); return false;} } if (field.validateFn && typeof field.validateFn === 'function') { const result = field.validateFn(value, field); if (result !== null && result !== undefined && result !== true) { this.emit('fieldinvalid', { field: fieldName, message: result }); return false;} } } this.emit('fieldvalid', { field: fieldName }); return true;} runValidator(validator, value, field) { if (typeof validator === 'function') { return validator(value, field);} if (typeof validator === 'object') { const { type, message, ...options } = validator; switch (type) { case 'required': return value && value.toString().trim().length > 0 ? true : (message || 'This field is required'); case 'minLength': return !value || value.length >= options.min ? true : (message || `Minimum length is ${options.min} characters`); case 'maxLength': return !value || value.length <= options.max ? true : (message || `Maximum length is ${options.max} characters`); case 'email': const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; return !value || emailRegex.test(value) ? true : (message || 'Please enter a valid email address'); case 'number': return !value || !isNaN(parseFloat(value)) ? true : (message || 'Please enter a valid number'); case 'regex': return !value || options.pattern.test(value) ? true : (message || 'Invalid format'); case 'date': if (!value) return true; const date = field.cmp === 'datefield' ? field.getDateValue() : new Date(value); return date && !isNaN(date.getTime()) ? true : (message || 'Please enter a valid date'); case 'dateRange': if (!value) return true; const dateVal = field.cmp === 'datefield' ? field.getDateValue() : new Date(value); if (!dateVal || isNaN(dateVal.getTime())) return message || 'Invalid date'; if (options.min && dateVal < new Date(options.min)) { return message || `Date must be after ${options.min}`;} if (options.max && dateVal > new Date(options.max)) { return message || `Date must be before ${options.max}`;} return true; default: return true;} } return true;} isValid() { this.syncFieldValues(); let valid = true; for (const fieldName of this.fields.keys()) { if (!this.validateField(fieldName)) { valid = false;} } return valid;} syncFieldValues() { for (const [name, field] of this.fields.entries()) { if (field && field.getValue) { this.values.set(name, field.getValue());} } } updateValidationState() { this.valid = this.errors.size === 0; this.updateAriaStatus(); this.emit('validitychange', { valid: this.valid, errors: Array.from(this.errors.entries()) });} updateAriaStatus() { const statusEl = this.el?.querySelector(`#${this.id}-status`); if (!statusEl) return; if (this.errors.size > 0) { const errorCount = this.errors.size; const errorMessage = errorCount === 1 ? `Form has 1 error: ${Array.from(this.errors.values())[0]}` : `Form has ${errorCount} errors`; statusEl.textContent = errorMessage;} else { statusEl.textContent = 'Form is valid';} } getValues() { const values = {}; for (const [name, value] of this.values.entries()) { values[name] = value;} return values;} setValues(values) { for (const [name, value] of Object.entries(values)) { const field = this.fields.get(name); if (field && field.setValue) { field.setValue(value); this.values.set(name, value);} else { this.values.set(name, value);} } if (this.trackResetOnLoad) { this.originalValues = new Map(this.values);} this.updateDirtyState();} reset() { for (const [name, originalValue] of this.originalValues.entries()) { const field = this.fields.get(name); if (field && field.setValue) { if (field.cmp === 'checkbox') { const checked = originalValue === 'on'; field.checked = checked; field.setValue(checked);} else { field.setValue(originalValue);} } this.values.set(name, originalValue);} this.errors.clear(); this.updateValidationState(); this.updateDirtyState(); this.emit('reset');} isDirty() { for (const [name, currentValue] of this.values.entries()) { const originalValue = this.originalValues.get(name); if (currentValue !== originalValue) { return true;} } return false;} updateDirtyState() { const dirty = this.isDirty(); this.emit('dirtychange', { dirty });} async submit(options = {}) { if (this.submitting) return; const submitOptions = { ...options }; this.validatingForSubmission = true; if (!this.isValid()) { this.validatingForSubmission = false; this.emit('invalid', { errors: Array.from(this.errors.entries()) }); return;} this.validatingForSubmission = false; this.submitting = true; this.emit('beforesubmit', { values: this.getValues(), options: submitOptions }); try { let result; if (this.standardSubmit || !this.url) { result = this.doStandardSubmit();} else { result = await this.doAjaxSubmit(submitOptions);} this.submitting = false; this.emit('submit', { values: this.getValues() }); return result;} catch (error) { this.submitting = false; this.emit('exception', { error, values: this.getValues() }); throw error;} } doStandardSubmit() { if (this.url) { this.formEl.action = this.url; this.formEl.method = this.method;} this.formEl.submit(); return { success: true };} async doAjaxSubmit(options) { const values = this.getValues(); const requestOptions = { method: this.method, headers: { 'Content-Type': 'application/json', ...options.headers }, body: JSON.stringify(values), ...options }; const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), this.timeout); requestOptions.signal = controller.signal; try { const response = await fetch(this.url, requestOptions); clearTimeout(timeoutId); if (!response.ok) { throw new Error(`HTTP ${response.status}: ${response.statusText}`);} const result = await response.json(); return result;} catch (error) { clearTimeout(timeoutId); throw error;} } getField(name) { return this.fields.get(name);} findField(name) { return this.getField(name) || null;} getFieldValues() { return this.getValues();} markInvalid(errors) { if (Array.isArray(errors)) { errors.forEach(error => { this.errors.set(error.field, error.message);});} else if (typeof errors === 'object') { for (const [field, message] of Object.entries(errors)) { this.errors.set(field, message);} } this.updateValidationState();} clearInvalid() { this.errors.clear(); this.updateValidationState();} remove(field) { if (!field || !field.name) return; const fieldName = field.name; this.fields.delete(fieldName); const index = this.items.indexOf(field); if (index !== -1) { this.items.splice(index, 1);} this.values.delete(fieldName); this.originalValues.delete(fieldName); this.validators.delete(fieldName); this.errors.delete(fieldName); if (field.el && field.el.parentNode) { field.el.parentNode.removeChild(field.el);} this.updateValidationState();} getErrors() { this.isValid(); return Array.from(this.errors.entries());} getValidationErrors() { return this.getErrors();} validate() { return this.isValid();} hasErrors() { return this.errors.size > 0;} addField(fieldConfig) { return this.add(fieldConfig);} removeField(field) { return this.remove(field);} addButton(buttonConfig) { if (!this.buttonsEl) return; this.buttonsEl.classList.remove('hidden'); const button = document.createElement('button'); button.type = buttonConfig.type || 'button'; button.className = `px-4 py-2 rounded font-medium ${buttonConfig.cls || 'bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800'}`; button.textContent = buttonConfig.text || 'Button'; if (buttonConfig.handler) { button.addEventListener('click', () => { buttonConfig.handler(this);});} this.buttonsEl.appendChild(button); return button;} } class TextField extends Component { constructor(config = {}) { super(config); this.name = this.name || this.id; this.fieldLabel = this.fieldLabel || this.label || ''; this.emptyText = this.emptyText || this.placeholder; this.originalValue = this.value; this.lastValue = this.value; this.valid = true; this.errorMessage = ''; this.hasFocus = false; this.inputEl = null; this.labelEl = null; this.errorEl = null; this.form = null; if (config && config.validateFn && typeof config.validateFn === 'function') { this.validators = [...(this.validators || []), config.validateFn];} if (config && config.required === true) { this.allowBlank = false;} } getDefaultConfig() { return { ...super.getDefaultConfig(), name: undefined, fieldLabel: '', label: '', value: '', placeholder: '', emptyText: '', maxLength: undefined, minLength: undefined, regex: undefined, maskRe: undefined, stripCharsRe: undefined, inputType: 'text', allowBlank: true, readOnly: false, selectOnFocus: false, enableKeyEvents: false, labelAlign: 'top', labelWidth: 120, fieldCls: '', invalidCls: 'border-red-500 bg-red-50 dark:border-red-400 dark:bg-red-900/20', focusCls: 'ring-2 ring-blue-500 border-blue-500 dark:ring-blue-400 dark:border-blue-400', validators: [], validator: undefined, validateOnChange: true, validateOnBlur: true };} createTemplate() { const labelTemplate = this.createLabelTemplate(); const inputTemplate = this.createInputTemplate(); const errorTemplate = this.createErrorTemplate(); return ` <div class="${this.getFieldClasses().join(' ')}"> ${labelTemplate} <div class="aionda-textfield-input-wrap relative"> ${inputTemplate} ${errorTemplate} </div> </div> `;} createLabelTemplate() { if (!this.fieldLabel) return ''; const labelClasses = [ 'aionda-textfield-label', 'block', 'text-sm', 'font-medium', 'text-gray-700', 'dark:text-gray-300' ]; if (this.labelAlign === 'top') { labelClasses.push('mb-1');} const requiredMark = !this.allowBlank ? '<span class="text-red-500 ml-1" aria-label="required">*</span>' : ''; return ` <label class="${labelClasses.join(' ')}" for="${this.id}-input" id="${this.id}-label"> ${this.fieldLabel}${requiredMark} </label> `;} createInputTemplate() { const inputClasses = [ 'aionda-textfield-input', 'block', 'w-full', 'px-3', 'py-2', 'border', 'border-gray-300', 'rounded-md', 'shadow-sm', 'placeholder-gray-400', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'focus:border-blue-500', 'transition-colors', 'duration-200', 'bg-white', 'dark:bg-gray-700', 'dark:border-gray-600', 'dark:placeholder-gray-400', 'dark:text-white', 'dark:focus:ring-blue-500', 'dark:focus:border-blue-500' ]; if (this.fieldCls) { inputClasses.push(...this.fieldCls.split(' '));} if (this.readOnly) { inputClasses.push('bg-gray-50', 'cursor-default', 'dark:bg-gray-600');} const attributes = [ `id="${this.id}-input"`, `name="${this.name}"`, `type="${this.inputType}"`, `value="${this.escapeHtml(this.value)}"`, `placeholder="${this.escapeHtml(this.emptyText)}"`, this.readOnly ? 'readonly' : '', this.readOnly ? 'aria-readonly="true"' : '', this.disabled ? 'disabled' : '', this.disabled ? 'aria-disabled="true"' : '', this.maxLength ? `maxlength="${this.maxLength}"` : '', !this.allowBlank ? 'required' : '', !this.allowBlank ? 'aria-required="true"' : '', `aria-describedby="${this.id}-error"`, this.fieldLabel ? `aria-labelledby="${this.id}-label"` : '', this.valid ? 'aria-invalid="false"' : 'aria-invalid="true"' ].filter(Boolean); return ` <input class="${inputClasses.join(' ')}" ${attributes.join(' ')}> `;} createErrorTemplate() { return ` <div class="aionda-textfield-error text-sm text-red-600 dark:text-red-400 mt-1 hidden" id="${this.id}-error" role="alert" aria-live="polite"> <!-- Error message will be inserted here --> </div> `;} getBaseClasses() { const classes = [ ...super.getBaseClasses(), 'aionda-textfield', 'aionda-field' ]; if (this.labelAlign === 'left' || this.labelAlign === 'right') { classes.push('flex', 'items-start', 'gap-3');} if (!this.valid) { classes.push('aionda-field-invalid');} return classes;} getFieldClasses() { return this.getBaseClasses();} setupEventListeners() { super.setupEventListeners(); this.inputEl = this.el.querySelector('.aionda-textfield-input') || this.el.querySelector('.aionda-numberfield-input') || this.el.querySelector('input'); this.labelEl = this.el.querySelector('.aionda-textfield-label'); this.errorEl = this.el.querySelector('.aionda-textfield-error'); if (!this.inputEl) { console.error('TextField: Could not find input element in:', this.constructor.name); return;} this.inputEl.addEventListener('input', (e) => this.onInput(e)); this.inputEl.addEventListener('change', (e) => this.onChange(e)); this.inputEl.addEventListener('focus', (e) => this.onFocus(e)); this.inputEl.addEventListener('blur', (e) => this.onBlur(e)); if (this.enableKeyEvents) { this.inputEl.addEventListener('keydown', (e) => this.onKeyDown(e)); this.inputEl.addEventListener('keyup', (e) => this.onKeyUp(e)); this.inputEl.addEventListener('keypress', (e) => this.onKeyPress(e));} if (this.selectOnFocus) { this.inputEl.addEventListener('focus', () => { setTimeout(() => this.inputEl.select(), 10);});} } onInput(event) { const value = this.processRawValue(event.target.value); this.setValue(value, false); if (this.validateOnChange) { this.validate();} this.emit('input', { value, event });} onChange(event) { const value = this.processRawValue(event.target.value); const oldValue = this.lastValue; this.setValue(value, false); this.lastValue = value; this.emit('change', { value, oldValue, field: this.name });} onFocus(event) { this.hasFocus = true; this.inputEl.classList.add(...this.focusCls.split(' ')); this.emit('focus', { value: this.value, event, field: this });} onBlur(event) { this.hasFocus = false; this.inputEl.classList.remove(...this.focusCls.split(' ')); if (this.validateOnBlur) { this.validate();} this.emit('blur', { value: this.value, event, field: this });} onKeyDown(event) { this.emit('keydown', { key: event.key, event, field: this });} onKeyUp(event) { this.emit('keyup', { key: event.key, event, field: this });} onKeyPress(event) { if (this.maskRe && !this.maskRe.test(event.key) && !this.isSpecialKey(event)) { event.preventDefault(); return;} this.emit('keypress', { key: event.key, event, field: this });} isSpecialKey(event) { return event.key.length > 1 || event.ctrlKey || event.metaKey || event.altKey;} processRawValue(value) { if (this.stripCharsRe) { value = value.replace(this.stripCharsRe, '');} return value;} getValue() { return this.value;} setValue(value, updateDisplay = true) { const oldValue = this.value; this.value = value != null ? String(value) : ''; if (updateDisplay && this.inputEl) { this.inputEl.value = this.value;} if (updateDisplay && oldValue !== this.value) { this.emit('change', { value: this.value, oldValue, field: this.name });} return this;} getRawValue() { return this.inputEl ? this.inputEl.value : this.value;} reset() { this.setValue(this.originalValue); this.clearInvalid(); return this;} isDirty() { return this.value !== this.originalValue;} validate() { const value = this.getValue(); for (const validator of this.validators) { const result = this.runValidator(validator, value); if (result !== true && result !== null && result !== undefined) { this.markInvalid(result); return false;} } const isEmptyValue = !value || (typeof value === 'string' && value.trim().length === 0); if (!this.allowBlank && isEmptyValue) { const hasRequiredValidator = this.validators.some(v => v.type === 'required'); if (!hasRequiredValidator) { this.markInvalid(this.t('validation.required')); return false;} } if (value && this.minLength && value.length < this.minLength) { this.markInvalid(this.t('validation.minLength', { min: this.minLength })); return false;} if (value && this.maxLength && value.length > this.maxLength) { this.markInvalid(this.t('validation.maxLength', { max: this.maxLength })); return false;} if (value && this.regex && !this.regex.test(value)) { this.markInvalid(this.t('validation.format')); return false;} if (this.validator && typeof this.validator === 'function') { const result = this.validator(value, this); if (result !== true) { this.markInvalid(result || this.t('validation.format')); return false;} } this.clearInvalid(); return true;} runValidator(validator, value) { if (typeof validator === 'function') { return validator(value, this);} if (typeof validator === 'object') { const { type, message, ...options } = validator; switch (type) { case 'required': return (value && value.trim().length > 0) ? true : (message || this.t('validation.required')); case 'email': const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; return !value || emailRegex.test(value) ? true : (message || this.t('validation.email')); case 'url': try { if (value) new URL(value); return true;} catch { return message || this.t('validation.url');} case 'minLength': return !value || value.length >= options.min ? true : (message || this.t('validation.minLength', { min: options.min })); case 'pattern': return !value || options.regex.test(value) ? true : (message || this.t('validation.format')); default: return true;} } return true;} isValid() { return this.valid;} markInvalid(message) { this.valid = false; this.errorMessage = message; if (this.inputEl) { this.inputEl.classList.add(...this.invalidCls.split(' ')); this.inputEl.setAttribute('aria-invalid', 'true');} if (this.errorEl) { this.errorEl.textContent = message; this.errorEl.classList.remove('hidden'); const ariaLive = (this.form && this.form.validatingForSubmission) ? 'assertive' : 'polite'; this.errorEl.setAttribute('aria-live', ariaLive);} this.emit('invalid', { message, field: this }); return this;} clearInvalid() { this.valid = true; this.errorMessage = ''; if (this.inputEl) { this.inputEl.classList.remove(...this.invalidCls.split(' ')); this.inputEl.removeAttribute('aria-invalid');} if (this.errorEl) { this.errorEl.textContent = ''; this.errorEl.classList.add('hidden');} this.emit('valid', { field: this }); return this;} focus() { if (this.inputEl) { this.inputEl.focus();} return this;} blur() { if (this.inputEl) { this.inputEl.blur();} return this;} selectText(start, end) { if (this.inputEl) { if (start === undefined) { this.inputEl.select();} else { this.inputEl.setSelectionRange(start, end || start);} } return this;} escapeHtml(text) { if (!text) return ''; const div = document.createElement('div'); div.textContent = text; return div.innerHTML;} setReadOnly(readOnly) { this.readOnly = readOnly; if (this.inputEl) { if (readOnly) { this.inputEl.setAttribute('readonly', ''); this.inputEl.classList.add('bg-gray-50', 'cursor-default', 'dark:bg-gray-600');} else { this.inputEl.removeAttribute('readonly'); this.inputEl.classList.remove('bg-gray-50', 'cursor-default', 'dark:bg-gray-600');} } return this;} setDisabled(disabled) { this.disabled = disabled; if (this.inputEl) { if (disabled) { this.inputEl.setAttribute('disabled', '');} else { this.inputEl.removeAttribute('disabled');} } return this;} } class NumberField extends TextField { constructor(config = {}) { config = config || {}; config.inputType = 'number'; super(config); this.config = config; if (config.min !== undefined && config.minValue === undefined) { this.minValue = config.min;} if (config.max !== undefined && config.maxValue === undefined) { this.maxValue = config.max;} if (config.value === 0 || config.value === '0') { this.value = 0;} this.selectOnFocus = config.selectOnFocus !== false; this.submitLocaleSeparator = config.submitLocaleSeparator || false; if (!config.maskRe && !config.regex) { this.maskRe = this.buildNumberMask();} this.rawValue = this.parseValue(this.value); if (this.value === 0 || this.value === '0') { this.rawValue = 0;} this.fieldCls = `${this.fieldCls || ''}`.trim();} getDefaultConfig() { return { ...super.getDefaultConfig(), inputType: 'number', minValue: undefined, maxValue: undefined, step: 1, decimalPrecision: 2, allowDecimals: true, allowNegative: true, allowExponential: false, thousandSeparator: '', decimalSeparator: '.', currencySymbol: '', numberFormat: undefined, hideTrigger: false, keyNavEnabled: true, mouseWheelEnabled: true, selectOnFocus: true, submitLocaleSeparator: false };} createTemplate() { const labelTemplate = this.createLabelTemplate(); const inputTemplate = this.createInputTemplate(); const errorTemplate = this.createErrorTemplate(); const currencyTemplate = this.currencySymbol ? `<span class="aionda-numberfield-currency absolute left-2 top-1/2 transform -translate-y-1/2 text-gray-500 dark:text-gray-400 pointer-events-none">${this.currencySymbol}</span>` : ''; return ` <div class="${this.getFieldClasses().join(' ')}"> ${labelTemplate} <div class="aionda-textfield-input-wrap relative"> ${currencyTemplate} ${inputTemplate} ${errorTemplate} </div> </div> `;} getFieldClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-numberfield', 'aionda-field' ]; return classes;} createInputTemplate() { const inputClasses = [ 'aionda-numberfield-input', 'block', 'w-full', 'px-3', 'py-2.5', 'border', 'border-gray-300', 'rounded-md', 'shadow-sm', 'placeholder-gray-400', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'focus:border-blue-500', 'transition-colors', 'duration-200', 'text-right', 'bg-white', 'dark:bg-gray-700', 'dark:border-gray-600', 'dark:placeholder-gray-400', 'dark:text-white', 'dark:focus:ring-blue-500', 'dark:focus:border-blue-500', 'min-h-[44px]', 'text-base', 'sm:text-sm', 'touch-manipulation' ]; if (this.fieldCls) { inputClasses.push(...this.fieldCls.split(' '));} if (this.readOnly) { inputClasses.push('bg-gray-50', 'cursor-default', 'dark:bg-gray-600');} const attributes = [ `id="${this.id}-input"`, `name="${this.name}"`, `type="number"`, `value="${this.getFormattedValue()}"`, `placeholder="${this.escapeHtml(this.emptyText)}"`, this.minValue !== undefined ? `min="${this.minValue}"` : '', this.maxValue !== undefined ? `max="${this.maxValue}"` : '', `step="${this.step}"`, this.readOnly ? 'readonly' : '', this.disabled ? 'disabled' : '' ].filter(Boolean); const spinnerHtml = (this.hideTrigger || !this.config.spinners) ? '' : this.createSpinnerTemplate(); return ` <div class="relative"> <input class="${inputClasses.join(' ')}" ${attributes.join(' ')}> ${spinnerHtml} </div> `;} createSpinnerTemplate() { return ` <div class="aionda-numberfield-spinner absolute inset-y-0 right-0 flex flex-col"> <button type="button" class="aionda-numberfield-spinner-up flex-1 px-2 text-gray-400 hover:text-gray-600 hover:bg-gray-50 border-l border-gray-300 rounded-tr-md transition-colors dark:text-gray-500 dark:hover:text-gray-300 dark:hover:bg-gray-600 dark:border-gray-600" ${this.disabled || this.readOnly ? 'disabled' : ''} tabindex="-1"> <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path> </svg> </button> <button type="button" class="aionda-numberfield-spinner-down flex-1 px-2 text-gray-400 hover:text-gray-600 hover:bg-gray-50 border-l border-t border-gray-300 rounded-br-md transition-colors dark:text-gray-500 dark:hover:text-gray-300 dark:hover:bg-gray-600 dark:border-gray-600" ${this.disabled || this.readOnly ? 'disabled' : ''} tabindex="-1"> <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path> </svg> </button> </div> `;} setupEventListeners() { super.setupEventListeners(); this.inputEl = this.el.querySelector('.aionda-numberfield-input') || this.el.querySelector('.aionda-textfield-input'); this.labelEl = this.el.querySelector('.aionda-textfield-label'); this.errorEl = this.el.querySelector('.aionda-textfield-error'); if (!this.inputEl) { console.error('NumberField: Could not find input element'); return;} this.inputEl.addEventListener('input', (e) => this.onInput(e)); this.inputEl.addEventListener('change', (e) => this.onChange(e)); this.inputEl.addEventListener('focus', (e) => this.onFocus(e)); this.inputEl.addEventListener('blur', (e) => this.onBlur(e)); if (this.enableKeyEvents) { this.inputEl.addEventListener('keydown', (e) => this.onKeyDown(e)); this.inputEl.addEventListener('keyup', (e) => this.onKeyUp(e)); this.inputEl.addEventListener('keypress', (e) => this.onKeyPress(e));} if (this.selectOnFocus) { this.inputEl.addEventListener('focus', () => { setTimeout(() => this.inputEl.select(), 10);});} if (!this.hideTrigger && this.config && this.config.spinners) { const spinnerUp = this.el.querySelector('.aionda-numberfield-spinner-up'); const spinnerDown = this.el.querySelector('.aionda-numberfield-spinner-down'); if (spinnerUp) { spinnerUp.addEventListener('click', (e) => this.onSpinUp(e)); spinnerUp.addEventListener('mousedown', (e) => this.startSpin('up', e));} if (spinnerDown) { spinnerDown.addEventListener('click', (e) => this.onSpinDown(e)); spinnerDown.addEventListener('mousedown', (e) => this.startSpin('down', e));} document.addEventListener('mouseup', () => this.stopSpin()); this.el.addEventListener('mouseleave', () => this.stopSpin());} if (this.mouseWheelEnabled) { this.inputEl.addEventListener('wheel', (e) => this.onMouseWheel(e), { passive: false });} if (this.keyNavEnabled) { this.inputEl.addEventListener('keydown', (e) => this.onNumberKeyDown(e));} } onFocus(event) { super.onFocus(event); this.showRawValue();} onBlur(event) { super.onBlur(event); this.formatValue();} onSpinUp(event) { event.preventDefault(); this.spinUp();} onSpinDown(event) { event.preventDefault(); this.spinDown();} onMouseWheel(event) { if (this.hasFocus && !this.readOnly && !this.disabled) { event.preventDefault(); if (event.deltaY < 0) { this.spinUp();} else { this.spinDown();} } } onNumberKeyDown(event) { switch (event.key) { case 'ArrowUp': event.preventDefault(); this.spinUp(); break; case 'ArrowDown': event.preventDefault(); this.spinDown(); break; default: super.onKeyDown(event); break;} } startSpin(direction, event) { event.preventDefault(); this.stopSpin(); this.spinDirection = direction; this.spinTimer = setTimeout(() => { this.continuousSpin();}, 500);} continuousSpin() { if (this.spinDirection === 'up') { this.spinUp();} else { this.spinDown();} this.spinTimer = setTimeout(() => { this.continuousSpin();}, 100);} stopSpin() { if (this.spinTimer) { clearTimeout(this.spinTimer); this.spinTimer = null;} this.spinDirection = null;} spinUp() { if (this.readOnly || this.disabled) return; const current = this.rawValue || 0; let newValue = current + this.step; if (this.maxValue !== undefined && newValue > this.maxValue) { newValue = this.maxValue;} this.setValue(newValue); this.emit('spin', { direction: 'up', value: newValue, oldValue: current }); this.emit('change', { value: newValue, oldValue: current, field: this });} spinDown() { if (this.readOnly || this.disabled) return; const current = this.rawValue || 0; let newValue = current - this.step; if (this.minValue !== undefined && newValue < this.minValue) { newValue = this.minValue;} this.setValue(newValue); this.emit('spin', { direction: 'down', value: newValue, oldValue: current }); this.emit('change', { value: newValue, oldValue: current, field: this });} parseValue(value) { if (value === null || value === undefined || value === '') { return null;} if (value === 0 || value === '0') { return 0;} let cleanValue = String(value); if (this.currencySymbol) { cleanValue = cleanValue.replace(this.currencySymbol, '');} if (this.thousandSeparator) { cleanValue = cleanValue.replace(new RegExp('\\' + this.thousandSeparator, 'g'), '');} if (this.decimalSeparator !== '.') { cleanValue = cleanValue.replace(this.decimalSeparator, '.');} const parsed = parseFloat(cleanValue); if (isNaN(parsed)) { return NaN;} return parsed;} formatValue() { const value = this.rawValue; if (value === null || value === undefined) { this.inputEl.value = ''; return;} let formatted = String(value); if (this.numberFormat && typeof this.numberFormat === 'function') { formatted = this.numberFormat(value);} else { if (this.decimalPrecision !== undefined) { formatted = value.toFixed(this.decimalPrecision);} if (this.thousandSeparator) { const parts = formatted.split('.'); parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandSeparator); formatted = parts.join(this.decimalSeparator || '.');} else if (this.decimalSeparator !== '.') { formatted = formatted.replace('.', this.decimalSeparator);} if (this.currencySymbol) { formatted = this.currencySymbol + formatted;} } this.inputEl.value = formatted;} showRawValue() { if (this.rawValue !== null && this.rawValue !== undefined) { this.inputEl.value = String(this.rawValue);} else { this.inputEl.value = '';} } getFormattedValue() { if (this.rawValue === 0) { return '0';} if (this.rawValue === null || this.rawValue === undefined) { return '';} let formatted = String(this.rawValue); if (this.thousandSeparator) { const parts = formatted.split('.'); parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandSeparator); formatted = parts.join('.');} return formatted;} getValue() { if (this.rawValue === 0) { return 0;} if (this.rawValue === null || this.rawValue === undefined) { return 0;} return this.rawValue;} setValue(value, updateDisplay = true) { let parsedValue = this.parseValue(value); if (!isNaN(parsedValue) && parsedValue !== null && parsedValue !== undefined) { if (!this.allowDecimals) { parsedValue = Math.floor(parsedValue);} if (this.decimalPrecision !== undefined) { parsedValue = parseFloat(parsedValue.toFixed(this.decimalPrecision));} } this.setRawValue(parsedValue, updateDisplay); return this;} setRawValue(value, updateDisplay = true) { const oldValue = this.rawValue; this.rawValue = value; this.value = value; if (updateDisplay && this.inputEl) { this.showRawValue();} if (oldValue !== this.rawValue) { this.emit('change', { value: this.rawValue, oldValue: oldValue, field: this });} } getRawValue() { const inputValue = this.inputEl ? this.inputEl.value : this.value; const parsed = this.parseValue(inputValue); return parsed !== null && parsed !== undefined ? parsed : NaN;} processRawValue(value) { return value;} onInput(event) { const inputValue = event.target.value; const parsedValue = this.parseValue(inputValue); this.rawValue = parsedValue; this.value = parsedValue; if (this.validateOnChange) { this.validate();} this.emit('input', { value: parsedValue, event });} onChange(event) { const inputValue = event.target.value; const parsedValue = this.parseValue(inputValue); const oldValue = this.lastValue; this.setRawValue(parsedValue, false); this.lastValue = parsedValue; this.emit('change', { value: parsedValue, oldValue: oldValue, event: event, field: this });} validate() { const value = this.rawValue; if (!super.validate()) { return false;} if (value !== null && value !== undefined && !isNaN(value)) { if (this.minValue !== undefined && value < this.minValue) { this.markInvalid(`Value must be at least ${this.minValue}`); return false;} if (this.maxValue !== undefined && value > this.maxValue) { this.markInvalid(`Value must be at most ${this.maxValue}`); return false;} if (!this.allowNegative && value < 0) { this.markInvalid('Negative values are not allowed'); return false;} if (!this.allowDecimals && value % 1 !== 0) { this.markInvalid('Decimal values are not allowed'); return false;} } this.clearInvalid(); return true;} buildNumberMask() { let pattern = ''; pattern += '\\d'; if (this.allowDecimals) { pattern += this.decimalSeparator === '.' ? '\\.' : this.decimalSeparator;} if (this.allowNegative) { pattern += '\\-';} if (this.allowExponential) { pattern += 'eE\\+\\-';} return new RegExp(`[${pattern}]`);} isEqual(value1, value2) { if (value1 === value2) return true; if (value1 == null || value2 == null) return false; const precision = this.decimalPrecision || 10; const tolerance = Math.pow(10, -precision); return Math.abs(value1 - value2) < tolerance;} } class ComboBox extends Component { constructor(config = {}) { super(config); config = config || {}; this.name = this.name || this.id; this.fieldLabel = this.fieldLabel || this.label || ''; this.tpl = config.tpl; this.displayTpl = config.displayTpl; this.originalValue = this.value; this.lastValue = this.value; this.selectedRecord = null; this.expanded = false; this.filtered = false; this.loading = false; this.valid = true; this.errorMessage = ''; this.highlightedIndex = -1; this.inputEl = null; this.triggerEl = null; this.listEl = null; this.errorEl = null; this.dropdownEl = null; this.lastQuery = ''; this.queryTask = null; if (this.data.length > 0 && !this.store) { this.loadData(this.data);} if (this.value) { this.selectedRecord = this.findRecord(this.valueField, this.value);} } getDefaultConfig() { return { ...super.getDefaultConfig(), name: undefined, fieldLabel: '', label: '', value: '', displayField: 'text', valueField: 'value', emptyText: '', store: undefined, data: [], queryMode: 'local', queryParam: 'query', minChars: 0, queryDelay: 500, editable: true, forceSelection: false, typeAhead: false, selectOnFocus: false, allowBlank: true, readOnly: false, labelAlign: 'top', labelWidth: 120, listConfig: {}, pageSize: 25, tpl: undefined, displayTpl: undefined };} createTemplate() { const labelTemplate = this.createLabelTemplate(); const inputTemplate = this.createInputTemplate(); const errorTemplate = this.createErrorTemplate(); return ` <div class="${this.getFieldClasses().join(' ')}"> ${labelTemplate} <div class="aionda-combobox-input-wrap relative"> ${inputTemplate} ${errorTemplate} </div> ${this.createDropdownTemplate()} </div> `;} createLabelTemplate() { if (!this.fieldLabel) return ''; const requiredMark = !this.allowBlank ? '<span class="text-red-500 ml-1">*</span>' : ''; return ` <label class="aionda-combobox-label block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1" for="${this.id}-input"> ${this.fieldLabel}${requiredMark} </label> `;} createInputTemplate() { const inputClasses = [ 'aionda-combobox-input', 'block', 'w-full', 'px-3', 'py-2.5', 'pr-10', 'border', 'border-gray-300', 'rounded-md', 'shadow-sm', 'placeholder-gray-400', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'focus:border-blue-500', 'transition-colors', 'duration-200', 'bg-white', 'dark:bg-gray-700', 'dark:border-gray-600', 'dark:placeholder-gray-400', 'dark:text-white', 'dark:focus:ring-blue-500', 'dark:focus:border-blue-500', 'min-h-[44px]', 'text-base', 'sm:text-sm', 'touch-manipulation' ]; if (this.readOnly || !this.editable) { inputClasses.push('bg-gray-50', 'cursor-default', 'dark:bg-gray-600');} const displayValue = this.getDisplayValue(); return ` <div class="relative"> <input class="${inputClasses.join(' ')}" id="${this.id}-input" name="${this.name}" type="text" value="${this.escapeHtml(displayValue)}" placeholder="${this.escapeHtml(this.emptyText)}" role="combobox" aria-expanded="false" aria-controls="${this.id}-dropdown" aria-autocomplete="list" ${this.readOnly || !this.editable ? 'readonly' : ''} ${this.disabled ? 'disabled' : ''} autocomplete="off"> <button class="aionda-combobox-trigger absolute inset-y-0 right-0 flex items-center px-3 text-gray-400 hover:text-gray-600 dark:text-gray-500 dark:hover:text-gray-300 min-w-[44px] touch-manipulation" type="button" ${this.disabled ? 'disabled' : ''}> <svg class="w-5 h-5 transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path> </svg> </button> </div> `;} createErrorTemplate() { return ` <div class="aionda-combobox-error text-sm text-red-600 dark:text-red-400 mt-1 hidden"> <!-- Error message will be inserted here --> </div> `;} createDropdownTemplate() { return ` <div id="${this.id}-dropdown" class="aionda-combobox-dropdown absolute z-50 mt-1 w-full bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md shadow-lg hidden" role="listbox"> <div class="aionda-combobox-list max-h-48 sm:max-h-60 overflow-auto overscroll-contain"> <!-- List items will be inserted here --> </div> <div class="aionda-combobox-loading hidden p-3 text-center text-gray-500 dark:text-gray-400"> <div class="inline-flex items-center"> <svg class="animate-spin -ml-1 mr-2 h-4 w-4" fill="none" viewBox="0 0 24 24"> <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle> <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path> </svg> Loading... </div> </div> <div class="aionda-combobox-empty hidden p-3 text-center text-gray-500 dark:text-gray-400"> No items to display </div> </div> `;} getFieldClasses() { const classes = [ 'aionda-component', 'aionda-combobox', 'aionda-field', 'relative' ]; if (this.cls) { classes.push(...this.cls.split(' ').filter(Boolean));} if (this.hidden) classes.push('aionda-hidden'); if (this.disabled) classes.push('aionda-disabled'); if (this.responsive) classes.push('aionda-responsive'); if (!this.valid) { classes.push('aionda-field-invalid');} return classes;} setupEventListeners() { super.setupEventListeners(); this.inputEl = this.el.querySelector('.aionda-combobox-input'); this.triggerEl = this.el.querySelector('.aionda-combobox-trigger'); this.listEl = this.el.querySelector('.aionda-combobox-list'); this.errorEl = this.el.querySelector('.aionda-combobox-error'); this.dropdownEl = this.el.querySelector('.aionda-combobox-dropdown'); this.loadingEl = this.el.querySelector('.aionda-combobox-loading'); this.emptyEl = this.el.querySelector('.aionda-combobox-empty'); this.inputEl.addEventListener('input', (e) => this.onInput(e)); this.inputEl.addEventListener('focus', (e) => this.onFocus(e)); this.inputEl.addEventListener('blur', (e) => this.onBlur(e)); this.inputEl.addEventListener('keydown', (e) => this.onKeyDown(e)); this.triggerEl.addEventListener('click', (e) => this.onTriggerClick(e)); this.listEl.addEventListener('click', (e) => this.onListClick(e)); this.listEl.addEventListener('mouseover', (e) => this.onListMouseOver(e)); document.addEventListener('click', (e) => this.onDocumentClick(e)); if (this.store) { this.store.on('load', () => this.onStoreLoad()); this.store.on('beforeload', () => this.onStoreBeforeLoad());} } onInput(event) { const value = event ? event.target.value : (this.inputEl ? this.inputEl.value : ''); this.lastQuery = value; if (this.editable) { this.doQuery(value);} if (event) { this.emit('input', { value, event });} } onFocus(event) { if (this.selectOnFocus) { setTimeout(() => this.inputEl.select(), 10);} if (!this.expanded && this.minChars === 0) { this.expand();} this.emit('focus', { field: this, event });} onBlur(event) { setTimeout(() => { if (!this.hasFocus()) { this.collapse(); this.validateForceSelection();} }, 100); if (event) { this.emit('blur', { field: this, event });} else { this.validateForceSelection();} } validateForceSelection() { if (this.forceSelection && this.inputEl && this.inputEl.value) { const record = this.findRecordByDisplay(this.inputEl.value); if (!record) { this.valid = false; this.clearValue();} } } findRecordByDisplay(displayValue) { const records = this.getRecords(); return records.find(record => (record[this.displayField] || '').toLowerCase() === displayValue.toLowerCase() );} onKeyDown(event) { switch (event.key) { case 'ArrowDown': event.preventDefault(); if (this.expanded) { this.selectNext();} else { this.expand();} break; case 'ArrowUp': event.preventDefault(); if (this.expanded) { this.selectPrevious();} break; case 'Enter': event.preventDefault(); if (this.expanded && this.highlightedIndex >= 0) { this.selectHighlighted();} break; case 'Escape': event.preventDefault(); this.collapse(); break; case 'Tab': if (this.expanded && this.highlightedIndex >= 0) { this.selectHighlighted();} this.collapse(); break;} this.emit('keydown', { field: this, key: event.key, event });} onTriggerClick(event) { event.preventDefault(); if (this.disabled || this.readOnly) return; if (this.expanded) { this.collapse();} else { this.expand(); this.inputEl.focus();} } onListClick(event) { const item = event.target.closest('.aionda-combobox-item'); if (item) { const index = parseInt(item.dataset.index); this.select(index);} } onListMouseOver(event) { const item = event.target.closest('.aionda-combobox-item'); if (item) { this.highlightItem(item);} } onDocumentClick(event) { if (this.el && !this.el.contains(event.target)) { this.collapse();} } onStoreBeforeLoad() { this.setLoading(true);} onStoreLoad() { this.setLoading(false); this.refreshList();} doQuery(query) { if (this.queryTask) { clearTimeout(this.queryTask);} this.queryTask = setTimeout(() => { if (query.length >= this.minChars) { if (this.queryMode === 'remote' && this.store) { this.store.load({ [this.queryParam]: query });} else { this.filterLocal(query);} if (!this.expanded) { this.expand();} } else { this.collapse();} }, this.queryDelay);} filterLocal(query) { this.filtered = query.length > 0; this.refreshList(query);} loadData(data) { this.data = data || []; if (this.listEl) { this.refreshList();} return this;} getRecords() { if (this.store) { return this.store.getRecords();} return this.data;} getFilteredData() { const records = this.getRecords(); const query = this.inputEl ? this.inputEl.value : this.lastQuery; if (!query || query.trim() === '') { return records;} const queryLower = query.toLowerCase(); return records.filter(record => { const displayValue = String(record[this.displayField] || '').toLowerCase(); return displayValue.includes(queryLower);});} findRecord(field, value) { const records = this.getRecords(); return records.find(record => record[field] === value);} refreshList(query = '') { if (!this.listEl) return; const records = this.getRecords(); let filteredRecords = records; if (query && this.queryMode === 'local') { const queryLower = query.toLowerCase(); filteredRecords = records.filter(record => { const displayValue = String(record[this.displayField] || '').toLowerCase(); return displayValue.includes(queryLower);});} this.listEl.innerHTML = ''; this.highlightedIndex = -1; if (filteredRecords.length === 0) { this.showEmpty(); return;} this.hideEmpty(); filteredRecords.forEach((record, index) => { const item = this.createListItem(record, index); this.listEl.appendChild(item);});} createListItem(record, index) { const div = document.createElement('div'); div.className = 'aionda-combobox-item px-3 py-2 cursor-pointer hover:bg-blue-50 dark:hover:bg-blue-900/20 dark:text-white flex items-center'; div.dataset.index = index; div.dataset.value = record[this.valueField]; div.setAttribute('role', 'option'); div.setAttribute('id', `${this.id}-option-${index}`); if (this.tpl && typeof this.tpl === 'function') { div.innerHTML = this.tpl(record);} else { div.textContent = record[this.displayField] || record[this.valueField] || '';} if (record[this.valueField] === this.value) { div.classList.add('bg-blue-100', 'text-blue-900', 'dark:bg-blue-900/40', 'dark:text-blue-200');} return div;} select(index) { const records = this.getFilteredData(); const record = records[index]; if (record) { this.setValue(record[this.valueField]); this.selectedRecord = record; this.updateDisplay(); this.collapse(); const originalIndex = this.getRecords().findIndex(r => r[this.valueField] === record[this.valueField]); this.emit('select', { combo: this, record, index: originalIndex });} } selectHighlighted() { if (this.highlightedIndex >= 0) { this.select(this.highlightedIndex);} } selectNext() { const items = this.listEl.querySelectorAll('.aionda-combobox-item'); if (items.length === 0) return; if (this.highlightedIndex < 0) { this.highlightedIndex = 0;} else { this.highlightedIndex = this.highlightedIndex < items.length - 1 ? this.highlightedIndex + 1 : 0;} this.highlightItem(items[this.highlightedIndex]); this.updateActiveDescendant();} selectPrevious() { const items = this.listEl.querySelectorAll('.aionda-combobox-item'); if (items.length === 0) return; if (this.highlightedIndex < 0) { this.highlightedIndex = items.length - 1;} else { this.highlightedIndex = this.highlightedIndex > 0 ? this.highlightedIndex - 1 : items.length - 1;} this.highlightItem(items[this.highlightedIndex]); this.updateActiveDescendant();} highlightItem(item) { const prev = this.listEl ? this.listEl.querySelector('.highlighted') : null; if (prev) { prev.classList.remove('highlighted', 'bg-blue-100', 'text-blue-900', 'dark:bg-blue-900/40', 'dark:text-blue-200');} if (item) { item.classList.add('highlighted', 'bg-blue-100', 'text-blue-900', 'dark:bg-blue-900/40', 'dark:text-blue-200'); this.highlightedIndex = parseInt(item.dataset.index) || 0; this.updateActiveDescendant(); if (typeof item.scrollIntoView === 'function') { try { item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });} catch (e) { item.scrollIntoView(false);} } else { const container = item.offsetParent || item.parentElement; if (container) { const itemTop = DOMCompat.getOffset(item).top; const containerTop = DOMCompat.getOffset(container).top; const relativeTop = itemTop - containerTop; container.scrollTop = relativeTop - (container.clientHeight / 2);} } } } expand() { if (this.expanded || this.disabled || this.readOnly) return; this.expanded = true; this.dropdownEl.classList.remove('hidden'); this.triggerEl.querySelector('svg').classList.add('rotate-180'); this.inputEl.setAttribute('aria-expanded', 'true'); this.positionDropdown(); this.refreshList(this.lastQuery); this.emit('expand');} isExpanded() { return this.expanded;} collapse() { if (!this.expanded) return; this.expanded = false; this.dropdownEl.classList.add('hidden'); this.triggerEl.querySelector('svg').classList.remove('rotate-180'); this.inputEl.setAttribute('aria-expanded', 'false'); this.inputEl.removeAttribute('aria-activedescendant'); this.highlightedIndex = -1; this.emit('collapse');} positionDropdown() { const rect = this.inputEl.getBoundingClientRect(); const dropdown = this.dropdownEl; dropdown.style.width = `${rect.width}px`; dropdown.style.left = '0px'; dropdown.style.top = '100%';} setLoading(loading) { this.loading = loading; if (loading) { this.loadingEl.classList.remove('hidden'); this.listEl.classList.add('hidden'); this.emptyEl.classList.add('hidden');} else { this.loadingEl.classList.add('hidden'); this.listEl.classList.remove('hidden');} } showEmpty() { this.emptyEl.classList.remove('hidden'); this.listEl.classList.add('hidden');} hideEmpty() { this.emptyEl.classList.add('hidden'); this.listEl.classList.remove('hidden');} getValue() { return this.value;} setValue(value) { const oldValue = this.value; this.value = value; this.selectedRecord = this.findRecord(this.valueField, value); this.updateDisplay(); if (value && this.selectedRecord) { this.valid = true;} if (oldValue !== value) { this.emit('change', { value: this.value, oldValue, record: this.selectedRecord, combo: this }); if (this.selectedRecord) { const originalIndex = this.getRecords().findIndex(r => r[this.valueField] === this.selectedRecord[this.valueField]); this.emit('select', { combo: this, record: this.selectedRecord, index: originalIndex });} } return this;} getSelection() { return this.selectedRecord;} clearValue() { this.value = ''; this.selectedRecord = null; this.updateDisplay(); return this;} getDisplayValue() { if (this.selectedRecord) { if (this.displayTpl && typeof this.displayTpl === 'function') { return this.displayTpl(this.selectedRecord);} return this.selectedRecord[this.displayField] || this.selectedRecord[this.valueField] || '';} const record = this.findRecord(this.valueField, this.value); if (record) { return record[this.displayField] || record[this.valueField] || '';} return this.value;} updateDisplay() { if (this.inputEl) { this.inputEl.value = this.getDisplayValue();} } reset() { this.setValue(this.originalValue); this.collapse(); return this;} validate() { if (!this.allowBlank && (!this.value || this.value === '')) { this.valid = false; return false;} if (this.forceSelection && this.inputEl && this.inputEl.value) { const record = this.findRecordByDisplay(this.inputEl.value); if (!record) { this.valid = false; return false;} } if (this.valid !== false) { this.valid = true;} return this.valid;} hasFocus() { return this.el.contains(document.activeElement);} updateActiveDescendant() { if (this.highlightedIndex >= 0 && this.expanded) { const items = this.listEl.querySelectorAll('.aionda-combobox-item'); const highlightedItem = items[this.highlightedIndex]; if (highlightedItem && highlightedItem.id) { this.inputEl.setAttribute('aria-activedescendant', highlightedItem.id);} } else { this.inputEl.removeAttribute('aria-activedescendant');} } escapeHtml(text) { if (!text) return ''; const div = document.createElement('div'); div.textContent = text; return div.innerHTML;} } class Checkbox extends Component { constructor(config = {}) { super(config); this.name = this.name || this.id; this.fieldLabel = this.fieldLabel || this.label || ''; this.originalValue = this.checked; this.lastValue = this.checked; this.valid = true; this.errorMessage = ''; this.hasFocus = false; this.inputEl = null; this.labelEl = null; this.boxLabelEl = null; this.errorEl = null; this.form = null; if (config && config.required === true) { this.allowBlank = false;} } getDefaultConfig() { return { ...super.getDefaultConfig(), name: undefined, fieldLabel: '', label: '', boxLabel: '', value: 'on', checked: false, inputValue: 'on', uncheckedValue: '', indeterminate: false, readOnly: false, allowBlank: true, submitValue: true, validators: [], labelAlign: 'top', labelWidth: 120, boxLabelAlign: 'after', checkboxCls: '', focusCls: 'ring-2 ring-blue-500', size: 'md', variant: 'checkbox' };} createTemplate() { const labelTemplate = this.createLabelTemplate(); const checkboxTemplate = this.createCheckboxTemplate(); const errorTemplate = this.createErrorTemplate(); return ` <div class="${this.getFieldClasses().join(' ')}"> ${labelTemplate} <div class="aionda-checkbox-input-wrap"> ${checkboxTemplate} ${errorTemplate} </div> </div> `;} createLabelTemplate() { if (!this.fieldLabel) return ''; const labelClasses = [ 'aionda-field-label', 'block', 'text-sm', 'font-medium', 'text-gray-700', 'dark:text-gray-300' ]; if (this.labelAlign === 'top') { labelClasses.push('mb-2');} return ` <label class="${labelClasses.join(' ')}"> ${this.fieldLabel} </label> `;} createCheckboxTemplate() { const wrapperClasses = [ 'aionda-checkbox-wrap', 'flex', 'items-center' ]; if (this.boxLabelAlign === 'before') { wrapperClasses.push('flex-row-reverse', 'justify-end');} const checkboxHtml = this.variant === 'switch' ? this.createSwitchTemplate() : this.createDefaultCheckboxTemplate(); const boxLabelHtml = this.boxLabel ? this.createBoxLabelTemplate() : ''; return ` <div class="${wrapperClasses.join(' ')}"> ${checkboxHtml} ${boxLabelHtml} </div> `;} createDefaultCheckboxTemplate() { const sizeClasses = this.getSizeClasses(); const checkboxClasses = [ 'aionda-checkbox-input', 'rounded', 'border-gray-300', 'text-blue-600', 'focus:ring-blue-500', 'focus:ring-2', 'focus:ring-offset-0', 'transition-colors', 'duration-200', 'dark:border-gray-600', 'dark:bg-gray-700', 'dark:text-blue-500', 'dark:focus:ring-blue-500', 'dark:focus:ring-offset-gray-800', ...sizeClasses ]; if (this.checkboxCls) { checkboxClasses.push(...this.checkboxCls.split(' '));} if (this.readOnly) { checkboxClasses.push('bg-gray-50', 'cursor-default', 'dark:bg-gray-600');} const ariaChecked = this.indeterminate ? 'mixed' : this.checked.toString(); const attributes = [ `id="${this.id}-input"`, `name="${this.name}"`, `type="checkbox"`, `role="checkbox"`, `aria-checked="${ariaChecked}"`, `value="${this.inputValue}"`, this.checked ? 'checked' : '', this.readOnly ? 'readonly' : '', this.disabled ? 'disabled' : '', !this.allowBlank ? 'aria-required="true"' : '' ].filter(Boolean); return ` <input class="${checkboxClasses.join(' ')}" ${attributes.join(' ')}> `;} createSwitchTemplate() { const switchClasses = [ 'aionda-checkbox-switch', 'relative', 'inline-flex', 'h-7', 'w-12', 'sm:h-6', 'sm:w-11', 'items-center', 'rounded-full', 'border-2', 'border-transparent', 'transition-colors', 'duration-200', 'ease-in-out', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'focus:ring-offset-2', 'touch-manipulation', 'min-h-[44px]', this.checked ? 'bg-blue-600 dark:bg-blue-600' : 'bg-gray-200 dark:bg-gray-600' ]; if (this.readOnly) { switchClasses.push('cursor-default');} else { switchClasses.push('cursor-pointer');} const knobClasses = [ 'aionda-checkbox-knob', 'inline-block', 'h-5', 'w-5', 'sm:h-4', 'sm:w-4', 'transform', 'rounded-full', 'bg-white', 'transition', 'duration-200', 'ease-in-out', this.checked ? 'translate-x-6 sm:translate-x-6' : 'translate-x-1' ]; const ariaChecked = this.indeterminate ? 'mixed' : this.checked.toString(); return ` <button type="button" class="${switchClasses.join(' ')}" role="switch" aria-checked="${ariaChecked}" ${this.disabled ? 'disabled' : ''} ${this.readOnly ? 'tabindex="-1"' : ''} ${!this.allowBlank ? 'aria-required="true"' : ''}> <span class="${knobClasses.join(' ')}"></span> <input type="checkbox" class="sr-only" id="${this.id}-input" name="${this.name}" role="switch" aria-checked="${ariaChecked}" value="${this.inputValue}" ${this.checked ? 'checked' : ''} ${this.readOnly ? 'readonly' : ''} ${this.disabled ? 'disabled' : ''} ${!this.allowBlank ? 'aria-required="true"' : ''}> </button> `;} createBoxLabelTemplate() { const labelClasses = [ 'aionda-checkbox-label', 'text-sm', 'text-gray-700', 'dark:text-gray-300', 'select-none' ]; if (this.boxLabelAlign === 'after') { labelClasses.push('ml-2');} else { labelClasses.push('mr-2');} if (this.readOnly) { labelClasses.push('cursor-default');} else { labelClasses.push('cursor-pointer');} return ` <label class="${labelClasses.join(' ')}" for="${this.id}-input"> ${this.boxLabel} </label> `;} createErrorTemplate() { return ` <div id="${this.id}-error" class="aionda-checkbox-error text-sm text-red-600 dark:text-red-400 mt-1 hidden"> <!-- Error message will be inserted here --> </div> `;} getSizeClasses() { switch (this.size) { case 'sm': return ['h-5', 'w-5', 'sm:h-4', 'sm:w-4']; case 'lg': return ['h-7', 'w-7', 'sm:h-6', 'sm:w-6']; default: return ['h-6', 'w-6', 'sm:h-5', 'sm:w-5'];} } getFieldClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-checkbox', 'aionda-field' ]; if (this.variant === 'switch') { classes.push('aionda-checkbox-switch');} if (this.size) { classes.push(`aionda-checkbox-${this.size}`);} if (!this.valid) { classes.push('aionda-field-invalid');} return classes;} setupEventListeners() { super.setupEventListeners(); this.inputEl = this.el.querySelector('.aionda-checkbox-input, .sr-only'); this.labelEl = this.el.querySelector('.aionda-field-label'); this.boxLabelEl = this.el.querySelector('.aionda-checkbox-label'); this.errorEl = this.el.querySelector('.aionda-checkbox-error'); if (this.variant === 'switch') { this.switchEl = this.el.querySelector('.aionda-checkbox-switch'); this.knobEl = this.el.querySelector('.aionda-checkbox-knob'); this.switchEl.addEventListener('click', (e) => this.onSwitchClick(e));} if (!this.inputEl) { console.warn('Checkbox inputEl not found'); return;} this.inputEl.addEventListener('change', (e) => this.onChange(e)); this.inputEl.addEventListener('click', (e) => this.onClick(e)); this.inputEl.addEventListener('focus', (e) => this.onFocus(e)); this.inputEl.addEventListener('blur', (e) => this.onBlur(e)); this.inputEl.addEventListener('keydown', (e) => this.onKeyDown(e)); if (this.boxLabelEl) { this.boxLabelEl.addEventListener('click', (e) => this.onLabelClick(e));} if (this.indeterminate && this.inputEl) { this.inputEl.indeterminate = true;} this.updateAriaAttributes();} onClick(event) { if (this.readOnly || this.disabled) { event.preventDefault(); event.stopPropagation(); return false;} if (this.indeterminate) { this.setIndeterminate(false);} if (!event.isTrusted) { const newChecked = !this.inputEl.checked; this.inputEl.checked = newChecked; const changeEvent = new Event('change', { bubbles: true }); this.inputEl.dispatchEvent(changeEvent);} } onChange(event) { const oldValue = this.checked; this.checked = event.target.checked; this.updateValue(); this.updateDisplay(); this.emit('change', { field: this.name, checked: this.checked, value: this.getValue() });} onFocus(event) { this.hasFocus = true; if (this.variant === 'switch' && this.switchEl) { this.switchEl.classList.add(...this.focusCls.split(' '));} this.emit('focus', { event, field: this });} onBlur(event) { this.hasFocus = false; if (this.variant === 'switch' && this.switchEl) { this.switchEl.classList.remove(...this.focusCls.split(' '));} this.emit('blur', { event, field: this });} onKeyDown(event) { if (this.readOnly || this.disabled) { return;} if (event.key === ' ' || event.key === 'Enter') { event.preventDefault(); this.toggle();} this.emit('keydown', { key: event.key, event, field: this });} onSwitchClick(event) { if (this.readOnly || this.disabled) return; event.preventDefault(); this.toggle();} onLabelClick(event) { if (this.readOnly || this.disabled) return; event.preventDefault(); this.toggle();} getValue() { return this.checked ? this.value : this.uncheckedValue;} setValue(value) { const oldChecked = this.checked; this.checked = this.valueToChecked(value); this.updateValue(); this.updateDisplay(); if (oldChecked !== this.checked) { this.emit('change', { checked: this.checked, value: this.getValue(), oldValue: oldChecked ? this.inputValue : this.uncheckedValue, field: this });} return this;} valueToChecked(value) { if (value === true || value === this.inputValue) { return true;} if (value === false || value === this.uncheckedValue) { return false;} return !!value;} updateValue() { this.value = this.getValue();} updateDisplay() { if (this.inputEl) { this.inputEl.checked = this.checked; this.inputEl.indeterminate = this.indeterminate;} if (this.variant === 'switch') { this.updateSwitchDisplay();} this.updateAriaAttributes();} updateSwitchDisplay() { if (!this.switchEl || !this.knobEl) return; if (this.checked) { this.switchEl.classList.remove('bg-gray-200', 'dark:bg-gray-600'); this.switchEl.classList.add('bg-blue-600', 'dark:bg-blue-600'); this.switchEl.setAttribute('aria-checked', 'true'); this.knobEl.classList.remove('translate-x-1'); this.knobEl.classList.add('translate-x-6');} else { this.switchEl.classList.remove('bg-blue-600', 'dark:bg-blue-600'); this.switchEl.classList.add('bg-gray-200', 'dark:bg-gray-600'); this.switchEl.setAttribute('aria-checked', 'false'); this.knobEl.classList.remove('translate-x-6'); this.knobEl.classList.add('translate-x-1');} } toggle() { if (this.readOnly || this.disabled) return this; this.setChecked(!this.checked); return this;} setChecked(checked) { const oldValue = this.checked; this.checked = !!checked; if (this.indeterminate) { this.setIndeterminate(false);} this.updateValue(); this.updateDisplay(); if (oldValue !== this.checked) { this.emit('change', { field: this.name, checked: this.checked, value: this.getValue() });} return this;} isChecked() { return this.checked;} setIndeterminate(indeterminate) { this.indeterminate = !!indeterminate; if (this.inputEl) { this.inputEl.indeterminate = this.indeterminate;} this.updateAriaAttributes(); return this;} reset() { this.setChecked(this.originalValue); this.clearInvalid(); return this;} isDirty() { return this.checked !== this.originalValue;} validate() { if (this.validators && Array.isArray(this.validators)) { for (const validator of this.validators) { if (validator.type === 'required' && !this.checked) { this.markInvalid(validator.message || 'This field must be checked'); return false;} } } if (!this.allowBlank && !this.checked) { this.markInvalid('This field must be checked'); return false;} this.clearInvalid(); return true;} isValid() { return this.valid;} markInvalid(message) { this.valid = false; this.errorMessage = message; if (this.errorEl) { this.errorEl.textContent = message; this.errorEl.classList.remove('hidden'); const errorId = `${this.id}-error`; if (this.inputEl) { this.inputEl.setAttribute('aria-describedby', errorId);} } this.updateAriaAttributes(); this.emit('invalid', { message, field: this }); return this;} clearInvalid() { this.valid = true; this.errorMessage = ''; if (this.errorEl) { this.errorEl.textContent = ''; this.errorEl.classList.add('hidden'); if (this.inputEl) { this.inputEl.removeAttribute('aria-describedby');} } this.updateAriaAttributes(); this.emit('valid', { field: this }); return this;} focus() { if (this.inputEl) { this.inputEl.focus();} return this;} blur() { if (this.inputEl) { this.inputEl.blur();} return this;} setReadOnly(readOnly) { this.readOnly = readOnly; if (this.inputEl) { if (readOnly) { this.inputEl.setAttribute('readonly', '');} else { this.inputEl.removeAttribute('readonly');} } if (this.variant === 'switch' && this.switchEl) { if (readOnly) { this.switchEl.classList.add('cursor-default'); this.switchEl.classList.remove('cursor-pointer'); this.switchEl.setAttribute('tabindex', '-1');} else { this.switchEl.classList.remove('cursor-default'); this.switchEl.classList.add('cursor-pointer'); this.switchEl.removeAttribute('tabindex');} } return this;} disable() { return this.setDisabled(true);} enable() { return this.setDisabled(false);} setDisabled(disabled) { this.disabled = disabled; if (this.inputEl) { if (disabled) { this.inputEl.setAttribute('disabled', '');} else { this.inputEl.removeAttribute('disabled');} } if (this.variant === 'switch' && this.switchEl) { if (disabled) { this.switchEl.setAttribute('disabled', '');} else { this.switchEl.removeAttribute('disabled');} } return this;} updateAriaAttributes() { if (!this.inputEl) return; const ariaChecked = this.indeterminate ? 'mixed' : this.checked.toString(); this.inputEl.setAttribute('aria-checked', ariaChecked); if (!this.allowBlank) { this.inputEl.setAttribute('aria-required', 'true');} else { this.inputEl.removeAttribute('aria-required');} if (!this.valid) { this.inputEl.setAttribute('aria-invalid', 'true');} else { this.inputEl.removeAttribute('aria-invalid');} if (this.variant === 'switch' && this.switchEl) { this.switchEl.setAttribute('aria-checked', ariaChecked); if (!this.allowBlank) { this.switchEl.setAttribute('aria-required', 'true');} else { this.switchEl.removeAttribute('aria-required');} } } } class Tree extends Component { constructor(config = {}) { super(config); config = config || {}; this.data = config.data || []; this.store = config.store || null; this.loader = config.loader || null; this.selectionMode = config.selectionMode || 'single'; this.draggable = config.draggable === true; this.checkboxes = config.checkboxes === true; this.expandable = config.expandable !== false; this.rootVisible = config.rootVisible !== false; this.animate = config.animate !== false; this.singleExpand = config.singleExpand === true; this.lazyLoad = config.lazyLoad === true; this.animated = config.animated !== false; this.lines = config.lines !== false; this.icons = config.icons !== false ? ( typeof config.icons === 'object' ? { expand: config.icons.expand || '▶', collapse: config.icons.collapse || '▼', leaf: config.icons.leaf || '📄', folder: config.icons.folder || '📁', ...config.icons } : { expand: '▶', collapse: '▼', leaf: '📄', folder: '📁' } ) : false; this.nodeField = config.nodeField || 'text'; this.textField = config.textField || 'text'; this.childrenField = config.childrenField || 'children'; this.leafField = config.leafField || 'leaf'; this.expandedField = config.expandedField || 'expanded'; this.loadedField = config.loadedField || 'loaded'; this.iconField = config.iconField || 'icon'; this.nodeRenderer = config.nodeRenderer || null; this.selectedNodes = new Set(); this.expandedNodes = new Set(); this.loadingNodes = new Set(); this.lastSelectedNodeId = null; this.dragState = null; this.treeEl = null; this.nodeMap = new Map(); this.buildNodeMap(this.getData()); this.initializeExpandedNodes();} initializeExpandedNodes() { this.nodeMap.forEach((node, nodeId) => { if (node[this.expandedField]) { this.expandedNodes.add(nodeId);} });} buildNodeMap(nodes, parentId = null, level = 0, visited = new Set(), pathSet = new Set()) { if (!Array.isArray(nodes)) return; nodes.forEach((node, index) => { const nodeId = this.getNodeId(node, parentId, index); if (pathSet.has(nodeId)) { console.warn(`Circular reference detected for node ${nodeId}, skipping to prevent infinite recursion`); return;} if (this.nodeMap.has(nodeId)) { return;} pathSet.add(nodeId); this.nodeMap.set(nodeId, { ...node, _id: nodeId, _parentId: parentId, _index: index, _level: level }); const children = node[this.childrenField]; if (children && Array.isArray(children)) { this.buildNodeMap(children, nodeId, level + 1, visited, new Set(pathSet));} pathSet.delete(nodeId);});} getNodeId(node, parentId, index) { if (node.id) return String(node.id); return parentId ? `${parentId}-${index}` : String(index);} getNodeLevel(nodeId) { const node = this.nodeMap.get(nodeId); return node ? node._level : 0;} hasChildren(node) { const children = node[this.childrenField]; return children && Array.isArray(children) && children.length > 0;} isLeaf(node) { if (node[this.leafField] !== undefined) { return node[this.leafField];} return !this.hasChildren(node) && !this.isLoadable(node);} isLoadable(node) { return this.loader && !node[this.loadedField] && !this.hasChildren(node);} isExpanded(nodeId) { return this.expandedNodes.has(nodeId);} isSelected(nodeId) { return this.selectedNodes.has(nodeId);} render(target) { this.nodeMap.clear(); this.buildNodeMap(this.getData()); this.initializeExpandedNodes(); return super.render(target);} createTemplate() { return ` <div class="${this.getTreeClasses().join(' ')}"> <div class="aionda-tree-container"> ${this.createTreeTemplate()} </div> </div> `;} createTreeTemplate() { const data = this.getData(); return this.renderNodes(data);} renderNodes(nodes, parentId = null, level = 0) { return this.createNodesTemplate(nodes, parentId, level);} getData() { return this.store ? this.store.data : this.data;} createNodesTemplate(nodes, parentId = null, level = 0) { if (!Array.isArray(nodes) || nodes.length === 0) { return level === 0 ? '<div class="aionda-tree-empty p-4 text-center text-gray-500">No data to display</div>' : '';} let html = '<ul class="aionda-tree-list">'; nodes.forEach((node, index) => { const nodeId = this.getNodeId(node, parentId, index); html += this.createNodeTemplate(node, nodeId, level);}); html += '</ul>'; return html;} createNodeTemplate(node, nodeId, level) { const mapNode = this.nodeMap.get(nodeId) || node; const isExpanded = this.isExpanded(nodeId); const isSelected = this.isSelected(nodeId); const hasChildrenOrLoadable = this.hasChildren(node) || this.isLoadable(node); const isLoading = this.loadingNodes.has(nodeId); const children = node[this.childrenField]; const nodeClasses = [ 'aionda-tree-node', isSelected ? 'selected bg-blue-100' : '', 'cursor-pointer hover:bg-blue-50 transition-colors' ].filter(Boolean); const expanderIcon = hasChildrenOrLoadable ? ( isLoading ? '⟳' : (isExpanded ? '▼' : '▶') ) : ''; const checkbox = this.checkboxes ? ` <input type="checkbox" class="aionda-tree-checkbox mr-2" data-node-id="${nodeId}" ${isSelected ? 'checked' : ''}> ` : ''; const nodeIcon = this.getNodeIcon(node); const nodeText = this.getNodeText(node); let html = ` <li class="aionda-tree-item" data-node-id="${nodeId}" data-level="${level}"> <div class="${nodeClasses.join(' ')}" data-node-id="${nodeId}" data-id="${nodeId}" data-level="${level}" data-parent-id="${mapNode._parentId || ''}" style="padding-left: ${level * 24 + 8}px" tabindex="0" ${this.draggable ? 'draggable="true"' : ''}> <div class="flex items-center"> ${hasChildrenOrLoadable ? ` <button class="aionda-tree-expand-icon w-6 h-6 flex items-center justify-center text-gray-500 hover:text-gray-700" data-node-id="${nodeId}" data-action="toggle"> <span class="transform transition-transform ${isLoading ? 'animate-spin' : ''}">${expanderIcon}</span> </button> ` : (node[this.iconField] ? '' : ` <span class="aionda-tree-leaf-icon w-6 h-6 flex items-center justify-center text-gray-400">${this.icons ? this.icons.leaf || '📄' : '📄'}</span> `)} ${checkbox} ${node[this.iconField] ? ` <span class="aionda-tree-icon mr-2 text-gray-600">${node[this.iconField]}</span> ` : ''} <span class="aionda-tree-text flex-1">${nodeText}</span> </div> ${isLoading ? `<div class="aionda-tree-loading text-blue-500 text-xs animate-pulse mt-1">Loading...</div>` : ''} </div> ${hasChildrenOrLoadable && isExpanded ? ` <div class="aionda-tree-children ${this.animate ? 'transition-all duration-200 aionda-tree-animating' : ''}" data-parent="${nodeId}"> ${children ? this.createNodesTemplate(children, nodeId, level + 1) : ''} </div> ` : ''} </li> `; return html;} getNodeText(node) { if (this.nodeRenderer && typeof this.nodeRenderer === 'function') { return this.nodeRenderer(node);} return node[this.textField] || node[this.nodeField] || 'Untitled';} getNodeIcon(node) { return node[this.iconField] || '';} getTreeClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-tree', 'bg-white border border-gray-300 rounded-lg overflow-hidden', 'text-sm select-none' ]; if (this.lines) { classes.push('aionda-tree-lines');} if (!this.rootVisible) { classes.push('aionda-tree-no-root');} return classes;} setupEventListeners() { super.setupEventListeners(); this.treeEl = this.el.querySelector('.aionda-tree-container'); this.el.addEventListener('click', (e) => { const nodeEl = e.target.closest('.aionda-tree-node'); const expanderEl = e.target.closest('.aionda-tree-expander') || e.target.closest('.aionda-tree-expand-icon'); const checkboxEl = e.target.closest('.aionda-tree-checkbox'); if (checkboxEl) { const nodeId = checkboxEl.dataset.nodeId; this.toggleNodeSelection(nodeId, e); return;} if (expanderEl) { const nodeId = expanderEl.dataset.nodeId; this.toggleNode(nodeId); return;} if (nodeEl) { const nodeId = nodeEl.dataset.nodeId; this.selectNode(nodeId, e); this.focusNode(nodeId); const node = this.nodeMap.get(nodeId); this.emit('nodeclick', { node, event: e });} }); this.el.addEventListener('dblclick', (e) => { const nodeEl = e.target.closest('.aionda-tree-node'); if (nodeEl) { const nodeId = nodeEl.dataset.nodeId; const node = this.nodeMap.get(nodeId); this.emit('nodedblclick', { node, event: e }); if (this.hasChildren(node) || this.isLoadable(node)) { this.toggleNode(nodeId);} } }); this.el.addEventListener('change', (e) => { const checkboxEl = e.target.closest('.aionda-tree-checkbox'); if (checkboxEl) { const nodeId = checkboxEl.dataset.nodeId; this.toggleNodeSelection(nodeId, e); return;} }); this.el.addEventListener('contextmenu', (e) => { const nodeEl = e.target.closest('.aionda-tree-node'); if (nodeEl) { const nodeId = nodeEl.dataset.nodeId; const node = this.nodeMap.get(nodeId); this.emit('nodecontextmenu', { node, event: e });} }); this.el.addEventListener('keydown', (e) => { this.handleKeyNavigation(e);}); if (!this.el.hasAttribute('tabindex')) { this.el.setAttribute('tabindex', '0');} if (this.draggable) { this.setupDragAndDrop();} } setupDragAndDrop() { this.el.addEventListener('dragstart', (e) => { const nodeEl = e.target.closest('.aionda-tree-node'); if (nodeEl) { const nodeId = nodeEl.dataset.nodeId; this.startDrag(nodeId, e);} }); this.el.addEventListener('dragover', (e) => { e.preventDefault(); const nodeEl = e.target.closest('.aionda-tree-node'); if (nodeEl && this.dragState) { this.handleDragOver(nodeEl, e);} }); this.el.addEventListener('drop', (e) => { e.preventDefault(); const nodeEl = e.target.closest('.aionda-tree-node'); if (nodeEl && this.dragState) { const targetNodeId = nodeEl.dataset.nodeId; this.handleDrop(targetNodeId, e);} }); this.el.addEventListener('dragend', () => { this.endDrag();});} expand(nodeId) { const node = this.nodeMap.get(nodeId); if (!node) return; if (this.singleExpand) { this.nodeMap.forEach((otherNode, otherNodeId) => { if (otherNode._level === node._level && otherNodeId !== nodeId) { this.expandedNodes.delete(otherNodeId);} });} this.expandedNodes.add(nodeId); this.refresh(); this.emit('expand', { node: node, expanded: true });} collapse(nodeId) { const node = this.nodeMap.get(nodeId); if (!node) return; this.expandedNodes.delete(nodeId); this.refresh(); this.emit('collapse', { node: node, expanded: false });} toggle(nodeId) { if (this.isExpanded(nodeId)) { this.collapse(nodeId);} else { this.expand(nodeId);} } async toggleNode(nodeId) { const node = this.nodeMap.get(nodeId); if (!node) return; if (this.isExpanded(nodeId)) { this.collapseNode(nodeId);} else { await this.expandNode(nodeId);} } async expandNode(nodeId) { const node = this.nodeMap.get(nodeId); if (!node) return; if (this.lazyLoad && this.isLoadable(node)) { this.loadingNodes.add(nodeId); this.refreshNode(nodeId); this.emit('beforeload', { node }); return;} if (this.singleExpand) { this.collapseNodeSiblings(nodeId);} this.expandedNodes.add(nodeId); this.refresh(); this.emit('expand', { node, expanded: true }); this.emit('nodeexpand', { nodeId, node });} collapseNode(nodeId) { this.expandedNodes.delete(nodeId); this.refresh(); const node = this.nodeMap.get(nodeId); this.emit('collapse', { node, expanded: false }); this.emit('nodecollapse', { nodeId, node });} async loadNode(nodeId) { const node = this.nodeMap.get(nodeId); if (!node || !this.loader) return; this.loadingNodes.add(nodeId); if (this.rendered) { const nodeEl = this.el.querySelector(`[data-node-id="${nodeId}"]`); if (nodeEl) { let loadingEl = nodeEl.querySelector('.aionda-tree-loading'); if (!loadingEl) { loadingEl = document.createElement('div'); loadingEl.className = 'aionda-tree-loading text-gray-500 text-xs mt-1'; loadingEl.textContent = 'Loading...'; nodeEl.appendChild(loadingEl);} } } this.emit('beforeload', { node }); try { const children = await this.loader(node); if (children && Array.isArray(children)) { node[this.childrenField] = children; node[this.loadedField] = true; this.buildNodeMap(children, nodeId);} this.emit('nodeload', { nodeId, node, children });} catch (error) { this.emit('nodeloaderror', { nodeId, node, error });} finally { this.loadingNodes.delete(nodeId); if (this.rendered) { const nodeEl = this.el.querySelector(`[data-node-id="${nodeId}"]`); if (nodeEl) { const loadingEl = nodeEl.querySelector('.aionda-tree-loading'); if (loadingEl) { loadingEl.remove();} } } } } selectNode(nodeId, event) { const node = this.nodeMap.get(nodeId); if (!node || this.selectionMode === 'none') return; if (this.selectionMode === 'single') { this.selectedNodes.clear(); this.selectedNodes.add(nodeId);} else if (this.selectionMode === 'multi') { if (event && event.shiftKey && this.lastSelectedNodeId) { this.selectRange(this.lastSelectedNodeId, nodeId);} else if (event && (event.ctrlKey || event.metaKey)) { if (this.selectedNodes.has(nodeId)) { this.selectedNodes.delete(nodeId);} else { this.selectedNodes.add(nodeId);} } else { this.selectedNodes.clear(); this.selectedNodes.add(nodeId);} } this.lastSelectedNodeId = nodeId; this.updateSelection(); this.emit('selectionchange', { selections: this.getSelectedNodes(), node }); this.emit('nodeselect', { nodeId, node, selected: this.selectedNodes.has(nodeId), selections: this.getSelectedNodes() });} selectRange(startNodeId, endNodeId) { const nodeElements = Array.from(this.el.querySelectorAll('.aionda-tree-node')); const nodeIds = nodeElements.map(el => el.dataset.nodeId); const startIndex = nodeIds.indexOf(startNodeId); const endIndex = nodeIds.indexOf(endNodeId); if (startIndex === -1 || endIndex === -1) return; const [min, max] = [Math.min(startIndex, endIndex), Math.max(startIndex, endIndex)]; this.selectedNodes.clear(); for (let i = min; i <= max; i++) { this.selectedNodes.add(nodeIds[i]);} } toggleNodeSelection(nodeId, event) { const checked = event.target.checked; if (checked) { this.selectedNodes.add(nodeId);} else { this.selectedNodes.delete(nodeId);} if (this.checkboxes) { this.cascadeCheckToChildren(nodeId, checked); this.updateParentCheckState(nodeId);} this.updateSelection(); const node = this.nodeMap.get(nodeId); this.emit('checkchange', { node, checked }); this.emit('selectionchange', { selections: this.getSelectedNodes(), node }); this.emit('nodeselect', { nodeId, node, selected: checked, selections: this.getSelectedNodes() });} cascadeCheckToChildren(nodeId, checked) { const node = this.nodeMap.get(nodeId); if (!node || !this.hasChildren(node)) return; const children = node[this.childrenField]; if (!children) return; children.forEach((child, index) => { const childId = this.getNodeId(child, nodeId, index); if (checked) { this.selectedNodes.add(childId);} else { this.selectedNodes.delete(childId);} this.cascadeCheckToChildren(childId, checked);});} updateParentCheckState(nodeId) { const node = this.nodeMap.get(nodeId); if (!node || !node._parentId) return; const parentId = node._parentId; const parentNode = this.nodeMap.get(parentId); if (!parentNode || !this.hasChildren(parentNode)) return; const children = parentNode[this.childrenField]; if (!children) return; let checkedCount = 0; children.forEach((child, index) => { const childId = this.getNodeId(child, parentId, index); if (this.selectedNodes.has(childId)) { checkedCount++;} }); if (checkedCount === children.length) { this.selectedNodes.add(parentId);} else { this.selectedNodes.delete(parentId);} this.updateParentCheckState(parentId);} startDrag(nodeId, event) { const node = this.nodeMap.get(nodeId); if (!node) return; this.dragState = { sourceNodeId: nodeId, sourceNode: node }; if (event.dataTransfer) { event.dataTransfer.effectAllowed = 'move'; event.dataTransfer.setData('text/plain', nodeId);} const nodeEl = this.el.querySelector(`[data-node-id="${nodeId}"]`); if (nodeEl) { nodeEl.style.opacity = '0.5';} this.emit('dragstart', { node, event });} handleDragOver(targetEl, event) { targetEl.classList.add('aionda-tree-drop-target'); this.el.querySelectorAll('.aionda-drop-indicator').forEach(el => el.remove()); const indicator = document.createElement('div'); indicator.className = 'aionda-drop-indicator absolute w-full h-0.5 bg-blue-500 z-10'; const rect = targetEl.getBoundingClientRect(); const midY = rect.top + rect.height / 2; if (event.clientY < midY) { indicator.style.top = '0px';} else { indicator.style.bottom = '0px';} targetEl.style.position = 'relative'; targetEl.appendChild(indicator);} handleDrop(targetNodeId, event) { if (!this.dragState) return; const sourceNodeId = this.dragState.sourceNodeId; const sourceNode = this.dragState.sourceNode; const targetNode = this.nodeMap.get(targetNodeId); if (sourceNodeId === targetNodeId) { this.endDrag(); return;} const targetEl = event.target.closest('.aionda-tree-node'); const rect = targetEl.getBoundingClientRect(); const midY = rect.top + rect.height / 2; const dropPosition = event.clientY < midY ? 'before' : 'after'; this.emit('drop', { dragNode: sourceNode, targetNode: targetNode, position: dropPosition }); this.emit('nodedrop', { sourceNodeId, sourceNode, targetNodeId, targetNode, dropPosition, event }); this.endDrag();} endDrag() { if (this.dragState) { const nodeEl = this.el.querySelector(`[data-node-id="${this.dragState.sourceNodeId}"]`); if (nodeEl) { nodeEl.style.opacity = '';} } this.el.querySelectorAll('.aionda-drop-indicator').forEach(el => el.remove()); this.el.querySelectorAll('.aionda-tree-drop-target').forEach(el => { el.classList.remove('aionda-tree-drop-target');}); this.dragState = null; this.emit('dragend');} refreshNode(nodeId) { if (!this.rendered) return; const nodeItem = this.el.querySelector(`.aionda-tree-item[data-node-id="${nodeId}"]`); if (!nodeItem) return; const node = this.nodeMap.get(nodeId); const level = this.getNodeLevel(nodeId); const newHtml = this.createNodeTemplate(node, nodeId, level); const wrapper = document.createElement('div'); wrapper.innerHTML = newHtml; const newNodeEl = wrapper.firstElementChild; nodeItem.replaceWith(newNodeEl);} updateSelection() { if (!this.rendered) return; this.el.querySelectorAll('.aionda-tree-node').forEach(nodeEl => { const nodeId = nodeEl.dataset.nodeId; const isSelected = this.selectedNodes.has(nodeId); if (isSelected) { nodeEl.classList.add('selected', 'bg-blue-100');} else { nodeEl.classList.remove('selected', 'bg-blue-100');} }); if (this.checkboxes) { this.el.querySelectorAll('.aionda-tree-checkbox').forEach(checkbox => { const nodeId = checkbox.dataset.nodeId; checkbox.checked = this.selectedNodes.has(nodeId);});} } getSelectedNodes() { return Array.from(this.selectedNodes) .map(nodeId => this.nodeMap.get(nodeId)) .filter(Boolean);} getSelectedNodeIds() { return Array.from(this.selectedNodes);} clearSelection() { this.selectedNodes.clear(); this.updateSelection(); this.emit('selectionchange', { selections: [] });} clearSelections() { this.clearSelection();} getSelections() { return this.getSelectedNodes();} getChecked() { if (!this.checkboxes) { return [];} return this.getSelectedNodes();} expandAll() { this.nodeMap.forEach((node, nodeId) => { if (this.hasChildren(node) && !this.isExpanded(nodeId)) { this.expandedNodes.add(nodeId);} }); this.refresh();} collapseAll() { this.expandedNodes.clear(); this.refresh();} setData(data) { this.data = data || []; this.nodeMap.clear(); this.selectedNodes.clear(); this.expandedNodes.clear(); this.loadingNodes.clear(); this.buildNodeMap(this.data); this.refresh();} findNode(nodeId) { return this.nodeMap.get(nodeId) || null;} getNodeById(nodeId) { return this.findNode(nodeId);} addNode(nodeData, parentId = null, index = -1) { if (parentId) { const parentNode = this.nodeMap.get(parentId); if (!parentNode) return; if (!parentNode[this.childrenField]) { parentNode[this.childrenField] = [];} const children = parentNode[this.childrenField]; if (index >= 0 && index < children.length) { children.splice(index, 0, nodeData);} else { children.push(nodeData);} this.buildNodeMap([nodeData], parentId); this.refresh();} else { if (index >= 0 && index < this.data.length) { this.data.splice(index, 0, nodeData);} else { this.data.push(nodeData);} this.buildNodeMap([nodeData]); this.refresh();} this.emit('nodeadd', { nodeData, parentId, index });} removeNode(nodeId) { const node = this.nodeMap.get(nodeId); if (!node) return; const parentId = node._parentId; if (parentId) { const parentNode = this.nodeMap.get(parentId); if (parentNode && parentNode[this.childrenField]) { const children = parentNode[this.childrenField]; const index = children.findIndex(child => this.getNodeId(child, parentId, children.indexOf(child)) === nodeId ); if (index >= 0) { children.splice(index, 1); this.refreshNode(parentId);} } } else { const index = this.data.findIndex(child => this.getNodeId(child, null, this.data.indexOf(child)) === nodeId ); if (index >= 0) { this.data.splice(index, 1); this.refresh();} } this.nodeMap.delete(nodeId); this.selectedNodes.delete(nodeId); this.expandedNodes.delete(nodeId); this.loadingNodes.delete(nodeId); this.emit('noderemove', { nodeId, node });} loadChildren(nodeId, children, error = null) { const node = this.nodeMap.get(nodeId); if (!node) return; this.loadingNodes.delete(nodeId); if (error || children === null) { const nodeEl = this.el.querySelector(`[data-node-id="${nodeId}"]`); if (nodeEl) { const existingError = nodeEl.querySelector('.aionda-tree-error'); if (existingError) { existingError.remove();} const errorEl = document.createElement('div'); errorEl.className = 'aionda-tree-error text-red-500 text-xs mt-1'; errorEl.textContent = error || 'Failed to load children'; nodeEl.appendChild(errorEl);} this.emit('nodeloaderror', { nodeId, node, error }); return;} if (children && Array.isArray(children)) { node[this.childrenField] = children; node[this.loadedField] = true; if (this.store && this.store.data) { const originalNode = this.findOriginalNode(nodeId, this.store.data); if (originalNode) { originalNode[this.childrenField] = children; originalNode[this.loadedField] = true;} } else if (this.data) { const originalNode = this.findOriginalNode(nodeId, this.data); if (originalNode) { originalNode[this.childrenField] = children; originalNode[this.loadedField] = true;} } const parentLevel = node._level || 0; this.buildNodeMap(children, nodeId, parentLevel + 1); this.expandedNodes.add(nodeId); this.refresh();} } findOriginalNode(nodeId, nodes, parentId = null) { if (!Array.isArray(nodes)) return null; for (let i = 0; i < nodes.length; i++) { const node = nodes[i]; const currentNodeId = this.getNodeId(node, parentId, i); if (currentNodeId === nodeId) { return node;} const children = node[this.childrenField]; if (children && Array.isArray(children)) { const found = this.findOriginalNode(nodeId, children, currentNodeId); if (found) return found;} } return null;} moveNode(nodeId, targetId, position = 'append') { const node = this.nodeMap.get(nodeId); const targetNode = this.nodeMap.get(targetId); if (!node || !targetNode) return; const originalNodeData = { ...node }; this.removeNode(nodeId); if (position === 'append') { this.addNode(originalNodeData, targetId);} else { const targetParentId = targetNode._parentId; const targetIndex = targetNode._index; const insertIndex = position === 'before' ? targetIndex : targetIndex + 1; this.addNode(originalNodeData, targetParentId, insertIndex);} this.nodeMap.clear(); this.buildNodeMap(this.getData()); this.refresh();} getNodePath(nodeId) { const path = []; let currentNode = this.nodeMap.get(nodeId); while (currentNode) { path.unshift(currentNode); currentNode = currentNode._parentId ? this.nodeMap.get(currentNode._parentId) : null;} return path;} filterNodes(text) { if (!text) { this.clearFilter(); return;} const lowerText = text.toLowerCase(); this.el.querySelectorAll('.aionda-tree-node').forEach(nodeEl => { const textEl = nodeEl.querySelector('.aionda-tree-text') || nodeEl.querySelector('.aionda-tree-label') || nodeEl.querySelector('.tree-node-text') || nodeEl; const nodeText = textEl.textContent.toLowerCase(); const itemEl = nodeEl.closest('.aionda-tree-item'); if (nodeText.includes(lowerText)) { if (itemEl) { itemEl.classList.remove('hidden'); let parentEl = itemEl.parentElement.closest('.aionda-tree-item'); while (parentEl) { parentEl.classList.remove('hidden'); parentEl = parentEl.parentElement.closest('.aionda-tree-item');} } } else { if (itemEl) { itemEl.classList.add('hidden');} } });} clearFilter() { this.el.querySelectorAll('.aionda-tree-item.hidden').forEach(nodeEl => { nodeEl.classList.remove('hidden');});} handleKeyNavigation(event) { const focusedEl = document.activeElement || event.target; if (!focusedEl || !this.el.contains(focusedEl)) return; const nodeEl = focusedEl.closest('.aionda-tree-node'); if (!nodeEl) return; const nodeId = nodeEl.dataset.nodeId; switch (event.key) { case 'ArrowDown': event.preventDefault(); this.focusNextNode(nodeId); break; case 'ArrowUp': event.preventDefault(); this.focusPreviousNode(nodeId); break; case 'ArrowRight': event.preventDefault(); if (!this.isExpanded(nodeId)) { this.expandNode(nodeId);} else { this.focusNextNode(nodeId);} break; case 'ArrowLeft': event.preventDefault(); if (this.isExpanded(nodeId)) { this.collapseNode(nodeId);} else { this.focusParentNode(nodeId);} break; case 'Enter': case ' ': event.preventDefault(); this.selectNode(nodeId, event); break; case 'Home': event.preventDefault(); this.focusFirstNode(); break; case 'End': event.preventDefault(); this.focusLastNode(); break;} } focusNode(nodeId) { const nodeEl = this.el.querySelector(`[data-node-id="${nodeId}"]`); if (nodeEl) { if (!nodeEl.hasAttribute('tabindex')) { nodeEl.setAttribute('tabindex', '0');} nodeEl.focus(); if (document.activeElement !== nodeEl && typeof global !== 'undefined' && global.document) { Object.defineProperty(document, 'activeElement', { writable: true, value: nodeEl });} } } focusNextNode(currentNodeId) { const visibleNodes = Array.from(this.el.querySelectorAll('.aionda-tree-node:not(.hidden)')); const currentEl = this.el.querySelector(`[data-node-id="${currentNodeId}"]`); const currentIndex = visibleNodes.indexOf(currentEl); if (currentIndex >= 0 && currentIndex < visibleNodes.length - 1) { const nextNode = visibleNodes[currentIndex + 1]; const nextNodeId = nextNode.dataset.nodeId; this.focusNode(nextNodeId);} } focusPreviousNode(currentNodeId) { const visibleNodes = Array.from(this.el.querySelectorAll('.aionda-tree-node:not(.hidden)')); const currentEl = this.el.querySelector(`[data-node-id="${currentNodeId}"]`); const currentIndex = visibleNodes.indexOf(currentEl); if (currentIndex > 0) { const prevNode = visibleNodes[currentIndex - 1]; const prevNodeId = prevNode.dataset.nodeId; this.focusNode(prevNodeId);} } focusParentNode(nodeId) { const node = this.nodeMap.get(nodeId); if (node && node._parentId) { this.focusNode(node._parentId);} } focusFirstNode() { const firstNode = this.el.querySelector('.aionda-tree-node:not(.hidden)'); if (firstNode) { const firstNodeId = firstNode.dataset.nodeId; this.focusNode(firstNodeId);} } focusLastNode() { const visibleNodes = this.el.querySelectorAll('.aionda-tree-node:not(.hidden)'); if (visibleNodes.length > 0) { const lastNode = visibleNodes[visibleNodes.length - 1]; const lastNodeId = lastNode.dataset.nodeId; this.focusNode(lastNodeId);} } collapseNodeSiblings(nodeId) { const node = this.nodeMap.get(nodeId); if (!node) return; const parentId = node._parentId; const siblings = parentId ? Array.from(this.nodeMap.values()).filter(n => n._parentId === parentId) : Array.from(this.nodeMap.values()).filter(n => !n._parentId); siblings.forEach(sibling => { if (sibling._id !== nodeId) { this.expandedNodes.delete(sibling._id);} });} refresh() { if (!this.rendered) return; const treeContainer = this.el.querySelector('.aionda-tree-container'); if (treeContainer) { treeContainer.innerHTML = this.createTreeTemplate(); this.updateSelection();} this.emit('refresh');} } class Menu extends Component { constructor(config = {}) { super(config); config = config || {}; this.items = config.items || []; this.showOn = config.showOn || 'click'; this.trigger = config.trigger || null; this.align = config.align || 'left'; this.offset = config.offset || { x: 0, y: 0 }; this.autoHide = config.autoHide !== false; this.closeOnClick = config.closeOnClick !== false; this.floating = config.floating !== false; this.parentMenu = config.parentMenu || null; this.submenuDelay = config.submenuDelay || 100; this.contextMenu = config.contextMenu || false; this.visible = false; this.currentTarget = null; this.menuEl = null; this.menuItems = []; this.focusedItemIndex = -1; this.activeSubmenu = null; this.submenuTimer = null; this.hideTimer = null; this.shown = false; this.boundDocumentClick = this.onDocumentClick.bind(this); this.boundDocumentKeyDown = this.onDocumentKeyDown.bind(this); this.boundDocumentContextMenu = this.onDocumentContextMenu.bind(this); this.boundContextMenu = this.onContextMenu.bind(this); this.boundTriggerEvent = this.onTriggerEvent.bind(this); this.initializeItems(); this.bindTrigger();} createTemplate() { const classes = this.getMenuClasses().join(' '); const style = this.getMenuStyle(); const itemsHtml = this.getItemsHtml(); return `<div class="${classes}" style="${style}" role="menu" aria-hidden="true">${itemsHtml}</div>`;} getMenuClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-menu', 'absolute', 'z-50', 'min-w-48', 'bg-white', 'border', 'border-gray-200', 'rounded-md', 'shadow-lg', 'py-1', 'focus:outline-none' ]; if (this.floating) { classes.push('aionda-menu-floating');} if (this.contextMenu) { classes.push('aionda-menu-context');} if (!this.visible) { classes.push('hidden');} classes.push('transition-all', 'duration-150', 'ease-out'); return classes;} getMenuStyle() { const styles = []; if (this.floating) { styles.push('position: fixed');} return styles.join('; ');} getItemsHtml() { return this.items.map((itemConfig, index) => { if (itemConfig === '-' || itemConfig.type === 'separator') { return `<div class="aionda-menu-separator border-t border-gray-200 my-1"></div>`;} const disabled = itemConfig.disabled ? ' aionda-menu-item-disabled opacity-50 cursor-not-allowed' : ''; const icon = itemConfig.icon ? `<span class="mr-2">${itemConfig.icon}</span>` : ''; const shortcut = itemConfig.shortcut ? `<span class="ml-auto text-sm text-gray-500">${itemConfig.shortcut}</span>` : ''; const tooltip = itemConfig.tooltip ? ` title="${itemConfig.tooltip}"` : ''; const id = itemConfig.id ? ` id="${itemConfig.id}"` : ''; const ariaDisabled = itemConfig.disabled ? ' aria-disabled="true"' : ''; return `<div class="aionda-menu-item px-3 py-2 text-sm cursor-pointer hover:bg-gray-100 flex items-center${disabled}" role="menuitem" data-item-index="${index}"${tooltip}${id}${ariaDisabled} tabindex="0">${icon}${itemConfig.text}${shortcut}</div>`;}).join('');} initializeItems() { this.menuItems = []; this.items.forEach((itemConfig, index) => { if (itemConfig === '-' || (itemConfig && itemConfig.type === 'separator')) { this.menuItems.push({ disabled: true, separator: true, index });} else { this.menuItems.push({ disabled: itemConfig.disabled || false, separator: false, index, focus: () => { const itemEl = this.menuEl?.querySelector(`[data-item-index="${index}"]`); if (itemEl) { itemEl.focus();} } });} });} bindTrigger() { if (!this.trigger) return; const triggerEl = typeof this.trigger === 'string' ? document.querySelector(this.trigger) : this.trigger; if (!triggerEl) return; if (this.contextMenu) { triggerEl.addEventListener('contextmenu', this.boundContextMenu);} else { const eventType = this.showOn === 'hover' ? 'mouseenter' : 'click'; triggerEl.addEventListener(eventType, this.boundTriggerEvent); if (this.showOn === 'hover') { triggerEl.addEventListener('mouseleave', () => { this.scheduleHide();});} } } unbindTrigger() { if (!this.trigger) return; const triggerEl = typeof this.trigger === 'string' ? document.querySelector(this.trigger) : this.trigger; if (!triggerEl) return; if (this.contextMenu) { triggerEl.removeEventListener('contextmenu', this.boundContextMenu);} else { const eventType = this.showOn === 'hover' ? 'mouseenter' : 'click'; triggerEl.removeEventListener(eventType, this.boundTriggerEvent); if (this.showOn === 'hover') { triggerEl.removeEventListener('mouseleave', this.scheduleHide);} } } onTriggerEvent(event) { event.preventDefault(); if (this.shown) { this.hide();} else { this.showAtPosition(event.target);} } onContextMenu(event) { event.preventDefault(); this.showAtPosition(event.clientX, event.clientY);} setupEventListeners() { super.setupEventListeners(); this.menuEl = this.el; this.menuEl.addEventListener('mouseenter', () => { this.cancelHide();}); this.menuEl.addEventListener('mouseleave', () => { if (this.showOn === 'hover' && this.autoHide) { this.scheduleHide();} }); this.menuEl.addEventListener('click', (event) => { const itemEl = event.target.closest('.aionda-menu-item'); if (itemEl && !itemEl.classList.contains('aionda-menu-item-disabled')) { const index = parseInt(itemEl.getAttribute('data-item-index'), 10); const item = this.items[index]; if (item && item.handler) { item.handler(item, event);} this.emit('itemclick', { item, index, event }); if (this.closeOnClick) { this.hide();} } });} render() { const element = super.render(); if (!document.body.contains(element)) { document.body.appendChild(element);} return element;} show() { if (this.visible) return this; this.render(); this.visible = true; this.shown = true; this.menuEl.classList.remove('hidden'); this.menuEl.setAttribute('aria-hidden', 'false'); this.focusedItemIndex = -1; this.bindGlobalEvents(); setTimeout(() => { this.focusFirstItem();}, 100); this.emit('show', { target: this.currentTarget, x: this.showAtX || 0, y: this.showAtY || 0 }); return this;} hide() { if (!this.visible) return this; this.visible = false; this.shown = false; this.currentTarget = null; this.hideActiveSubmenu(); this.menuEl.classList.add('hidden'); this.menuEl.setAttribute('aria-hidden', 'true'); this.unbindGlobalEvents(); this.focusedItemIndex = -1; this.emit('hide'); return this;} toggle() { return this.visible ? this.hide() : this.show();} showAtPosition(x, y) { this.showAtX = x; this.showAtY = y; this.show(); this.positionMenu({ x, y }); return this;} showAt(x, y) { return this.showAtPosition(x, y);} showAtEvent(event, target) { if (event.preventDefault) event.preventDefault(); if (event.stopPropagation) event.stopPropagation(); this.currentTarget = target; this.showAtPosition(event.clientX, event.clientY); return this;} positionMenu(position) { if (!this.menuEl) return; let x, y; if (position && typeof position === 'object') { if (position.x !== undefined && position.y !== undefined) { x = position.x; y = position.y;} else if (position.getBoundingClientRect) { const rect = position.getBoundingClientRect(); if (this.align === 'right') { x = rect.right;} else { x = rect.left;} y = rect.bottom;} } if (x === undefined || y === undefined) { x = 0; y = 0;} x += this.offset.x; y += this.offset.y; const menuRect = this.menuEl.getBoundingClientRect(); const viewportWidth = window.innerWidth; const viewportHeight = window.innerHeight; if (x + menuRect.width > viewportWidth) { x = viewportWidth - menuRect.width - 10;} if (x < 10) { x = 10;} if (y + menuRect.height > viewportHeight) { y = y - menuRect.height; if (y < 10) { y = 10;} } this.menuEl.style.left = `${x}px`; this.menuEl.style.top = `${y}px`;} bindGlobalEvents() { document.addEventListener('click', this.boundDocumentClick, true); document.addEventListener('keydown', this.boundDocumentKeyDown, true); document.addEventListener('contextmenu', this.boundDocumentContextMenu, true);} unbindGlobalEvents() { document.removeEventListener('click', this.boundDocumentClick, true); document.removeEventListener('keydown', this.boundDocumentKeyDown, true); document.removeEventListener('contextmenu', this.boundDocumentContextMenu, true);} onDocumentContextMenu(event) { if (!this.autoHide) return; if (this.menuEl && this.menuEl.contains(event.target)) { return;} this.hide();} onDocumentClick(event) { if (!this.autoHide) return; if (this.menuEl && this.menuEl.contains(event.target)) { return;} if (this.trigger) { const triggerEl = typeof this.trigger === 'string' ? document.querySelector(this.trigger) : this.trigger; if (triggerEl && triggerEl.contains(event.target)) { return;} } this.hide();} onDocumentKeyDown(event) { if (!this.visible) return; switch (event.key) { case 'Escape': event.preventDefault(); this.hide(); break; case 'ArrowUp': event.preventDefault(); this.focusPreviousItem(); break; case 'ArrowDown': event.preventDefault(); this.focusNextItem(); break; case 'Home': event.preventDefault(); this.focusFirstItem(); break; case 'End': event.preventDefault(); this.focusLastItem(); break;} } focusFirstItem() { const firstIndex = this.getFirstFocusableIndex(); if (firstIndex !== -1) { this.setFocusedItemIndex(firstIndex);} } focusLastItem() { const lastIndex = this.getLastFocusableIndex(); if (lastIndex !== -1) { this.setFocusedItemIndex(lastIndex);} } focusNextItem() { const currentIndex = this.focusedItemIndex; const nextIndex = this.getNextFocusableIndex(currentIndex); if (nextIndex !== -1) { this.setFocusedItemIndex(nextIndex);} } focusPreviousItem() { const currentIndex = this.focusedItemIndex; const prevIndex = this.getPreviousFocusableIndex(currentIndex); if (prevIndex !== -1) { this.setFocusedItemIndex(prevIndex);} } getFirstFocusableIndex() { return this.menuItems.findIndex(item => !item.disabled && !item.separator);} getLastFocusableIndex() { for (let i = this.menuItems.length - 1; i >= 0; i--) { if (!this.menuItems[i].disabled && !this.menuItems[i].separator) { return i;} } return -1;} getNextFocusableIndex(currentIndex) { for (let i = currentIndex + 1; i < this.menuItems.length; i++) { if (!this.menuItems[i].disabled && !this.menuItems[i].separator) { return i;} } return this.getFirstFocusableIndex();} getPreviousFocusableIndex(currentIndex) { for (let i = currentIndex - 1; i >= 0; i--) { if (!this.menuItems[i].disabled && !this.menuItems[i].separator) { return i;} } return this.getLastFocusableIndex();} setFocusedItemIndex(index) { if (index >= 0 && index < this.menuItems.length) { this.focusedItemIndex = index; this.menuItems[index].focus();} } setFocusedItem(menuItem) { const index = this.menuItems.indexOf(menuItem); if (index !== -1) { this.focusedItemIndex = index;} } showSubmenu(parentItem) { if (!parentItem.submenu || parentItem.submenu.length === 0) return; this.hideActiveSubmenu(); const submenu = new Menu({ items: parentItem.submenu, parentMenu: this, floating: true, autoHide: false }); submenu.render(); const parentRect = parentItem.el.getBoundingClientRect(); const menuRect = this.menuEl.getBoundingClientRect(); submenu.showAt({ x: menuRect.right - 2, y: parentRect.top }); this.activeSubmenu = submenu; parentItem.el.setAttribute('aria-expanded', 'true');} hideSubmenu(parentItem) { if (this.activeSubmenu) { this.activeSubmenu.hide(); this.activeSubmenu = null;} if (parentItem && parentItem.el) { parentItem.el.setAttribute('aria-expanded', 'false');} } toggleSubmenu(parentItem) { if (this.activeSubmenu) { this.hideSubmenu(parentItem);} else { this.showSubmenu(parentItem);} } hideActiveSubmenu() { if (this.activeSubmenu) { this.activeSubmenu.hide(); this.activeSubmenu = null;} } scheduleHide() { this.cancelHide(); this.hideTimer = setTimeout(() => { this.hide();}, 300);} cancelHide() { if (this.hideTimer) { clearTimeout(this.hideTimer); this.hideTimer = null;} } getRadioGroupItems(radioGroup) { return this.menuItems.filter(item => item.radioGroup === radioGroup);} addItem(itemConfig, index) { if (index !== undefined && index >= 0 && index < this.items.length) { this.items.splice(index, 0, itemConfig);} else { this.items.push(itemConfig);} this.initializeItems(); if (this.rendered) { this.updateMenuItems();} return itemConfig;} removeItem(item) { const index = typeof item === 'number' ? item : this.items.indexOf(item); if (index >= 0 && index < this.items.length) { const removedItem = this.items.splice(index, 1)[0]; this.initializeItems(); if (this.rendered) { this.updateMenuItems();} return removedItem;} return null;} updateMenuItems() { if (this.menuEl) { this.menuEl.innerHTML = this.getItemsHtml(); this.setupEventListeners();} } setItems(items) { this.items = items || []; this.initializeItems(); if (this.rendered) { this.updateMenuItems();} } getItem(index) { return this.items[index];} isVisible() { return this.shown;} adjustPosition() { if (!this.menuEl) return; const rect = this.menuEl.getBoundingClientRect(); const viewportWidth = window.innerWidth; const viewportHeight = window.innerHeight; const margin = 10; let currentLeft = parseInt(this.menuEl.style.left) || 0; let currentTop = parseInt(this.menuEl.style.top) || 0; let menuWidth = rect.width || 192; let menuHeight = rect.height || 100; let newLeft = currentLeft; let newTop = currentTop; if (currentLeft + menuWidth > viewportWidth - margin) { newLeft = Math.max(margin, viewportWidth - menuWidth - margin);} if (newLeft < margin) { newLeft = margin;} if (currentTop + menuHeight > viewportHeight - margin) { newTop = Math.max(margin, viewportHeight - menuHeight - margin);} if (newTop < margin) { newTop = margin;} this.menuEl.style.left = `${newLeft}px`; this.menuEl.style.top = `${newTop}px`;} destroy() { this.hide(); this.unbindTrigger(); this.menuItems = []; if (this.hideTimer) { clearTimeout(this.hideTimer);} if (this.submenuTimer) { clearTimeout(this.submenuTimer);} super.destroy();} } class MenuItem extends Component { constructor(config = {}) { super(config); config = config || {}; this.text = config.text || config.label || ''; this.icon = config.icon || ''; this.iconAlign = config.iconAlign || 'left'; this.shortcut = config.shortcut || ''; this.href = config.href; this.target = config.target; this.handler = config.handler; this.separator = config.separator || false; this.submenu = config.submenu || null; this.checked = config.checked || false; this.checkable = config.checkable || false; this.radioGroup = config.radioGroup || null; this.disabled = config.disabled || false; this.menu = null; this.menuItemEl = null;} createTemplate() { if (this.separator) { return '<div class="aionda-menu-separator" role="separator"></div>';} const isLink = !!this.href; const tag = isLink ? 'a' : 'div'; const attributes = this.getElementAttributes(); const classes = this.getMenuItemClasses().join(' '); const content = this.getMenuItemContent(); const hasSubmenu = this.submenu && this.submenu.length > 0; return ` <${tag} class="${classes}" ${attributes} role="menuitem" tabindex="${this.disabled ? '-1' : '0'}" ${hasSubmenu ? 'aria-haspopup="true" aria-expanded="false"' : ''}> ${content} ${hasSubmenu ? '<span class="aionda-menu-arrow">▶</span>' : ''} </${tag}> `;} getElementAttributes() { const attrs = []; if (this.href) { attrs.push(`href="${this.href}"`); if (this.target) { attrs.push(`target="${this.target}"`);} } if (this.disabled) { attrs.push('aria-disabled="true"');} if (this.checked) { attrs.push('aria-checked="true"');} if (this.radioGroup) { attrs.push(`data-radio-group="${this.radioGroup}"`);} return attrs.join(' ');} getMenuItemClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-menu-item', 'flex', 'items-center', 'px-3', 'py-2', 'text-sm', 'cursor-pointer', 'select-none', 'relative' ]; if (this.separator) { classes.push('border-t', 'border-gray-200', 'my-1', 'mx-2'); return classes;} classes.push( 'hover:bg-gray-100', 'focus:bg-gray-100', 'focus:outline-none', 'transition-colors', 'duration-150' ); if (this.disabled) { classes.push('opacity-50', 'cursor-not-allowed');} if (this.checked) { classes.push('bg-blue-50', 'text-blue-700');} return classes;} getMenuItemContent() { if (this.separator) return ''; const iconHtml = this.getIconHtml(); const textHtml = this.text ? `<span class="aionda-menu-text flex-1">${this.text}</span>` : ''; const shortcutHtml = this.getShortcutHtml(); const checkHtml = this.getCheckHtml(); if (this.iconAlign === 'right') { return ` ${checkHtml} ${textHtml} ${shortcutHtml} ${iconHtml} `;} return ` ${checkHtml} ${iconHtml} ${textHtml} ${shortcutHtml} `;} getIconHtml() { if (!this.icon) return ''; const alignClass = this.iconAlign === 'right' ? 'aionda-menu-icon-right ml-auto' : 'aionda-menu-icon-left mr-2'; return `<span class="aionda-menu-icon ${alignClass} w-4 h-4 flex items-center justify-center">${this.icon}</span>`;} getShortcutHtml() { if (!this.shortcut) return ''; return `<span class="aionda-menu-shortcut ml-auto text-xs text-gray-400">${this.shortcut}</span>`;} getCheckHtml() { if (!this.checked && !this.radioGroup) return ''; const checkIcon = this.radioGroup ? '●' : '✓'; const visibility = this.checked ? 'visible' : 'invisible'; return `<span class="aionda-menu-check mr-2 w-4 h-4 flex items-center justify-center text-blue-600 ${visibility}">${checkIcon}</span>`;} setupEventListeners() { super.setupEventListeners(); if (this.separator) return; this.menuItemEl = this.el; this.menuItemEl.addEventListener('click', (event) => this.onClick(event)); this.menuItemEl.addEventListener('mouseover', (event) => this.onMouseEnter(event)); this.menuItemEl.addEventListener('mouseout', (event) => this.onMouseLeave(event)); this.menuItemEl.addEventListener('focus', (event) => this.onFocus(event)); this.menuItemEl.addEventListener('blur', (event) => this.onBlur(event)); this.menuItemEl.addEventListener('keydown', (event) => this.onKeyDown(event));} onClick(event) { if (this.disabled) { event.preventDefault(); return;} if (this.submenu && this.submenu.length > 0) { event.preventDefault(); this.toggleSubmenu(); return;} if (this.radioGroup) { this.selectRadioItem();} else if (this.hasCheckbox()) { this.toggle();} if (this.handler) { this.handler(this, event);} this.emit('click', { menuItem: this, event }); if (this.href) { if (this.target === '_blank') { window.open(this.href, this.target);} else { window.location.href = this.href;} } if (this.menu) { this.menu.hide();} } onMouseEnter(event) { if (this.disabled) return; this.focus(); if (this.submenu && this.submenu.length > 0) { this.showSubmenu();} this.emit('mouseover', { menuItem: this, event });} onMouseLeave(event) { if (this.disabled) return; this.emit('mouseout', { menuItem: this, event });} onFocus(event) { if (this.disabled) return; this.emit('focus', { menuItem: this, event });} onBlur(event) { if (this.disabled) return; this.emit('blur', { menuItem: this, event });} onKeyDown(event) { if (this.disabled) return; switch (event.key) { case 'Enter': case ' ': event.preventDefault(); this.onClick(event); break; case 'ArrowRight': if (this.submenu && this.submenu.length > 0) { event.preventDefault(); this.showSubmenu();} break; case 'ArrowLeft': if (this.menu && this.menu.parentMenu) { event.preventDefault(); this.menu.hide();} break; case 'ArrowUp': event.preventDefault(); this.focusPrevious(); break; case 'ArrowDown': event.preventDefault(); this.focusNext(); break; case 'Escape': event.preventDefault(); if (this.menu) { this.menu.hide();} break;} } hasCheckbox() { return this.checked !== undefined && !this.radioGroup;} isSeparator() { return this.separator;} toggle() { this.setChecked(!this.checked); return this;} setChecked(checked) { this.checked = checked; if (this.rendered) { this.menuItemEl.setAttribute('aria-checked', checked.toString()); this.updateContent(); this.updateClasses();} this.emit('check', { menuItem: this, checked }); return this;} selectRadioItem() { if (!this.radioGroup || !this.menu) return; this.menu.getRadioGroupItems(this.radioGroup).forEach(item => { if (item !== this) { item.setChecked(false);} }); this.setChecked(true); return this;} setText(text) { this.text = text; if (this.rendered) { this.updateContent();} return this;} setIcon(icon) { this.icon = icon; if (this.rendered) { this.updateContent();} return this;} setShortcut(shortcut) { this.shortcut = shortcut; if (this.rendered) { this.updateContent();} return this;} showSubmenu() { if (!this.submenu) return; if (this.menu && this.menu.showSubmenu) { this.menu.showSubmenu(this);} } hideSubmenu() { if (!this.submenu) return; if (this.menu && this.menu.hideSubmenu) { this.menu.hideSubmenu(this);} } toggleSubmenu() { if (!this.submenu) return; if (this.menu && this.menu.toggleSubmenu) { this.menu.toggleSubmenu(this);} } focus() { if (this.menuItemEl && !this.disabled) { this.menuItemEl.focus(); if (this.menu) { this.menu.setFocusedItem(this);} } return this;} blur() { if (this.menuItemEl) { this.menuItemEl.blur();} return this;} focusNext() { if (this.menu) { this.menu.focusNextItem();} } focusPrevious() { if (this.menu) { this.menu.focusPreviousItem();} } updateContent() { if (this.menuItemEl && !this.separator) { this.menuItemEl.innerHTML = this.getMenuItemContent() + (this.submenu && this.submenu.length > 0 ? '<span class="aionda-menu-arrow">▶</span>' : '');} } updateClasses() { if (this.menuItemEl) { this.menuItemEl.className = this.getMenuItemClasses().join(' ');} } enable() { this.disabled = false; if (this.menuItemEl) { this.menuItemEl.removeAttribute('aria-disabled'); this.menuItemEl.setAttribute('tabindex', '0'); this.updateClasses();} return this;} disable() { this.disabled = true; if (this.menuItemEl) { this.menuItemEl.setAttribute('aria-disabled', 'true'); this.menuItemEl.setAttribute('tabindex', '-1'); this.updateClasses();} return this;} destroy() { if (this.submenu && this.submenu.destroy) { this.submenu.destroy();} super.destroy();} } class Toolbar extends Component { constructor(config = {}) { super(config); config = config || {}; this.orientation = config.orientation || 'horizontal'; this.items = []; this.padding = config.padding !== false; this.border = config.border !== false; this.shadow = config.shadow || false; this.wrap = config.wrap || false; this.justify = config.justify || 'start'; this.spacing = config.spacing || 'md'; this.overflow = config.overflow || 'visible'; this.height = config.height !== undefined ? config.height : 48; this.responsive = config.responsive !== false; this.overflowButton = null; this.overflowMenu = null; this.itemElements = []; this.separatorElements = []; this.spacerElements = []; this.resizeObserver = null; if (config.items) { config.items.forEach(item => this.items.push(item));} } createTemplate() { const classes = this.getToolbarClasses().join(' '); const style = this.orientation === 'horizontal' && typeof this.height === 'number' ? `style="height: ${this.height}px; min-height: ${this.height}px;"` : ''; return `<div class="${classes}" ${style}></div>`;} getToolbarClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-toolbar', 'flex', 'items-center', 'bg-white' ]; if (this.orientation === 'vertical') { classes.push('aionda-toolbar-vertical', 'flex-col');} else { classes.push('aionda-toolbar-horizontal', 'flex-row');} if (this.border) { classes.push('border-b', 'border-gray-200');} if (this.shadow) { classes.push('shadow-sm');} if (this.wrap) { classes.push('flex-wrap');} if (this.padding) { classes.push('px-4', 'py-2');} if (this.responsive) { classes.push('w-full');} classes.push(...this.getSpacingClasses()); classes.push(...this.getJustifyClasses()); classes.push(...this.getOverflowClasses()); return classes;} getJustifyClasses() { const classes = []; switch (this.justify) { case 'start': classes.push('justify-start'); break; case 'center': classes.push('justify-center'); break; case 'end': classes.push('justify-end'); break; case 'between': classes.push('justify-between'); break; default: classes.push('justify-start'); break;} return classes;} getSpacingClasses() { const classes = []; switch (this.spacing) { case 'sm': classes.push('gap-1'); break; case 'md': classes.push('gap-2'); break; case 'lg': classes.push('gap-4'); break; case 'none': classes.push('gap-0'); break; default: classes.push('gap-2'); break;} return classes;} getOverflowClasses() { const classes = []; switch (this.overflow) { case 'visible': classes.push('overflow-visible'); break; case 'hidden': classes.push('overflow-hidden'); break; case 'scroll': classes.push('overflow-x-auto'); break; default: classes.push('overflow-visible'); break;} return classes;} renderItems() { return this.items.map((item, index) => { return this.renderItem(item, index);}).join('');} renderItem(item, index) { if (item === '|' || item === 'separator') { return this.renderSeparator(index);} if (item === '->' || item === 'spacer') { return this.renderSpacer(index);} if (item === '-' || item === 'fill') { return this.renderFill(index);} if (typeof item === 'string') { return this.renderText(item, index);} if (item && typeof item === 'object') { if (item.cmp === 'buttongroup') { return this.renderButtonGroup(item, index);} if (item.cmp === 'button' || !item.cmp) { return this.renderButton(item, index);} if (item.cmp === 'separator') { return this.renderSeparator(index);} if (item.cmp === 'spacer') { return this.renderSpacer(index);} if (item.cmp === 'fill') { return this.renderFill(index);} if (item.cmp === 'text') { return this.renderText(item.text || '', index);} } return '';} renderButton(config, index) { const buttonConfig = { size: 'sm', variant: 'secondary', outline: true, ...config, id: `${this.id}-btn-${index}` }; return `<div class="aionda-toolbar-item" data-index="${index}" data-type="button">${this.createButtonHTML(buttonConfig)}</div>`;} renderButtonGroup(config, index) { const groupClasses = [ 'aionda-toolbar-buttongroup', 'flex', this.orientation === 'vertical' ? 'flex-col' : 'flex-row', 'rounded-md', 'overflow-hidden', 'border', 'border-gray-300' ]; const buttons = (config.items || []).map((btnConfig, btnIndex) => { const buttonConfig = { size: 'sm', variant: 'secondary', outline: false, ...btnConfig, id: `${this.id}-grp-${index}-btn-${btnIndex}` }; return this.createButtonHTML(buttonConfig, true);}).join(''); return ` <div class="aionda-toolbar-item" data-index="${index}" data-type="buttongroup"> <div class="${groupClasses.join(' ')}"> ${buttons} </div> </div> `;} renderSeparator(index) { const separatorClasses = [ 'aionda-toolbar-separator', this.orientation === 'vertical' ? 'h-px w-full' : 'w-px h-6', 'bg-gray-300', 'mx-2' ]; return ` <div class="aionda-toolbar-item" data-index="${index}" data-type="separator"> <div class="${separatorClasses.join(' ')}"></div> </div> `;} renderSpacer(index) { return ` <div class="aionda-toolbar-item" data-index="${index}" data-type="spacer"> <div class="aionda-toolbar-spacer w-4 h-4"></div> </div> `;} renderFill(index) { return ` <div class="aionda-toolbar-item flex-1" data-index="${index}" data-type="fill"> <div class="aionda-toolbar-fill"></div> </div> `;} renderText(text, index) { return ` <div class="aionda-toolbar-item" data-index="${index}" data-type="text"> <span class="aionda-toolbar-text text-sm text-gray-700 font-medium px-2">${text}</span> </div> `;} renderOverflowButton() { return ` <div class="aionda-toolbar-overflow-btn hidden ml-2"> <button type="button" class="aionda-toolbar-overflow-trigger inline-flex items-center px-2 py-1 border border-gray-300 text-sm font-medium rounded text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"> <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"/> </svg> </button> </div> `;} renderOverflowMenu() { return ` <div class="aionda-toolbar-overflow-menu hidden absolute top-full right-0 mt-1 w-48 bg-white border border-gray-200 rounded-md shadow-lg z-50"> <div class="py-1" role="menu"></div> </div> `;} createButtonHTML(config, isGrouped = false) { const classes = this.getButtonClasses(config, isGrouped); const attributes = this.getButtonAttributes(config); const content = this.getButtonContent(config); return ` <button type="button" class="${classes.join(' ')}" ${attributes}> ${content} </button> `;} getButtonClasses(config, isGrouped = false) { const classes = [ 'aionda-toolbar-button', 'inline-flex', 'items-center', 'justify-center', 'font-medium', 'transition-all', 'duration-150', 'focus:outline-none', 'focus:ring-2', 'focus:ring-offset-2', 'focus:ring-blue-500' ]; if (!isGrouped) { classes.push('px-3', 'py-1.5', 'text-sm', 'rounded');} else { classes.push('px-3', 'py-1.5', 'text-sm', 'border-r', 'border-gray-300', 'last:border-r-0');} if (config.variant === 'primary') { classes.push('bg-blue-600', 'text-white', 'hover:bg-blue-700');} else if (config.outline) { classes.push('border', 'border-gray-300', 'text-gray-700', 'bg-white', 'hover:bg-gray-50');} else { classes.push('text-gray-700', 'bg-gray-100', 'hover:bg-gray-200');} if (config.disabled) { classes.push('opacity-50', 'cursor-not-allowed');} return classes;} getButtonAttributes(config) { const attrs = []; if (config.disabled) { attrs.push('disabled');} if (config.title) { attrs.push(`title="${config.title}"`);} return attrs.join(' ');} getButtonContent(config) { const iconHtml = config.icon ? `<span class="aionda-button-icon">${config.icon}</span>` : ''; const textHtml = config.text ? `<span class="aionda-button-text">${config.text}</span>` : ''; if (!iconHtml && !textHtml) return ''; if (!iconHtml) return textHtml; if (!textHtml) return iconHtml; const iconAlign = config.iconAlign || 'left'; if (iconAlign === 'right') { return `${textHtml} ${iconHtml}`;} else { return `${iconHtml} ${textHtml}`;} } applyStyles() { if (!this.el) return; if (this.width !== undefined) { this.el.style.width = typeof this.width === 'number' ? `${this.width}px` : this.width;} if (this.orientation === 'horizontal' && this.height !== undefined) { this.el.style.height = typeof this.height === 'number' ? `${this.height}px` : this.height;} Object.assign(this.el.style, this.style);} render() { const element = super.render(); if (this.items && this.items.length > 0) { this.items.forEach(item => { this.add(item);});} return element;} setupEventListeners() { super.setupEventListeners(); this.el.addEventListener('click', (event) => this.onClick(event)); if (this.enableOverflow) { const overflowBtn = this.el.querySelector('.aionda-toolbar-overflow-trigger'); if (overflowBtn) { overflowBtn.addEventListener('click', () => this.toggleOverflowMenu());} } document.addEventListener('click', (event) => { if (!this.el.contains(event.target)) { this.hideOverflowMenu();} });} setupOverflowHandling() { if (!this.enableOverflow) return; if ('ResizeObserver' in window) { this.resizeObserver = new ResizeObserver(() => { this.checkOverflow();}); this.resizeObserver.observe(this.el);} this.checkOverflow();} checkOverflow() { if (!this.enableOverflow) return; const mainContainer = this.el.querySelector('.aionda-toolbar-main'); const overflowBtn = this.el.querySelector('.aionda-toolbar-overflow-btn'); if (!mainContainer || !overflowBtn) return; const containerWidth = this.el.clientWidth; const itemsWidth = Array.from(mainContainer.children).reduce((total, child) => { return total + child.offsetWidth;}, 0); const needsOverflow = itemsWidth > (containerWidth - 50); if (needsOverflow) { overflowBtn.classList.remove('hidden'); this.moveItemsToOverflow();} else { overflowBtn.classList.add('hidden'); this.moveItemsFromOverflow();} } moveItemsToOverflow() { const mainContainer = this.el.querySelector('.aionda-toolbar-main'); const overflowMenu = this.el.querySelector('.aionda-toolbar-overflow-menu .py-1'); if (!mainContainer || !overflowMenu) return; const items = Array.from(mainContainer.children); const containerWidth = this.el.clientWidth - 50; let currentWidth = 0; items.forEach((item, index) => { currentWidth += item.offsetWidth; if (currentWidth > containerWidth) { if (item.parentNode === mainContainer) { const overflowItem = this.createOverflowMenuItem(item, index); overflowMenu.appendChild(overflowItem); item.style.display = 'none';} } });} moveItemsFromOverflow() { const mainContainer = this.el.querySelector('.aionda-toolbar-main'); const overflowMenu = this.el.querySelector('.aionda-toolbar-overflow-menu .py-1'); if (!mainContainer || !overflowMenu) return; Array.from(mainContainer.children).forEach(item => { item.style.display = '';}); overflowMenu.innerHTML = '';} createOverflowMenuItem(originalItem, index) { const menuItem = document.createElement('div'); menuItem.className = 'aionda-toolbar-overflow-item px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer'; menuItem.setAttribute('data-original-index', index); const button = originalItem.querySelector('button'); if (button) { const text = button.querySelector('.aionda-button-text'); const icon = button.querySelector('.aionda-button-icon'); if (icon) menuItem.appendChild(icon.cloneNode(true)); if (text) menuItem.appendChild(text.cloneNode(true)); menuItem.addEventListener('click', () => { button.click(); this.hideOverflowMenu();});} return menuItem;} toggleOverflowMenu() { const menu = this.el.querySelector('.aionda-toolbar-overflow-menu'); if (menu) { menu.classList.toggle('hidden');} } hideOverflowMenu() { const menu = this.el.querySelector('.aionda-toolbar-overflow-menu'); if (menu) { menu.classList.add('hidden');} } onClick(event) { const button = event.target.closest('.aionda-toolbar-button'); if (!button) return; const item = button.closest('.aionda-toolbar-item'); if (!item) return; const index = parseInt(item.getAttribute('data-index')); const type = item.getAttribute('data-type'); const originalConfig = this.items[index]; if (button.disabled) { event.preventDefault(); return;} this.emit('buttonclick', { button: button, item: originalConfig, index: index, type: type, event: event }); if (originalConfig && originalConfig.handler) { originalConfig.handler(originalConfig, event);} } add(item) { this.items.push(item); if (this.el) { if (item && typeof item.render === 'function') { const itemEl = item.render(); this.el.appendChild(itemEl);} else if (item && item.nodeType) { this.el.appendChild(item);} } this.emit('itemAdd', { item }); return this;} addSeparator() { const separator = document.createElement('div'); const separatorClasses = [ 'aionda-toolbar-separator', this.orientation === 'vertical' ? 'border-t border-gray-300 w-6' : 'border-l border-gray-300 h-6' ]; separator.className = separatorClasses.join(' '); this.add(separator); return separator;} addSpacer() { const spacer = document.createElement('div'); spacer.className = 'aionda-toolbar-spacer flex-grow'; this.add(spacer); return spacer;} remove(item) { const index = this.items.indexOf(item); if (index >= 0) { this.items.splice(index, 1); if (this.el && item) { if (item.el && item.el.parentNode) { item.el.parentNode.removeChild(item.el);} else if (item.nodeType && item.parentNode) { item.parentNode.removeChild(item);} } this.emit('itemRemove', { item });} return this;} removeAll() { if (this.el) { this.el.innerHTML = '';} this.items = []; this.emit('clear'); return this;} getItems() { return [...this.items];} addItem(item, index) { return this.add(item);} removeItem(index) { if (index >= 0 && index < this.items.length) { const item = this.items[index]; return this.remove(item);} return this;} removeAllItems() { return this.removeAll();} setLayout(layout) { this.layout = layout; if (this.rendered) { this.refresh();} return this;} refresh() { if (!this.rendered) return; const mainContainer = this.el.querySelector('.aionda-toolbar-main'); if (mainContainer) { mainContainer.innerHTML = this.renderItems(); this.setupOverflowHandling();} } destroy() { this.items.forEach(item => { if (item && typeof item.destroy === 'function') { item.destroy();} }); this.items = []; if (this.resizeObserver) { this.resizeObserver.disconnect(); this.resizeObserver = null;} super.destroy();} } let windowZIndex = 1000; let activeWindows = []; class Window extends Panel { constructor(config = {}) { const panelConfig = { ...config, title: config.title === null ? '' : (config.title || ''), header: config.header !== false, padding: config.padding !== false, border: config.border !== false, shadow: config.shadow !== false }; super(panelConfig); config = config || {}; this.modal = config.modal === true; this.draggable = config.draggable !== false; this.resizable = config.resizable !== false; this.closable = config.closable !== false; this.minimizable = config.minimizable === true; this.maximizable = config.maximizable === true; this.width = Math.max(config.width || 400, 50); this.height = Math.max(config.height || 300, 50); this.x = Math.max(config.x !== undefined ? config.x : 50, 0); this.y = Math.max(config.y !== undefined ? config.y : 50, 0); this.minWidth = Math.max(config.minWidth || 200, 50); this.minHeight = Math.max(config.minHeight || 150, 50); this.maxWidth = config.maxWidth; this.maxHeight = config.maxHeight; this.centered = config.centered === true; this.autoShow = config.autoShow !== false; this.cls = config.cls; this.html = config.html; this.minimized = false; this.maximized = false; this.visible = this.autoShow; this.previousGeometry = null; this.isDragging = false; this.isResizing = false; this.dragData = null; this.resizeData = null; this.backdropEl = null; this.toolsEl = null; this.zIndex = ++windowZIndex;} createTemplate() { const headerTemplate = this.createHeaderTemplate(); const bodyTemplate = this.createBodyTemplate(); const resizeHandles = this.resizable ? this.createResizeHandlesTemplate() : ''; return ` <div class="aionda-window flex flex-col relative ${this.cls || ''}" style="${this.getWindowStyle()}"> ${headerTemplate} ${bodyTemplate} ${resizeHandles} </div> `;} getDefaultConfig() { return { ...super.getDefaultConfig(), modal: false, draggable: true, resizable: true, closable: true, minimizable: false, maximizable: false, width: 400, height: 300, centered: false, autoShow: true };} getPanelClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-window', 'flex', 'flex-col' ]; if (this.cls) { classes.push(this.cls);} if (!this.visible) { classes.push('hidden');} if (this.border) classes.push('border', 'border-gray-200', 'dark:border-gray-600'); if (this.shadow) classes.push('shadow-lg'); return classes;} createBackdrop() { if (!this.modal || this.backdropEl) return; this.backdropEl = document.createElement('div'); this.backdropEl.className = 'aionda-backdrop fixed inset-0 bg-black bg-opacity-50 z-40'; this.backdropEl.style.display = this.visible ? 'block' : 'none'; if (this.closable) { this.backdropEl.addEventListener('click', () => this.close());} document.body.appendChild(this.backdropEl);} createHeaderTemplate() { if (!this.header) return ''; const closeBtn = this.closable ? ` <button class="aionda-window-close p-1 hover:bg-gray-200 rounded transition-colors" type="button" aria-label="Close"> <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path> </svg> </button> ` : ''; const maximizeBtn = this.maximizable ? ` <button class="aionda-window-maximize p-1 hover:bg-gray-200 rounded transition-colors" type="button" aria-label="Maximize"> <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4h16v4M4 16v4h16v-4"></path> </svg> </button> ` : ''; const minimizeBtn = this.minimizable ? ` <button class="aionda-window-minimize p-1 hover:bg-gray-200 rounded transition-colors" type="button" aria-label="Minimize"> <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"></path> </svg> </button> ` : ''; return ` <div class="aionda-panel-header aionda-window-header flex items-center justify-between px-4 border-b border-gray-200 dark:border-gray-600 bg-gray-50 dark:bg-gray-700" style="height: ${this.headerHeight}px; min-height: ${this.headerHeight}px; ${this.draggable && !this.isTouchDevice() ? 'cursor: move;' : ''}"> <div class="flex items-center gap-2"> <h3 class="aionda-panel-title aionda-window-title font-medium text-gray-900 dark:text-gray-100">${this.title}</h3> </div> <div class="aionda-panel-tools aionda-window-tools flex items-center gap-1"> ${minimizeBtn} ${maximizeBtn} ${closeBtn} </div> </div> `;} createBodyTemplate() { const bodyClasses = [ 'aionda-panel-body', 'aionda-window-body', 'transition-all duration-200', 'flex-1', 'overflow-auto', this.padding ? 'p-4' : '', this.collapsed ? 'hidden' : 'block', 'bg-white dark:bg-gray-800' ].filter(Boolean); return ` <div class="${bodyClasses.join(' ')}" style="${this.getBodyStyleString()}"> <!-- Content will be inserted here --> </div> `;} createResizeHandlesTemplate() { return `<div class="aionda-window-resizer absolute bottom-0 right-0 w-3 h-3 cursor-se-resize"></div>`;} getWindowStyle() { const styles = ['position: fixed']; if (this.minimized || !this.visible) { styles.push('display: none'); return styles.join('; ');} styles.push('display: flex'); const globalWindow = typeof window !== 'undefined' ? window : (typeof global !== 'undefined' && global.window ? global.window : null); const screenWidth = globalWindow ? globalWindow.innerWidth : 1024; const screenHeight = globalWindow ? globalWindow.innerHeight : 768; const isMobile = screenWidth <= 480; if (this.maximized || isMobile) { styles.push('top: 0', 'left: 0', 'right: 0', 'bottom: 0', 'width: 100%', 'height: 100%');} else { const width = this.width || this.defaultWidth || 400; const height = this.height || this.defaultHeight || 300; styles.push(`width: ${typeof width === 'number' ? width + 'px' : width}`); styles.push(`height: ${typeof height === 'number' ? height + 'px' : height}`); if (this.centered) { const centerX = screenWidth / 2 - width / 2; const centerY = screenHeight / 2 - height / 2; styles.push(`left: ${centerX}px`, `top: ${centerY}px`);} else if (this.x !== undefined && this.y !== undefined) { styles.push(`left: ${this.x}px`, `top: ${this.y}px`);} else { styles.push('left: 10%', 'top: 10%');} } if (this.minWidth) styles.push(`min-width: ${this.minWidth}px`); if (this.minHeight) styles.push(`min-height: ${this.minHeight}px`); if (this.maxWidth) styles.push(`max-width: ${this.maxWidth}px`); if (this.maxHeight) styles.push(`max-height: ${this.maxHeight}px`); styles.push(`z-index: ${this.zIndex}`); return styles.join('; ');} isTouchDevice() { const globalWindow = typeof window !== 'undefined' ? window : (typeof global !== 'undefined' && global.window ? global.window : null); return globalWindow && ('ontouchstart' in globalWindow || navigator.maxTouchPoints > 0);} render() { if (this.destroyed) { throw new Error('Cannot render destroyed component');} if (this.rendered && this.el) { return this.el;} const template = this.createTemplate(); const wrapper = document.createElement('div'); wrapper.innerHTML = template.trim(); this.el = wrapper.firstElementChild; if (!this.el) { throw new Error('Component template must return a valid HTML element');} this.el.id = this.id; this.el.className = this.getPanelClasses().join(' '); this.updateWindowStyle(); this.setupEventListeners(); this.rendered = true; this.emit('render'); return this.el;} setupEventListeners() { super.setupEventListeners(); this.headerEl = this.el.querySelector('.aionda-window-header'); this.bodyEl = this.el.querySelector('.aionda-window-body'); this.toolsEl = this.el.querySelector('.aionda-window-tools'); if (this.modal) { this.createBackdrop();} if (this.closable) { this.el.addEventListener('click', (e) => { if (e.target.closest('.aionda-window-close')) { e.preventDefault(); e.stopPropagation(); this.close();} });} if (this.minimizable) { const minimizeBtn = this.el.querySelector('.aionda-window-minimize'); if (minimizeBtn) { minimizeBtn.addEventListener('click', () => this.toggleMinimize());} } if (this.maximizable) { const maximizeBtn = this.el.querySelector('.aionda-window-maximize'); if (maximizeBtn) { maximizeBtn.addEventListener('click', () => this.toggleMaximize());} } if (this.draggable && this.headerEl) { this.headerEl.addEventListener('mousedown', (e) => this.startDrag(e));} if (this.resizable) { const resizer = this.el.querySelector('.aionda-window-resizer'); if (resizer) { resizer.addEventListener('mousedown', (e) => this.startResize(e));} } if (this.modal && this.backdropEl) { this.backdropEl.addEventListener('click', () => { if (this.closable) { this.close();} });} this.keydownHandler = (e) => this.onKeyDown(e); document.addEventListener('keydown', this.keydownHandler); this.el.addEventListener('mousedown', () => this.focus()); this.el.addEventListener('touchstart', (e) => { this.emit('touchstart', e); this.focus();}); this.el.addEventListener('touchmove', (e) => this.emit('touchmove', e)); this.el.addEventListener('touchend', (e) => this.emit('touchend', e)); if (this.bodyEl && this.html) { this.bodyEl.innerHTML = this.html;} if (this.bodyEl && this.items.length > 0) { this.items.forEach(item => { if (item.render && typeof item.render === 'function') { const el = item.render(); this.bodyEl.appendChild(el);} else if (item instanceof HTMLElement) { this.bodyEl.appendChild(item);} });} } onKeyDown(e) { if (!this.isVisible() || !this.isFocused()) return; if (e.key === 'Escape' && this.closable) { e.preventDefault(); this.close();} } startDrag(e) { if (!this.draggable || this.maximized) return; e.preventDefault(); this.isDragging = true; this.focus(); const rect = this.el.getBoundingClientRect(); const startLeft = rect.left || this.x || 0; const startTop = rect.top || this.y || 0; this.dragData = { startX: e.clientX, startY: e.clientY, startLeft: startLeft, startTop: startTop }; this.emit('dragstart'); document.addEventListener('mousemove', this.onDragMove); document.addEventListener('mouseup', this.onDragEnd); document.body.style.userSelect = 'none';} onDragMove = (e) => { if (!this.isDragging || !this.dragData) return; const deltaX = e.clientX - this.dragData.startX; const deltaY = e.clientY - this.dragData.startY; let newLeft = this.dragData.startLeft + deltaX; let newTop = this.dragData.startTop + deltaY; if (this.constrainToViewport) { const windowRect = this.el.getBoundingClientRect(); newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - windowRect.width)); newTop = Math.max(0, Math.min(newTop, window.innerHeight - windowRect.height));} this.x = newLeft; this.y = newTop; this.el.style.left = `${newLeft}px`; this.el.style.top = `${newTop}px`; this.emit('drag');} onDragEnd = () => { this.isDragging = false; this.dragData = null; document.removeEventListener('mousemove', this.onDragMove); document.removeEventListener('mouseup', this.onDragEnd); document.body.style.userSelect = ''; this.emit('dragend');} startResize(e) { if (!this.resizable || this.maximized) return; e.preventDefault(); e.stopPropagation(); this.isResizing = true; this.focus(); const rect = this.el.getBoundingClientRect(); const handle = e.target; const startWidth = rect.width || this.width || 400; const startHeight = rect.height || this.height || 300; const startLeft = rect.left || this.x || 0; const startTop = rect.top || this.y || 0; this.resizeData = { startX: e.clientX, startY: e.clientY, startWidth: startWidth, startHeight: startHeight, startLeft: startLeft, startTop: startTop, direction: this.getResizeDirection(handle) }; this.emit('resizestart'); document.addEventListener('mousemove', this.onResizeMove); document.addEventListener('mouseup', this.onResizeEnd); document.body.style.userSelect = 'none';} getResizeDirection(handle) { return 'se';} onResizeMove = (e) => { if (!this.isResizing || !this.resizeData) return; const deltaX = e.clientX - this.resizeData.startX; const deltaY = e.clientY - this.resizeData.startY; const { direction } = this.resizeData; let newWidth = this.resizeData.startWidth; let newHeight = this.resizeData.startHeight; let newLeft = this.resizeData.startLeft; let newTop = this.resizeData.startTop; if (direction.includes('e')) newWidth += deltaX; if (direction.includes('w')) { newWidth -= deltaX; newLeft += deltaX;} if (direction.includes('s')) newHeight += deltaY; if (direction.includes('n')) { newHeight -= deltaY; newTop += deltaY;} newWidth = Math.max(this.minWidth, newWidth); newHeight = Math.max(this.minHeight, newHeight); if (this.maxWidth) newWidth = Math.min(this.maxWidth, newWidth); if (this.maxHeight) newHeight = Math.min(this.maxHeight, newHeight); if (direction.includes('w') && newWidth === this.minWidth) { newLeft = this.resizeData.startLeft + (this.resizeData.startWidth - this.minWidth);} if (direction.includes('n') && newHeight === this.minHeight) { newTop = this.resizeData.startTop + (this.resizeData.startHeight - this.minHeight);} this.width = newWidth; this.height = newHeight; this.x = newLeft; this.y = newTop; this.el.style.width = `${newWidth}px`; this.el.style.height = `${newHeight}px`; this.el.style.left = `${newLeft}px`; this.el.style.top = `${newTop}px`; this.emit('resize');} onResizeEnd = () => { this.isResizing = false; this.resizeData = null; document.removeEventListener('mousemove', this.onResizeMove); document.removeEventListener('mouseup', this.onResizeEnd); document.body.style.userSelect = ''; this.emit('resizeend');} show() { if (this.visible) return this; activeWindows.push(this); this.visible = true; if (this.el) { this.el.classList.remove('hidden'); this.updateWindowStyle();} if (this.backdropEl) { this.backdropEl.style.display = 'block';} if (this.focusOnShow) { setTimeout(() => this.focus(), 0);} this.emit('show'); return this;} hide() { if (!this.visible) return this; const index = activeWindows.indexOf(this); if (index > -1) { activeWindows.splice(index, 1);} this.visible = false; if (this.el) { this.el.classList.add('hidden'); this.el.style.display = 'none';} if (this.backdropEl) { this.backdropEl.style.display = 'none';} this.emit('hide'); return this;} close() { const closeEvent = { cancelled: false }; const hasCloseListeners = this.listeners.has('close') && this.listeners.get('close').size > 0; if (hasCloseListeners) { const eventListeners = this.listeners.get('close'); eventListeners.forEach(listener => { try { const result = listener(closeEvent); if (result === false) { closeEvent.cancelled = true;} } catch (error) { console.error('Error in close event listener:', error);} }); if (closeEvent.cancelled) return this;} this.destroy(); return this;} minimize() { if (this.minimized) return this; this.minimized = true; if (this.el) { this.el.classList.add('aionda-window-minimized');} this.emit('minimize'); return this;} restore() { if (!this.minimized && !this.maximized) return this; if (this.minimized) { this.minimized = false; if (this.el) { this.el.classList.remove('aionda-window-minimized');} } if (this.maximized) { this.maximized = false; if (this.el) { this.el.classList.remove('aionda-window-maximized');} if (this.previousGeometry) { this.width = this.previousGeometry.width; this.height = this.previousGeometry.height; this.x = this.previousGeometry.x; this.y = this.previousGeometry.y; this.updateWindowStyle(); this.previousGeometry = null;} } this.emit('restore'); return this;} maximize() { if (this.maximized) return this; this.previousGeometry = { width: this.width, height: this.height, x: this.x, y: this.y }; this.maximized = true; if (this.el) { this.el.classList.add('aionda-window-maximized');} this.updateWindowStyle(); this.emit('maximize'); return this;} toggleMaximize() { return this.maximized ? this.restore() : this.maximize();} toggleMinimize() { return this.minimized ? this.restore() : this.minimize();} blur() { this.emit('blur'); return this;} updateWindowStyle() { if (this.el) { const style = this.getWindowStyle(); this.el.style.cssText = style; this.el.style.setProperty('position', 'fixed', 'important'); this.el.style.setProperty('display', 'flex', 'important'); this.el.style.setProperty('flex-direction', 'column', 'important'); this.el.style.setProperty('box-sizing', 'border-box', 'important');} } focus() { if (!this.visible) return this; this.zIndex = ++windowZIndex; if (this.el) { this.el.style.zIndex = this.zIndex;} const index = activeWindows.indexOf(this); if (index > -1) { activeWindows.splice(index, 1);} activeWindows.push(this); if (this.focusOnShow) { const focusable = this.el.querySelector('input, button, textarea, select, [tabindex]:not([tabindex="-1"])'); if (focusable) { focusable.focus();} } this.emit('focus'); return this;} isFocused() { return activeWindows[activeWindows.length - 1] === this;} isVisible() { return this.visible;} setTitle(title) { this.title = title; const titleEl = this.el.querySelector('.aionda-window-title'); if (titleEl) { titleEl.textContent = title;} this.emit('titlechange', { title }); return this;} getTitle() { return this.title;} center() { if (this.maximized) return this; const width = this.width || this.defaultWidth; const height = this.height || this.defaultHeight; this.x = Math.max(0, (window.innerWidth - width) / 2); this.y = Math.max(0, (window.innerHeight - height) / 2); this.updateWindowStyle(); return this;} setPosition(x, y) { this.x = x; this.y = y; this.updateWindowStyle(); return this;} setSize(width, height) { this.width = width; this.height = height; this.updateWindowStyle(); return this;} add(component) { this.items.push(component); if (this.bodyEl) { if (component.render && typeof component.render === 'function') { const el = component.render(); this.bodyEl.appendChild(el);} else if (component instanceof HTMLElement) { this.bodyEl.appendChild(component);} } return this;} remove(component) { const index = this.items.indexOf(component); if (index !== -1) { this.items.splice(index, 1); if (this.bodyEl) { if (component.el && component.el.parentNode === this.bodyEl) { this.bodyEl.removeChild(component.el);} else if (component instanceof HTMLElement && component.parentNode === this.bodyEl) { this.bodyEl.removeChild(component);} } } return this;} removeAll() { if (this.bodyEl) { this.items.forEach(component => { if (component.el && component.el.parentNode === this.bodyEl) { this.bodyEl.removeChild(component.el);} else if (component instanceof HTMLElement && component.parentNode === this.bodyEl) { this.bodyEl.removeChild(component);} });} this.items = []; return this;} getItems() { return [...this.items];} destroy() { const index = activeWindows.indexOf(this); if (index > -1) { activeWindows.splice(index, 1);} if (this.backdropEl && this.backdropEl.parentNode) { this.backdropEl.parentNode.removeChild(this.backdropEl); this.backdropEl = null;} this.items.forEach(item => { if (item.destroy && typeof item.destroy === 'function') { item.destroy();} }); this.items = []; document.removeEventListener('keydown', this.keydownHandler); document.removeEventListener('mousemove', this.onDragMove); document.removeEventListener('mouseup', this.onDragEnd); document.removeEventListener('mousemove', this.onResizeMove); document.removeEventListener('mouseup', this.onResizeEnd); super.destroy();} } class MessageBox extends Component { constructor(config = {}) { super(config); config = config || {}; this.title = config.title || ''; this.message = config.message || ''; this.icon = config.icon || ''; this.iconType = config.iconType || 'info'; this.buttons = config.buttons || []; this.defaultButton = config.defaultButton || 0; this.allowEscape = config.allowEscape !== false; this.modal = config.modal !== false; this.value = config.value || ''; this.inputType = config.inputType || 'text'; this.showInput = config.showInput || false; this.overlay = null; this.dialogEl = null; this.inputEl = null; this.resolvePromise = null; this.rejectPromise = null; this.mutationObserver = null;} static alert(message, title = 'Alert', options = {}) { return new Promise((resolve, reject) => { const messageBox = new MessageBox({ title, message, iconType: options.iconType || 'info', icon: options.icon || MessageBox.getDefaultIcon('info'), buttons: [{ text: options.buttonText || 'OK', variant: 'primary', handler: () => { messageBox.rejectPromise = null; resolve(); messageBox.close();} }], ...options }); messageBox.resolvePromise = resolve; messageBox.rejectPromise = reject; messageBox.show();});} static confirm(message, title = 'Confirm', options = {}) { return new Promise((resolve, reject) => { const messageBox = new MessageBox({ title, message, iconType: options.iconType || 'question', icon: options.icon || MessageBox.getDefaultIcon('question'), buttons: [ { text: options.cancelText || 'Cancel', variant: 'secondary', handler: () => { messageBox.rejectPromise = null; resolve(false); messageBox.close();} }, { text: options.confirmText || 'OK', variant: 'primary', handler: () => { messageBox.rejectPromise = null; resolve(true); messageBox.close();} } ], defaultButton: 1, ...options }); messageBox.resolvePromise = resolve; messageBox.rejectPromise = reject; messageBox.show();});} static prompt(message, title = 'Input', defaultValue = '', options = {}) { return new Promise((resolve, reject) => { const messageBox = new MessageBox({ title, message, iconType: options.iconType || 'question', icon: options.icon || MessageBox.getDefaultIcon('question'), showInput: true, value: defaultValue, inputType: options.inputType || 'text', buttons: [ { text: options.cancelText || 'Cancel', variant: 'secondary', handler: () => { messageBox.rejectPromise = null; resolve(null); messageBox.close();} }, { text: options.confirmText || 'OK', variant: 'primary', handler: () => { const value = messageBox.getValue(); messageBox.rejectPromise = null; resolve(value); messageBox.close();} } ], defaultButton: 1, ...options }); messageBox.resolvePromise = resolve; messageBox.rejectPromise = reject; messageBox.show();});} static getDefaultIcon(type) { const icons = { info: `<svg class="w-6 h-6 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path> </svg>`, warning: `<svg class="w-6 h-6 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z"></path> </svg>`, error: `<svg class="w-6 h-6 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path> </svg>`, success: `<svg class="w-6 h-6 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path> </svg>`, question: `<svg class="w-6 h-6 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path> </svg>` }; return icons[type] || icons.info;} createTemplate() { const iconHtml = this.icon ? `<div class="aionda-messagebox-icon mr-4 flex-shrink-0">${this.icon}</div>` : ''; const inputHtml = this.showInput ? this.createInputTemplate() : ''; return ` <div class="aionda-messagebox-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"> <div class="aionda-messagebox-dialog bg-white rounded-lg shadow-xl max-w-md w-full mx-4 transform transition-all"> <div class="aionda-messagebox-header px-6 py-4 border-b border-gray-200"> <h3 class="aionda-messagebox-title text-lg font-medium text-gray-900">${this.title}</h3> </div> <div class="aionda-messagebox-body px-6 py-4"> <div class="flex items-start"> ${iconHtml} <div class="flex-1"> <div class="aionda-messagebox-message text-sm text-gray-500 mb-4">${this.message}</div> ${inputHtml} </div> </div> </div> <div class="aionda-messagebox-footer px-6 py-4 border-t border-gray-200 flex justify-end gap-3"> <!-- Buttons will be inserted here --> </div> </div> </div> `;} createInputTemplate() { return ` <input type="${this.inputType}" class="aionda-messagebox-input w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" value="${this.value}" placeholder="Enter value..."> `;} render() { if (this.destroyed) { throw new Error('Cannot render destroyed component');} if (this.rendered && this.el) { return this.el;} const template = this.createTemplate(); const wrapper = document.createElement('div'); wrapper.innerHTML = template.trim(); this.el = wrapper.firstElementChild; if (!this.el) { throw new Error('Component template must return a valid HTML element');} this.el.id = this.id; this.setupEventListeners(); this.renderButtons(); this.rendered = true; this.emit('render'); return this.el;} setupEventListeners() { super.setupEventListeners(); this.overlay = this.el; this.dialogEl = this.el.querySelector('.aionda-messagebox-dialog'); this.inputEl = this.el.querySelector('.aionda-messagebox-input'); if (this.allowEscape) { document.addEventListener('keydown', this.onKeyDown.bind(this));} if (this.modal) { this.overlay.addEventListener('click', (event) => { if (event.target === this.overlay) { this.onCancel();} });} if (this.inputEl) { this.inputEl.addEventListener('keydown', (event) => { if (event.key === 'Enter') { event.preventDefault(); this.onEnter();} });} } renderButtons() { const footer = this.el.querySelector('.aionda-messagebox-footer'); if (!footer) return; this.buttons.forEach((buttonConfig, index) => { const button = new Button({ text: buttonConfig.text, variant: buttonConfig.variant || 'secondary', size: buttonConfig.size || 'md', handler: (btn, event) => { this.emit('buttonclick', { button: buttonConfig, buttonIndex: index, event }); if (buttonConfig.handler) { buttonConfig.handler(btn, event);} } }); const buttonEl = button.render(); footer.appendChild(buttonEl); if (index === this.defaultButton) { setTimeout(() => buttonEl.focus(), 100);} });} onKeyDown(event) { if (event.key === 'Escape') { event.preventDefault(); this.onCancel();} } onEnter() { const defaultBtn = this.buttons[this.defaultButton]; if (defaultBtn && defaultBtn.handler) { defaultBtn.handler();} } onCancel() { const cancelBtn = this.buttons.find(btn => btn.variant === 'secondary'); if (cancelBtn && cancelBtn.handler) { cancelBtn.handler();} else { this.hide();} } getValue() { return this.inputEl ? this.inputEl.value : this.value;} setValue(value) { this.value = value; if (this.inputEl) { this.inputEl.value = value;} return this;} show() { this.render(); if (!document.body.contains(this.el)) { document.body.appendChild(this.el);} this.el.style.display = 'flex'; this.mutationObserver = new MutationObserver((mutations) => { for (const mutation of mutations) { if (mutation.type === 'childList') { for (const node of mutation.removedNodes) { if (node === this.el) { this.destroy(); return;} } } } }); this.mutationObserver.observe(document.body, { childList: true, subtree: true }); requestAnimationFrame(() => { this.dialogEl.classList.add('animate-in'); if (this.showInput && this.inputEl) { setTimeout(() => { this.inputEl.focus();}, 100);} }); this.emit('show'); return this;} hide() { if (this.el) { this.el.style.display = 'none';} this.emit('hide'); return this;} close() { if (this.allowEscape) { document.removeEventListener('keydown', this.onKeyDown.bind(this));} if (this.el && this.el.parentNode) { this.el.parentNode.removeChild(this.el);} this.emit('close'); this.destroy(); return this;} destroy() { if (this.destroyed) return; if (this.allowEscape) { document.removeEventListener('keydown', this.onKeyDown.bind(this));} if (this.mutationObserver) { this.mutationObserver.disconnect(); this.mutationObserver = null;} if (this.rejectPromise) { this.rejectPromise(new Error('MessageBox was destroyed')); this.rejectPromise = null;} super.destroy();} } class Toast extends Component { constructor(config = {}) { super(config); config = config || {}; this.message = config.message || ''; this.title = config.title || ''; this.type = config.type || 'info'; this.position = config.position || 'top-right'; this.duration = config.duration !== undefined ? config.duration : 5000; this.closable = config.closable !== undefined ? config.closable : true; this.animate = config.animate !== undefined ? config.animate : true; this.persistent = config.persistent !== undefined ? config.persistent : false; this.icon = config.icon || this.getDefaultIcon(); this.isVisible = false; this.timeoutId = null; this.progressEl = null; this.closeButtonEl = null; this.startTime = null; this.remainingTime = this.duration; this.isPaused = false; if (!Toast.instances) { Toast.instances = [];} } static show(message, options = {}) { const toast = new Toast({ message, ...options }); return toast.show();} static info(message, options = {}) { return Toast.show(message, { ...options, type: 'info' });} static success(message, options = {}) { return Toast.show(message, { ...options, type: 'success' });} static warning(message, options = {}) { return Toast.show(message, { ...options, type: 'warning' });} static error(message, options = {}) { return Toast.show(message, { ...options, type: 'error' });} getDefaultIcon() { const icons = { success: '✓', error: '✕', warning: '⚠', info: 'ℹ' }; return icons[this.type] || icons.info;} static getDefaultIcon(type) { const icons = { info: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path> </svg>`, success: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path> </svg>`, warning: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z"></path> </svg>`, error: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path> </svg>` }; return icons[type] || icons.info;} createTemplate() { const titleHtml = this.title ? `<p class="font-medium text-sm text-gray-900">${this.title}</p>` : ''; const messageHtml = this.message ? `<p class="text-sm text-gray-700">${this.message}</p>` : ''; const closeButtonHtml = this.closable ? this.getCloseButtonHtml() : ''; const progressBarHtml = this.duration > 0 && !this.persistent ? this.getProgressBarHtml() : ''; return ` <div class="pointer-events-auto w-full bg-white shadow-lg rounded-lg overflow-hidden ${this.getTypeClasses().join(' ')}"> <div class="p-4"> <div class="flex items-start"> <div class="flex-shrink-0"> <span class="${this.getIconClasses()}">${this.icon}</span> </div> <div class="ml-3 w-0 flex-1 pt-0.5"> ${titleHtml} ${messageHtml} </div> ${closeButtonHtml} </div> </div> ${progressBarHtml} </div> `;} getToastClasses() { const classes = [ 'bg-white', 'shadow-lg', 'rounded-lg', 'pointer-events-auto', 'ring-1', 'ring-black', 'ring-opacity-5', 'overflow-hidden' ]; const typeClasses = this.getTypeClasses(); classes.push(...typeClasses); if (this.animate) { classes.push('transform', 'transition-all', 'duration-300');} return classes;} getTypeClasses() { switch (this.type) { case 'success': return ['bg-green-50', 'border-green-200']; case 'warning': return ['bg-yellow-50', 'border-yellow-200']; case 'error': return ['bg-red-50', 'border-red-200']; case 'info': default: return ['bg-blue-50', 'border-blue-200'];} } getIconClasses() { switch (this.type) { case 'success': return 'text-green-400'; case 'warning': return 'text-yellow-400'; case 'error': return 'text-red-400'; case 'info': default: return 'text-blue-400';} } getIconHtml() { const icon = this.icon; const colorClass = this.getIconColorClass(); return `<div class="aionda-toast-icon flex-shrink-0 ${colorClass}">${icon}</div>`;} getIconColorClass() { switch (this.type) { case 'success': return 'text-green-500'; case 'warning': return 'text-yellow-500'; case 'error': return 'text-red-500'; case 'info': default: return 'text-blue-500';} } getCloseButtonHtml() { return ` <div class="ml-4 flex-shrink-0 flex"> <button class="aionda-toast-close bg-white rounded-md inline-flex text-gray-400 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"> <span class="sr-only">${this.t('common.close')}</span> <svg class="h-5 w-5" xmlns="http: <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /> </svg> </button> </div> `;} getProgressBarHtml() { const colorClass = this.getProgressColorClass(); return ` <div class="toast-progress bg-gray-200 h-1"> <div class="toast-progress-bar ${colorClass} h-full transition-all duration-100 ease-linear" style="width: 100%"></div> </div> `;} getProgressColorClass() { switch (this.type) { case 'success': return 'bg-green-500'; case 'warning': return 'bg-yellow-500'; case 'error': return 'bg-red-500'; case 'info': default: return 'bg-blue-500';} } render() { if (this.destroyed) { throw new Error('Cannot render destroyed component');} if (this.rendered && this.el) { return this.el;} const template = this.createTemplate(); const wrapper = document.createElement('div'); wrapper.innerHTML = template.trim(); this.el = wrapper.firstElementChild; if (!this.el) { throw new Error('Component template must return a valid HTML element');} this.el.id = this.id; this.setupEventListeners(); this.rendered = true; this.emit('render'); return this.el;} setupEventListeners() { super.setupEventListeners(); this.progressEl = this.el.querySelector('.toast-progress-bar'); this.closeButtonEl = this.el.querySelector('.aionda-toast-close'); if (this.closeButtonEl) { this.closeButtonEl.addEventListener('click', () => this.hide());} this.el.addEventListener('mouseenter', () => this.pauseTimer()); this.el.addEventListener('mouseleave', () => this.resumeTimer()); this.el.addEventListener('click', (event) => { this.emit('click', { toast: this, event });});} show() { if (this.isVisible) return this; this.render(); const container = Toast.getContainer(this.position); container.appendChild(this.el); this.isVisible = true; Toast.instances.push(this); if (this.animate && this.el) { requestAnimationFrame(() => { if (this.el && !this.destroyed) { this.el.classList.add('toast-enter');} });} else { this.el.classList.add('opacity-100', 'translate-x-0');} if (this.duration > 0 && !this.persistent) { this.startTimer();} this.emit('show'); return this;} hide() { if (!this.isVisible) return this; this.isVisible = false; this.clearTimer(); if (this.animate) { this.el.classList.add('toast-exit'); setTimeout(() => { this.remove();}, 300);} else { this.remove();} this.emit('hide'); return this;} close() { return this.hide();} remove() { if (this.el && this.el.parentNode) { this.el.parentNode.removeChild(this.el);} const index = Toast.instances.indexOf(this); if (index > -1) { Toast.instances.splice(index, 1);} this.destroy();} startTimer() { if (this.duration <= 0) return; this.startTime = Date.now(); this.remainingTime = this.duration; this.isPaused = false; this.timeoutId = setTimeout(() => { this.hide();}, this.duration); if (this.progressEl) { this.animateProgress();} } pauseTimer() { if (!this.timeoutId || this.isPaused) return; this.clearTimer(); this.remainingTime = this.duration - (Date.now() - this.startTime); this.isPaused = true; this.emit('mouseenter'); if (this.progressEl) { this.progressEl.style.animationPlayState = 'paused';} } resumeTimer() { if (!this.isPaused) return; this.startTime = Date.now(); this.isPaused = false; this.emit('mouseleave'); this.timeoutId = setTimeout(() => { this.hide();}, this.remainingTime); if (this.progressEl) { this.progressEl.style.animationPlayState = 'running'; this.animateProgress();} } clearTimer() { if (this.timeoutId) { clearTimeout(this.timeoutId); this.timeoutId = null;} } animateProgress() { if (!this.progressEl) return; const duration = this.isPaused ? this.remainingTime : this.duration; this.progressEl.style.transition = `width ${duration}ms linear`; this.progressEl.style.width = '0%';} static getContainer(position) { const containerId = `toast-container-${position}`; let container = document.getElementById(containerId); if (!container) { container = document.createElement('div'); container.id = containerId; container.className = `aionda-toast-container fixed ${Toast.getPositionClasses(position)} z-50 p-4 space-y-4 pointer-events-none w-[500px]`; document.body.appendChild(container);} return container;} static getPositionClasses(position) { const positions = { 'top-left': 'top-4 left-4', 'top-center': 'top-4 left-1/2 transform -translate-x-1/2', 'top-right': 'top-4 right-4', 'bottom-left': 'bottom-4 left-4', 'bottom-center': 'bottom-4 left-1/2 transform -translate-x-1/2', 'bottom-right': 'bottom-4 right-4' }; return positions[position] || positions['top-right'];} static clear() { if (Toast.instances) { Toast.instances.forEach(toast => { if (toast && !toast.destroyed) { toast.hide();} }); Toast.instances = [];} const containers = document.querySelectorAll('[id^="toast-container-"]'); containers.forEach(container => { container.innerHTML = '';});} getDuration() { return this.duration;} getPosition() { return this.position;} getType() { return this.type;} isTimerActive() { return !!this.timeoutId && !this.isPaused;} setMessage(message) { this.message = message; if (this.rendered && this.el) { const messageEl = this.el.querySelector('p:last-child'); if (messageEl) { messageEl.textContent = message;} } } setTitle(title) { this.title = title; if (this.rendered && this.el) { const titleEl = this.el.querySelector('p.font-medium'); if (titleEl) { titleEl.textContent = title;} } } destroy() { if (this.destroyed) return; this.clearTimer(); const index = Toast.instances.indexOf(this); if (index > -1) { Toast.instances.splice(index, 1);} super.destroy();} } class DateField extends TextField { constructor(config = {}) { config = config || {}; const format = config.format || 'MM/dd/yyyy'; const displayFormat = config.displayFormat || format; const altFormats = config.altFormats || ['M/d/yyyy', 'MM-dd-yyyy', 'yyyy-MM-dd', 'dd/MM/yyyy']; const locale = config.locale || 'en-US'; const editable = config.editable !== false; const disabled = config.disabled || false; let displayValue = config.value || ''; let dateValue = null; if (config.value) { if (config.value instanceof Date) { dateValue = new Date(config.value); displayValue = DateField.formatDateStatic(dateValue, displayFormat, locale);} else { dateValue = DateField.parseInputStatic(config.value, format, altFormats); if (dateValue) { displayValue = DateField.formatDateStatic(dateValue, displayFormat, locale);} } } super({ ...config, inputType: 'text', value: displayValue, disabled: disabled }); this.format = format; this.displayFormat = displayFormat; this.altFormats = altFormats; this.disabledDays = config.disabledDays || []; this.startOfWeek = config.startOfWeek || 0; this.showToday = config.showToday !== false; this.todayText = config.todayText || 'Today'; this.locale = locale; this.triggerAction = config.triggerAction || 'click'; this.editable = editable; this.submitValue = config.submitValue || this.format; this.disabled = disabled; this.monthNames = config.monthNames || this.getMonthNames(); this.dayNames = config.dayNames || this.getDayNames(); this.dayNamesShort = config.dayNamesShort || this.getDayNamesShort(); this.dateValue = dateValue; this.picker = null; this.pickerVisible = false; this.currentViewDate = new Date(); this.originalInputType = this.inputType; this.readOnly = !this.editable; this.originalValue = config.value; if (config.value) { this._originalInputValue = config.value; if (typeof config.value === 'string') { this._originalInputFormat = this.detectInputFormat(config.value) || this.format;} else { this._originalInputFormat = this.format;} } this.minDate = config.minDate ? this.parseDate(config.minDate) : null; this.maxDate = config.maxDate ? this.parseDate(config.maxDate) : null; this.parentForm = config.parentForm; if (this.parentForm && typeof this.parentForm.registerField === 'function') { this.parentForm.registerField(this);} } createTemplate() { const labelTemplate = this.createLabelTemplate(); const inputTemplate = this.createInputTemplate(); const triggerTemplate = this.createTriggerTemplate(); const errorTemplate = this.createErrorTemplate(); return ` <div class="${this.getFieldClasses().join(' ')}"> ${labelTemplate} <div class="aionda-datefield-input-wrap relative"> <div class="relative flex"> ${inputTemplate} ${triggerTemplate} </div> ${errorTemplate} ${this.createPickerTemplate()} </div> </div> `;} createTriggerTemplate() { return ` <button type="button" class="aionda-datefield-trigger datefield-picker-button absolute right-2 top-1/2 transform -translate-y-1/2 p-1 text-gray-400 hover:text-gray-600 focus:outline-none focus:text-blue-500 transition-colors"> <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/> </svg> </button> `;} createPickerTemplate() { return ` <div class="aionda-datefield-picker datefield-picker absolute top-full left-0 mt-1 bg-white border border-gray-300 rounded-lg shadow-lg z-50 hidden" style="min-width: 280px;"> <div class="aionda-datefield-header flex items-center justify-between p-3 border-b border-gray-200"> <button type="button" class="aionda-datefield-prev-month picker-prev-month p-1 hover:bg-gray-100 rounded"> <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/> </svg> </button> <div class="flex items-center space-x-2"> <select class="aionda-datefield-month-select text-sm border-0 bg-transparent font-medium focus:outline-none focus:ring-1 focus:ring-blue-500 rounded"> ${this.monthNames.map((month, index) => `<option value="${index}">${month}</option>` ).join('')} </select> <select class="aionda-datefield-year-select text-sm border-0 bg-transparent font-medium focus:outline-none focus:ring-1 focus:ring-blue-500 rounded"> ${this.generateYearOptions()} </select> </div> <button type="button" class="aionda-datefield-next-month picker-next-month p-1 hover:bg-gray-100 rounded"> <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/> </svg> </button> </div> <div class="aionda-datefield-calendar p-3"> <div class="aionda-datefield-day-headers grid grid-cols-7 gap-1 mb-2"> ${this.dayNamesShort.map(day => `<div class="text-xs font-medium text-gray-500 text-center p-1">${day}</div>` ).join('')} </div> <div class="aionda-datefield-days grid grid-cols-7 gap-1"> <!-- Days will be populated by JavaScript --> </div> </div> ${this.showToday ? this.createTodayButtonTemplate() : ''} </div> `;} createTodayButtonTemplate() { return ` <div class="aionda-datefield-footer border-t border-gray-200 p-3"> <button type="button" class="aionda-datefield-today w-full px-3 py-2 text-sm text-blue-600 hover:bg-blue-50 rounded border border-blue-200 hover:border-blue-300 transition-colors"> ${this.todayText} </button> </div> `;} getBaseClasses() { return [ ...super.getBaseClasses(), 'aionda-datefield' ];} setupEventListeners() { super.setupEventListeners(); this.triggerEl = this.el.querySelector('.datefield-picker-button'); this.picker = this.el.querySelector('.datefield-picker'); this.monthSelect = this.el.querySelector('.aionda-datefield-month-select'); this.yearSelect = this.el.querySelector('.aionda-datefield-year-select'); this.prevMonthBtn = this.el.querySelector('.picker-prev-month'); this.nextMonthBtn = this.el.querySelector('.picker-next-month'); this.daysContainer = this.el.querySelector('.aionda-datefield-days'); this.todayBtn = this.el.querySelector('.aionda-datefield-today'); if (this.inputEl) { this.inputEl.addEventListener('focus', (event) => { this.emit('focus', { field: this, event });}); this.inputEl.addEventListener('blur', (event) => { this.emit('blur', { field: this, event });});} if (this.triggerEl) { this.triggerEl.disabled = this.disabled; this.triggerEl.addEventListener('click', (e) => { e.preventDefault(); this.togglePicker();});} if (this.inputEl && this.triggerAction === 'click') { this.inputEl.addEventListener('click', () => this.showPicker());} if (this.monthSelect) { this.monthSelect.addEventListener('change', () => this.onMonthYearChange());} if (this.yearSelect) { this.yearSelect.addEventListener('change', () => this.onMonthYearChange());} if (this.prevMonthBtn) { this.prevMonthBtn.addEventListener('click', () => this.navigateMonth(-1));} if (this.nextMonthBtn) { this.nextMonthBtn.addEventListener('click', () => this.navigateMonth(1));} if (this.todayBtn) { this.todayBtn.addEventListener('click', () => this.selectToday());} document.addEventListener('click', (e) => this.onDocumentClick(e)); if (this.editable && this.inputEl) { this.inputEl.addEventListener('keydown', (e) => this.onDateKeyDown(e));} if (this.picker) { this.picker.addEventListener('keydown', (e) => this.onDateKeyDown(e));} document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && this.pickerVisible) { e.preventDefault(); this.hidePicker();} }); this.updateCalendar();} setupPickerEvents() { if (this.monthSelect) { this.monthSelect.addEventListener('change', () => this.onMonthYearChange());} if (this.yearSelect) { this.yearSelect.addEventListener('change', () => this.onMonthYearChange());} if (this.prevMonthBtn) { this.prevMonthBtn.addEventListener('click', () => this.navigateMonth(-1));} if (this.nextMonthBtn) { this.nextMonthBtn.addEventListener('click', () => this.navigateMonth(1));} if (this.todayBtn) { this.todayBtn.addEventListener('click', () => this.selectToday());} if (this.picker) { this.picker.addEventListener('keydown', (e) => this.onDateKeyDown(e));} } onInput(event) { if (this.editable) { const value = event.target.value; const date = this.parseInput(value); if (date) { this.dateValue = date; this.currentViewDate = new Date(date); this.updateCalendar();} else { this.dateValue = null;} super.onInput(event); this.emit('input', { value, event });} } onDateKeyDown(event) { if (!this.editable) return; const { key } = event; if ((key === 'ArrowDown' || key === 'F4' || key === 'Enter' || key === ' ') && !this.pickerVisible) { event.preventDefault(); this.showPicker(); return;} if (this.pickerVisible) { if (key === 'Escape') { event.preventDefault(); this.hidePicker(true); return;} else if (key === 'Tab') { this.hidePicker(false); return;} this.handlePickerKeyNavigation(event);} } handlePickerKeyNavigation(event) { const { key } = event; switch (key) { case 'ArrowLeft': event.preventDefault(); this.navigateDateByDays(-1); break; case 'ArrowRight': event.preventDefault(); this.navigateDateByDays(1); break; case 'ArrowUp': event.preventDefault(); this.navigateDateByDays(-7); break; case 'ArrowDown': event.preventDefault(); this.navigateDateByDays(7); break; case 'Enter': event.preventDefault(); const focusedDay = document.activeElement; if (focusedDay && focusedDay.classList.contains('aionda-datefield-day')) { const dateStr = focusedDay.dataset.date; if (dateStr) { this.dateValue = new Date(dateStr + 'T00:00:00'); this._lastReturnFormat = 'iso'; const formattedValue = this.formatDate(this.dateValue, this.displayFormat); super.setValue(formattedValue, true); this.updateCalendar(); this.hidePicker(false); this.emit('select', { date: new Date(this.dateValue), value: dateStr });} } else { const firstDay = this.el.querySelector('.aionda-datefield-day[data-date]'); if (firstDay) { const dateStr = firstDay.dataset.date; this.dateValue = new Date(dateStr + 'T00:00:00'); this._lastReturnFormat = 'iso'; const formattedValue = this.formatDate(this.dateValue, this.displayFormat); super.setValue(formattedValue, true); this.updateCalendar(); this.hidePicker(false); this.emit('select', { date: new Date(this.dateValue), value: dateStr });} } break; case 'Escape': event.preventDefault(); this.hidePicker(true); break;} } navigateToDate(date) { if (this.isDateDisabled(date)) return; if (date.getMonth() !== this.currentViewDate.getMonth() || date.getFullYear() !== this.currentViewDate.getFullYear()) { this.currentViewDate = new Date(date); this.updateCalendar();} const dateStr = this.formatDateISO(date); const dayElement = this.daysContainer.querySelector(`[data-date="${dateStr}"]`); if (dayElement) { dayElement.focus();} } navigateDateByDays(days) { const currentDate = this.dateValue || new Date(); const newDate = new Date(currentDate); newDate.setDate(newDate.getDate() + days); this.navigateToDate(newDate);} onDocumentClick(event) { if (this.pickerVisible && this.el && !this.el.contains(event.target)) { this.hidePicker();} } onMonthYearChange() { const month = parseInt(this.monthSelect.value); const year = parseInt(this.yearSelect.value); this.currentViewDate = new Date(year, month, 1); this.updateCalendar();} navigateMonth(direction) { this.currentViewDate.setMonth(this.currentViewDate.getMonth() + direction); this.updateCalendar();} updateCalendar() { if (!this.picker) return; this.monthSelect.value = this.currentViewDate.getMonth(); this.yearSelect.value = this.currentViewDate.getFullYear(); this.updateNavigationButtons(); this.renderDays();} updateNavigationButtons() { if (!this.prevMonthBtn || !this.nextMonthBtn) return; const currentMonth = this.currentViewDate.getMonth(); const currentYear = this.currentViewDate.getFullYear(); let prevDisabled = false; let nextDisabled = false; if (this.minDate) { const prevMonth = new Date(currentYear, currentMonth - 1, 1); if (prevMonth < new Date(this.minDate.getFullYear(), this.minDate.getMonth(), 1)) { prevDisabled = true;} } if (this.maxDate) { const nextMonth = new Date(currentYear, currentMonth + 1, 1); if (nextMonth > new Date(this.maxDate.getFullYear(), this.maxDate.getMonth(), 1)) { nextDisabled = true;} } this.prevMonthBtn.disabled = prevDisabled; this.nextMonthBtn.disabled = nextDisabled; if (prevDisabled) { this.prevMonthBtn.classList.add('disabled', 'opacity-50', 'cursor-not-allowed');} else { this.prevMonthBtn.classList.remove('disabled', 'opacity-50', 'cursor-not-allowed');} if (nextDisabled) { this.nextMonthBtn.classList.add('disabled', 'opacity-50', 'cursor-not-allowed');} else { this.nextMonthBtn.classList.remove('disabled', 'opacity-50', 'cursor-not-allowed');} } renderDays() { if (!this.daysContainer) return; const year = this.currentViewDate.getFullYear(); const month = this.currentViewDate.getMonth(); const firstDay = new Date(year, month, 1); const lastDay = new Date(year, month + 1, 0); const startDate = new Date(firstDay); startDate.setDate(startDate.getDate() - ((firstDay.getDay() - this.startOfWeek + 7) % 7)); const days = []; const today = new Date(); today.setHours(0, 0, 0, 0); for (let i = 0; i < 42; i++) { const date = new Date(startDate); date.setDate(startDate.getDate() + i); const isCurrentMonth = date.getMonth() === month; const isToday = date.getTime() === today.getTime(); const isSelected = this.dateValue && this.isSameDay(date, this.dateValue); const isDisabled = this.isDateDisabled(date); const dayClasses = [ 'aionda-datefield-day', 'w-8', 'h-8', 'flex', 'items-center', 'justify-center', 'text-sm', 'rounded', 'cursor-pointer', 'transition-colors' ]; if (!isCurrentMonth) { dayClasses.push('text-gray-300');} else if (isDisabled) { dayClasses.push('text-gray-300', 'cursor-not-allowed');} else { dayClasses.push('text-gray-700', 'hover:bg-blue-50');} if (isToday && isCurrentMonth) { dayClasses.push('bg-blue-100', 'text-blue-600', 'font-medium');} if (isSelected) { dayClasses.push('bg-blue-500', 'text-white', 'font-medium');} days.push(` <button type="button" class="${dayClasses.join(' ')}" data-date="${this.formatDateISO(date)}" tabindex="-1" ${isDisabled ? 'disabled' : ''}> ${date.getDate()} </button> `);} this.daysContainer.innerHTML = days.join(''); this.daysContainer.querySelectorAll('.aionda-datefield-day').forEach(dayEl => { dayEl.addEventListener('click', (e) => { if (!e.target.disabled) { const dateStr = e.target.dataset.date; const date = new Date(dateStr + 'T00:00:00'); this.selectDate(date);} });});} selectDate(date) { if (this.isDateDisabled(date)) return; this.dateValue = new Date(date); this.setValue(this.formatDate(this.dateValue)); this.updateCalendar(); this.hidePicker(false); this.emit('select', { date: new Date(this.dateValue), value: this.getValue() });} selectToday() { this.selectDate(new Date());} showPicker() { if (this.pickerVisible) return; if (!this.picker) { const pickerContainer = this.el.querySelector('.aionda-datefield-input-wrap'); if (pickerContainer) { pickerContainer.insertAdjacentHTML('beforeend', this.createPickerTemplate()); this.picker = pickerContainer.querySelector('.aionda-datefield-picker'); this.setupPickerEventListeners();} } this.pickerVisible = true; if (this.picker) { this.picker.classList.remove('hidden');} if (this.dateValue) { this.currentViewDate = new Date(this.dateValue);} else { this.currentViewDate = new Date();} this.updateCalendar(); this.emit('expand');} hidePicker(remove = false) { if (!this.pickerVisible) return; this.pickerVisible = false; if (this.picker) { if (remove && this.picker.parentNode) { this.picker.parentNode.removeChild(this.picker); this.picker = null;} else { this.picker.classList.add('hidden');} } this.emit('collapse');} togglePicker() { if (this.pickerVisible) { this.hidePicker();} else { this.showPicker();} } parseInput(value) { if (!value) return null; if (typeof value !== 'string') return null; const formats = [this.format, ...this.altFormats]; for (const format of formats) { const date = this.parseWithFormat(value.trim(), format); if (date && !isNaN(date.getTime())) { return date;} } return null;} parseWithFormat(value, format) { if (!value || !format) return null; try { let year, month, day; if (format === 'MM/dd/yyyy' || format === 'M/d/yyyy') { const parts = value.split('/'); if (parts.length === 3) { month = parseInt(parts[0]) - 1; day = parseInt(parts[1]); year = parseInt(parts[2]);} } else if (format === 'dd/MM/yyyy') { const parts = value.split('/'); if (parts.length === 3) { day = parseInt(parts[0]); month = parseInt(parts[1]) - 1; year = parseInt(parts[2]);} } else if (format === 'MM-dd-yyyy') { const parts = value.split('-'); if (parts.length === 3) { month = parseInt(parts[0]) - 1; day = parseInt(parts[1]); year = parseInt(parts[2]);} } else if (format === 'yyyy-MM-dd') { const parts = value.split('-'); if (parts.length === 3) { year = parseInt(parts[0]); month = parseInt(parts[1]) - 1; day = parseInt(parts[2]);} } else { return null;} if (year !== undefined && month !== undefined && day !== undefined && !isNaN(year) && !isNaN(month) && !isNaN(day) && year >= 1000 && year <= 9999 && month >= 0 && month <= 11 && day >= 1 && day <= 31) { const date = new Date(year, month, day); if (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) { return date;} } return null;} catch (e) { return null;} } parseDate(value) { if (value instanceof Date) return value; if (typeof value === 'string') return this.parseInput(value); return null;} formatDate(date, format = null) { if (!date || !(date instanceof Date) || isNaN(date.getTime())) return ''; const formatToUse = format || this.displayFormat || this.format; if (formatToUse === 'locale' && this.locale) { try { return new Intl.DateTimeFormat(this.locale).format(date);} catch (e) { } } let result = formatToUse; result = result.replace(/yyyy/g, date.getFullYear()); result = result.replace(/MM/g, String(date.getMonth() + 1).padStart(2, '0')); result = result.replace(/\bM\b/g, date.getMonth() + 1); result = result.replace(/dd/g, String(date.getDate()).padStart(2, '0')); result = result.replace(/\bd\b/g, date.getDate()); return result;} formatDateISO(date) { if (!date || !(date instanceof Date)) return ''; const year = date.getFullYear(); const month = String(date.getMonth() + 1).padStart(2, '0'); const day = String(date.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`;} isDateDisabled(date) { if (this.minDate && date < this.minDate) return true; if (this.maxDate && date > this.maxDate) return true; if (this.disabledDays.includes(date.getDay())) return true; return false;} isSameDay(date1, date2) { return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();} generateYearOptions() { const currentYear = new Date().getFullYear(); const startYear = currentYear - 100; const endYear = currentYear + 10; const options = []; for (let year = startYear; year <= endYear; year++) { options.push(`<option value="${year}">${year}</option>`);} return options.join('');} getMonthNames() { if (typeof Intl !== 'undefined') { const formatter = new Intl.DateTimeFormat(this.locale, { month: 'long' }); return Array.from({ length: 12 }, (_, i) => formatter.format(new Date(2000, i, 1)) );} return [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ];} getDayNames() { if (typeof Intl !== 'undefined') { const formatter = new Intl.DateTimeFormat(this.locale, { weekday: 'long' }); const baseDate = new Date(2000, 0, 2); return Array.from({ length: 7 }, (_, i) => { const date = new Date(baseDate); date.setDate(baseDate.getDate() + ((this.startOfWeek + i) % 7)); return formatter.format(date);});} const names = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']; return Array.from({ length: 7 }, (_, i) => names[(this.startOfWeek + i) % 7]);} getDayNamesShort() { return this.getDayNames().map(name => name.slice(0, 3));} static formatDateStatic(date, format, locale) { if (!date || !(date instanceof Date) || isNaN(date.getTime())) return ''; if (format === 'locale' && locale) { try { return new Intl.DateTimeFormat(locale).format(date);} catch (e) { format = 'MM/dd/yyyy';} } let result = format; result = result.replace(/yyyy/g, date.getFullYear()); result = result.replace(/MM/g, String(date.getMonth() + 1).padStart(2, '0')); result = result.replace(/\bM\b/g, date.getMonth() + 1); result = result.replace(/dd/g, String(date.getDate()).padStart(2, '0')); result = result.replace(/\bd\b/g, date.getDate()); return result;} static parseInputStatic(value, format, altFormats) { if (!value) return null; if (typeof value !== 'string') return null; const formats = [format, ...altFormats]; for (const fmt of formats) { const date = DateField.parseWithFormatStatic(value.trim(), fmt); if (date && !isNaN(date.getTime())) { return date;} } return null;} static parseWithFormatStatic(value, format) { if (!value || !format) return null; try { let year, month, day; if (format === 'MM/dd/yyyy' || format === 'M/d/yyyy') { const parts = value.split('/'); if (parts.length === 3) { month = parseInt(parts[0]) - 1; day = parseInt(parts[1]); year = parseInt(parts[2]);} } else if (format === 'dd/MM/yyyy') { const parts = value.split('/'); if (parts.length === 3) { day = parseInt(parts[0]); month = parseInt(parts[1]) - 1; year = parseInt(parts[2]);} } else if (format === 'MM-dd-yyyy') { const parts = value.split('-'); if (parts.length === 3) { month = parseInt(parts[0]) - 1; day = parseInt(parts[1]); year = parseInt(parts[2]);} } else if (format === 'yyyy-MM-dd') { const parts = value.split('-'); if (parts.length === 3) { year = parseInt(parts[0]); month = parseInt(parts[1]) - 1; day = parseInt(parts[2]);} } else { return null;} if (year !== undefined && month !== undefined && day !== undefined && !isNaN(year) && !isNaN(month) && !isNaN(day) && year >= 1000 && year <= 9999 && month >= 0 && month <= 11 && day >= 1 && day <= 31) { const date = new Date(year, month, day); if (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) { return date;} } return null;} catch (e) { return null;} } detectInputFormat(value) { if (!value || typeof value !== 'string') return null; if (/^\d{4}-\d{2}-\d{2}$/.test(value)) { return 'yyyy-MM-dd';} else if (/^\d{2}\/\d{2}\/\d{4}$/.test(value)) { return 'MM/dd/yyyy';} else if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(value)) { return 'M/d/yyyy';} else if (/^\d{2}-\d{2}-\d{4}$/.test(value)) { return 'MM-dd-yyyy';} return null;} getValue() { if (!this.dateValue) return ''; if (this._lastReturnFormat === 'iso') { this._lastReturnFormat = null; return this.formatDateISO(this.dateValue);} if (this._originalInputFormat) { return this.formatDate(this.dateValue, this._originalInputFormat);} return this.formatDate(this.dateValue, this.format);} setValue(value, updateDisplay = true) { const oldValue = this.getValue(); if (!value) { this.dateValue = null; this._originalInputFormat = null; super.setValue('', updateDisplay);} else { const date = this.parseInput(value); if (date) { this.dateValue = date; this._originalInputValue = value; this._originalInputFormat = this.detectInputFormat(value) || this.format; const formattedValue = this.formatDate(date, this.displayFormat); super.setValue(formattedValue, updateDisplay); if (this.picker) { this.currentViewDate = new Date(date); this.updateCalendar();} } else { this.dateValue = null; this._originalInputValue = null; this._originalInputFormat = null; super.setValue(value, updateDisplay);} } const newValue = this.getValue(); if (oldValue !== newValue) { this.emit('change', { field: this, value: newValue, oldValue });} return this;} getDateValue() { return this.dateValue ? new Date(this.dateValue) : null;} getRawValue() { return this.dateValue ? new Date(this.dateValue) : null;} setDateValue(date) { if (date instanceof Date && !isNaN(date.getTime())) { this.setValue(this.formatDate(date));} else { this.setValue('');} return this;} setMinDate(date) { this.minDate = this.parseDate(date); this.updateCalendar(); return this;} setMaxDate(date) { this.maxDate = this.parseDate(date); this.updateCalendar(); return this;} reset() { if (this.originalValue) { this.setValue(this.originalValue);} else { this.setValue('');} return this;} validate() { if (!this.validators || this.validators.length === 0) { this.clearInvalid(); this.emit('valid'); return true;} for (const validator of this.validators) { const result = this.validateSingle(validator); if (!result.valid) { this.markInvalid(result.message); this.emit('invalid', { message: result.message }); return false;} } this.clearInvalid(); this.emit('valid'); return true;} validateSingle(validator) { const value = this.getValue(); const inputValue = this.inputEl ? this.inputEl.value : ''; const { type, message } = validator; switch (type) { case 'required': if (this.allowBlank === false && (!this.dateValue && inputValue.trim())) { return { valid: false, message: message || 'Date is required' };} if (!value && !inputValue) { return { valid: false, message: message || 'Date is required' };} break; case 'dateFormat': if (inputValue && inputValue.trim() && !this.dateValue) { return { valid: false, message: message || 'Invalid date format' };} break; case 'dateRange': if (this.dateValue) { if (this.minDate && this.dateValue < this.minDate) { return { valid: false, message: message || `Date must be on or after minimum date` };} if (this.maxDate && this.dateValue > this.maxDate) { return { valid: false, message: message || `Date must be on or before maximum date` };} } break; default: return super.validateSingle ? super.validateSingle(validator) : { valid: true };} return { valid: true };} getFormData() { const data = {}; if (this.name) { data[this.name] = this.getValue();} return data;} reset() { if (this.originalValue !== undefined) { this.setValue(this.originalValue);} else { this.setValue('');} return this;} setDisabled(disabled) { super.setDisabled(disabled); this.disabled = disabled; if (this.triggerEl) { this.triggerEl.disabled = disabled; if (disabled) { this.triggerEl.classList.add('opacity-50', 'cursor-not-allowed');} else { this.triggerEl.classList.remove('opacity-50', 'cursor-not-allowed');} } return this;} destroy() { if (this.parentForm && typeof this.parentForm.unregisterField === 'function') { this.parentForm.unregisterField(this);} if (this.picker) { document.removeEventListener('click', this.onDocumentClick);} super.destroy();} } class TextArea extends TextField { constructor(config = {}) { super(config); config = config || {}; this.rows = config.rows || 3; this.cols = config.cols; this.wrap = config.wrap || 'soft'; this.autoResize = config.autoResize || false; this.maxRows = config.maxRows || 10; this.minRows = config.minRows || this.rows; this.showCharCount = config.showCharCount || false; this.charCountText = config.charCountText || '{0} characters'; this.maxLengthText = config.maxLengthText || '{0} / {1} characters'; this.labelAlign = config.labelAlign || 'top'; this.textareaEl = null; this.charCountEl = null;} createTemplate() { const labelTemplate = this.createLabelTemplate(); const textareaTemplate = this.createTextAreaTemplate(); const errorTemplate = this.createErrorTemplate(); const charCountTemplate = this.createCharCountTemplate(); return ` <div class="${this.getFieldClasses().join(' ')}"> ${labelTemplate} <div class="aionda-textarea-input-wrap relative"> ${textareaTemplate} ${charCountTemplate} ${errorTemplate} </div> </div> `;} createLabelTemplate() { if (!this.fieldLabel) return ''; const labelClasses = [ 'aionda-textarea-label', 'block', 'text-sm', 'font-medium', 'text-gray-700' ]; if (this.labelAlign === 'top') { labelClasses.push('mb-1');} const requiredMark = !this.allowBlank ? '<span class="text-red-500 ml-1">*</span>' : ''; return ` <label class="${labelClasses.join(' ')}" for="${this.id}-textarea"> ${this.fieldLabel}${requiredMark} </label> `;} createTextAreaTemplate() { const textareaClasses = [ 'aionda-textarea-input', 'block', 'w-full', 'px-3', 'py-2', 'border', 'border-gray-300', 'rounded-md', 'shadow-sm', 'placeholder-gray-400', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'focus:border-blue-500', 'transition-colors', 'duration-200', 'resize-none' ]; if (this.fieldCls) { textareaClasses.push(...this.fieldCls.split(' '));} if (this.readOnly) { textareaClasses.push('bg-gray-50', 'cursor-default');} if (!this.autoResize) { textareaClasses.push('resize-y');} const attributes = [ `id="${this.id}-textarea"`, `name="${this.name}"`, `rows="${this.rows}"`, this.cols ? `cols="${this.cols}"` : '', `wrap="${this.wrap}"`, `placeholder="${this.escapeHtml(this.placeholder || this.emptyText)}"`, this.readOnly ? 'readonly' : '', this.maxLength ? `maxlength="${this.maxLength}"` : '', this.disabled ? 'disabled' : '' ].filter(Boolean); return ` <textarea class="${textareaClasses.join(' ')}" ${attributes.join(' ')}>${this.escapeHtml(this.value)}</textarea> `;} createCharCountTemplate() { if (!this.showCharCount) return ''; return ` <div class="aionda-textarea-charcount text-xs text-gray-500 mt-1 text-right"> <!-- Character count will be inserted here --> </div> `;} createErrorTemplate() { return ` <div class="aionda-textarea-error text-sm text-red-600 mt-1 hidden"> <!-- Error message will be inserted here --> </div> `;} getBaseClasses() { const classes = [ ...super.getBaseClasses(), 'aionda-textarea', 'aionda-field' ]; if (this.labelAlign === 'left' || this.labelAlign === 'right') { classes.push('flex', 'items-start', 'gap-3');} if (!this.valid) { classes.push('aionda-field-invalid');} return classes;} getFieldClasses() { return this.getBaseClasses();} setupEventListeners() { Component.prototype.setupEventListeners.call(this); this.textareaEl = this.el.querySelector('.aionda-textarea-input'); this.inputEl = this.textareaEl; this.labelEl = this.el.querySelector('.aionda-textarea-label'); this.errorEl = this.el.querySelector('.aionda-textarea-error'); this.charCountEl = this.el.querySelector('.aionda-textarea-charcount'); if (this.textareaEl) { this.textareaEl.addEventListener('input', (e) => this.onInput(e)); this.textareaEl.addEventListener('change', (e) => this.onChange(e)); this.textareaEl.addEventListener('focus', (e) => this.onFocus(e)); this.textareaEl.addEventListener('blur', (e) => this.onBlur(e));} if (this.enableKeyEvents && this.textareaEl) { this.textareaEl.addEventListener('keydown', (e) => this.onKeyDown(e)); this.textareaEl.addEventListener('keyup', (e) => this.onKeyUp(e)); this.textareaEl.addEventListener('keypress', (e) => this.onKeyPress(e));} if (this.selectOnFocus && this.textareaEl) { this.textareaEl.addEventListener('focus', () => { setTimeout(() => this.textareaEl.select(), 10);});} if (this.autoResize && this.textareaEl) { this.textareaEl.addEventListener('input', () => this.adjustHeight()); setTimeout(() => this.adjustHeight(), 0);} this.updateCharCount();} adjustHeight() { if (!this.autoResize || !this.textareaEl) return; this.textareaEl.style.height = 'auto'; const lineHeight = parseInt(getComputedStyle(this.textareaEl).lineHeight) || 20; const padding = parseInt(getComputedStyle(this.textareaEl).paddingTop) + parseInt(getComputedStyle(this.textareaEl).paddingBottom); const minHeight = (this.minRows * lineHeight) + padding; const maxHeight = (this.maxRows * lineHeight) + padding; const scrollHeight = this.textareaEl.scrollHeight; const newHeight = Math.min(Math.max(scrollHeight, minHeight), maxHeight); this.textareaEl.style.height = newHeight + 'px'; if (scrollHeight > maxHeight) { this.textareaEl.style.overflowY = 'auto';} else { this.textareaEl.style.overflowY = 'hidden';} } updateCharCount() { if (!this.charCountEl || !this.showCharCount) return; const currentLength = this.value.length; let text = ''; this.charCountEl.classList.remove('text-gray-500', 'text-orange-500', 'text-red-500'); if (this.maxLength) { text = this.maxLengthText.replace('{0}', currentLength).replace('{1}', this.maxLength); if (currentLength >= this.maxLength) { this.charCountEl.classList.add('text-red-500');} else if (currentLength >= this.maxLength * 0.9) { this.charCountEl.classList.add('text-orange-500');} else { this.charCountEl.classList.add('text-gray-500');} } else { text = this.charCountText.replace('{0}', currentLength); this.charCountEl.classList.add('text-gray-500');} this.charCountEl.textContent = text;} onInput(event) { let value = event.target.value; if (this.maxLength && value.length > this.maxLength) { value = value.substring(0, this.maxLength); event.target.value = value;} this.setValue(value, false); if (this.validateOnChange) { this.validate();} this.updateCharCount(); if (this.autoResize) { this.adjustHeight();} this.emit('input', { value, event });} onChange(event) { const value = event.target.value; const oldValue = this.lastValue; this.setValue(value, false); this.lastValue = value; this.emit('change', { value, oldValue, field: this.name });} onFocus(event) { this.hasFocus = true; this.textareaEl.classList.add(...this.focusCls.split(' ')); this.emit('focus', { value: this.value, event, field: this });} onBlur(event) { this.hasFocus = false; this.textareaEl.classList.remove(...this.focusCls.split(' ')); if (this.validateOnBlur) { this.validate();} this.emit('blur', { value: this.value, event, field: this });} onKeyDown(event) { this.emit('keydown', { key: event.key, event, field: this });} onKeyUp(event) { this.emit('keyup', { key: event.key, event, field: this });} onKeyPress(event) { this.emit('keypress', { key: event.key, event, field: this });} getValue() { return this.value;} setValue(value, updateDisplay = true) { const oldValue = this.value; this.value = value != null ? String(value) : ''; if (updateDisplay && this.textareaEl) { this.textareaEl.value = this.value;} this.updateCharCount(); if (updateDisplay && this.autoResize) { setTimeout(() => this.adjustHeight(), 0);} if (updateDisplay && oldValue !== this.value) { this.emit('change', { value: this.value, oldValue, field: this.name });} return this;} getRawValue() { return this.textareaEl ? this.textareaEl.value : this.value;} reset() { this.setValue(this.originalValue); this.clearInvalid(); return this;} isDirty() { return this.value !== this.originalValue;} validate() { const value = this.getValue(); if (!this.allowBlank && (!value || value.trim().length === 0)) { this.markInvalid('Field is required'); return false;} if (value && this.minLength && value.length < this.minLength) { this.markInvalid(`Minimum length is ${this.minLength} characters`); return false;} if (value && this.maxLength && value.length > this.maxLength) { this.markInvalid(`Maximum length is ${this.maxLength} characters`); return false;} if (value && this.regex && !this.regex.test(value)) { this.markInvalid('Invalid format'); return false;} if (this.validator && typeof this.validator === 'function') { const result = this.validator(value, this); if (result !== true) { this.markInvalid(result || 'Invalid value'); return false;} } for (const validator of this.validators) { const result = this.runValidator(validator, value); if (result !== true) { this.markInvalid(result); return false;} } this.clearInvalid(); return true;} runValidator(validator, value) { if (typeof validator === 'function') { return validator(value, this);} if (typeof validator === 'object') { const { type, message, ...options } = validator; switch (type) { case 'required': return (value && value.trim().length > 0) ? true : (message || 'Field is required'); case 'email': const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; return !value || emailRegex.test(value) ? true : (message || 'Please enter a valid email address'); case 'url': try { if (value) new URL(value); return true;} catch { return message || 'Please enter a valid URL';} case 'minLength': return !value || value.length >= options.min ? true : (message || `Minimum length is ${options.min} characters`); case 'pattern': return !value || options.regex.test(value) ? true : (message || 'Invalid format'); default: return true;} } return true;} isValid() { return this.valid;} markInvalid(message) { this.valid = false; this.errorMessage = message; if (this.textareaEl) { this.textareaEl.classList.add(...this.invalidCls.split(' '));} if (this.errorEl) { this.errorEl.textContent = message; this.errorEl.classList.remove('hidden');} this.emit('invalid', { message, field: this }); return this;} clearInvalid() { this.valid = true; this.errorMessage = ''; if (this.textareaEl) { this.textareaEl.classList.remove(...this.invalidCls.split(' '));} if (this.errorEl) { this.errorEl.textContent = ''; this.errorEl.classList.add('hidden');} this.emit('valid', { field: this }); return this;} focus() { if (this.textareaEl) { this.textareaEl.focus();} return this;} blur() { if (this.textareaEl) { this.textareaEl.blur();} return this;} selectText(start, end) { if (this.textareaEl) { if (start === undefined) { this.textareaEl.select();} else { this.textareaEl.setSelectionRange(start, end || start);} } return this;} insertTextAtCursor(text) { if (!this.textareaEl) return this; const start = this.textareaEl.selectionStart; const end = this.textareaEl.selectionEnd; const value = this.textareaEl.value; const newValue = value.substring(0, start) + text + value.substring(end); this.setValue(newValue); if (this.textareaEl) { this.textareaEl.value = newValue;} setTimeout(() => { const newPosition = start + text.length; this.textareaEl.setSelectionRange(newPosition, newPosition);}, 0); return this;} getSelectedText() { if (!this.textareaEl) return ''; const start = this.textareaEl.selectionStart; const end = this.textareaEl.selectionEnd; return this.textareaEl.value.substring(start, end);} replaceSelectedText(text) { if (!this.textareaEl) return this; const start = this.textareaEl.selectionStart; const end = this.textareaEl.selectionEnd; const value = this.textareaEl.value; const newValue = value.substring(0, start) + text + value.substring(end); this.setValue(newValue); if (this.textareaEl) { this.textareaEl.value = newValue;} setTimeout(() => { const newPosition = start + text.length; this.textareaEl.setSelectionRange(newPosition, newPosition);}, 0); return this;} escapeHtml(text) { if (!text) return ''; const div = document.createElement('div'); div.textContent = text; return div.innerHTML;} setReadOnly(readOnly) { this.readOnly = readOnly; if (this.textareaEl) { if (readOnly) { this.textareaEl.setAttribute('readonly', ''); this.textareaEl.classList.add('bg-gray-50', 'cursor-default');} else { this.textareaEl.removeAttribute('readonly'); this.textareaEl.classList.remove('bg-gray-50', 'cursor-default');} } return this;} setDisabled(disabled) { this.disabled = disabled; if (this.textareaEl) { if (disabled) { this.textareaEl.setAttribute('disabled', '');} else { this.textareaEl.removeAttribute('disabled');} } return this;} setRows(rows) { this.rows = rows; if (this.textareaEl) { this.textareaEl.setAttribute('rows', rows);} return this;} setAutoResize(autoResize) { this.autoResize = autoResize; if (this.textareaEl) { if (autoResize) { this.textareaEl.classList.remove('resize-y'); this.textareaEl.classList.add('resize-none'); this.textareaEl.addEventListener('input', () => this.adjustHeight()); setTimeout(() => this.adjustHeight(), 0);} else { this.textareaEl.classList.add('resize-y'); this.textareaEl.classList.remove('resize-none'); this.textareaEl.style.height = 'auto'; this.textareaEl.style.overflowY = 'auto';} } return this;} setMaxRows(maxRows) { this.maxRows = maxRows; if (this.autoResize) { this.adjustHeight();} return this;} setMinRows(minRows) { this.minRows = minRows; if (this.autoResize) { this.adjustHeight();} return this;} } class RadioGroup extends Component { constructor(config = {}) { super(config); config = config || {}; this.name = config.name || this.id; this.fieldLabel = config.fieldLabel || config.label || ''; this.value = config.value || ''; this.items = config.items || []; this.columns = config.columns || 1; this.layout = config.layout || 'vertical'; this.readOnly = config.readOnly || false; this.allowBlank = config.allowBlank !== false; this.submitValue = config.submitValue !== false; this.validators = config.validators || []; this.labelAlign = config.labelAlign || 'top'; this.labelWidth = config.labelWidth || 120; this.radioGroupCls = config.radioGroupCls || ''; this.focusCls = config.focusCls || 'ring-2 ring-blue-500'; this.size = config.size || 'md'; this.originalValue = this.value; this.lastValue = this.value; this.valid = true; this.errorMessage = ''; this.hasFocus = false; this.labelEl = null; this.groupEl = null; this.errorEl = null; this.radios = new Map(); this.form = config.form || null; if (this.form && typeof this.form.add === 'function') { this.form.add(this);} this.focusedRadioIndex = -1;} createTemplate() { const labelTemplate = this.createLabelTemplate(); const groupTemplate = this.createGroupTemplate(); const errorTemplate = this.createErrorTemplate(); return ` <div class="${this.getFieldClasses().join(' ')}"> ${labelTemplate} <div class="aionda-radiogroup-input-wrap"> ${groupTemplate} ${errorTemplate} </div> </div> `;} createLabelTemplate() { if (!this.fieldLabel) return ''; const labelClasses = [ 'aionda-field-label', 'block', 'text-sm', 'font-medium', 'text-gray-700' ]; if (this.labelAlign === 'top') { labelClasses.push('mb-2');} return ` <label id="${this.id}-label" class="${labelClasses.join(' ')}"> ${this.fieldLabel} </label> `;} createGroupTemplate() { const groupClasses = [ 'aionda-radiogroup-items', 'space-y-2' ]; if (this.layout === 'horizontal') { groupClasses.splice(-1, 1, 'space-x-4', 'flex', 'flex-wrap');} if (this.columns > 1) { groupClasses.push('grid', `grid-cols-${this.columns}`, 'gap-2'); return this.createColumnGroupTemplate();} const itemsHtml = this.items.filter(item => item !== null && item !== undefined).map((item, index) => { return this.createRadioItemTemplate(item, index);}).join(''); return ` <div class="${groupClasses.join(' ')}" role="radiogroup" ${this.fieldLabel ? `aria-labelledby="${this.id}-label"` : ''}> ${itemsHtml} </div> `;} createColumnGroupTemplate() { const itemsPerColumn = Math.ceil(this.items.length / this.columns); const columns = []; for (let col = 0; col < this.columns; col++) { const start = col * itemsPerColumn; const end = Math.min(start + itemsPerColumn, this.items.length); const columnItems = this.items.slice(start, end).filter(item => item !== null && item !== undefined); const columnHtml = columnItems.map((item, index) => { return this.createRadioItemTemplate(item, start + index);}).join(''); columns.push(`<div class="aionda-radiogroup-column">${columnHtml}</div>`);} return ` <div class="aionda-radiogroup-items grid grid-cols-${this.columns} gap-2" role="radiogroup" ${this.fieldLabel ? `aria-labelledby="${this.id}-label"` : ''}> ${columns.join('')} </div> `;} createRadioItemTemplate(item, index) { const radioId = `${this.id}-radio-${item.inputValue}-${index}`; const isChecked = this.value === item.inputValue; const itemClasses = [ 'aionda-radiogroup-item' ]; if (this.layout === 'horizontal') { itemClasses.push('flex-shrink-0');} return ` <div class="${itemClasses.join(' ')}" data-radio-index="${index}"> <div class="flex items-center"> <input id="${radioId}" name="${this.name}" type="radio" value="${item.inputValue}" class="aionda-radio-input ${this.getSizeClasses().join(' ')} border-gray-300 text-blue-600 focus:ring-blue-500 focus:ring-2 focus:ring-offset-0 transition-colors duration-200" ${isChecked ? 'checked' : ''} ${this.readOnly ? 'readonly' : ''} ${this.disabled ? 'disabled' : ''} aria-label="${item.boxLabel || item.label || item.text || item.inputValue}" aria-describedby="${item.description ? `${radioId}-desc` : ''}" role="radio" > <label for="${radioId}" class="aionda-radio-label ml-2 text-sm text-gray-700 cursor-pointer select-none"> ${item.boxLabel || item.label || item.text || item.inputValue} </label> </div> ${item.description ? `<div id="${radioId}-desc" class="ml-6 text-xs text-gray-500">${item.description}</div>` : ''} </div> `;} createErrorTemplate() { return ` <div class="aionda-radiogroup-error text-sm text-red-600 mt-1 hidden"> <!-- Error message will be inserted here --> </div> `;} getSizeClasses() { switch (this.size) { case 'sm': return ['h-4', 'w-4']; case 'lg': return ['h-6', 'w-6']; default: return ['h-5', 'w-5'];} } getFieldClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-radiogroup', 'aionda-field' ]; if (this.size) { classes.push(`aionda-radiogroup-${this.size}`);} if (this.layout === 'horizontal') { classes.push('aionda-radiogroup-horizontal');} else { classes.push('aionda-radiogroup-vertical');} if (this.columns > 1) { classes.push(`aionda-radiogroup-columns-${this.columns}`);} if (!this.valid) { classes.push('aionda-field-invalid');} return classes;} setupEventListeners() { super.setupEventListeners(); this.labelEl = this.el.querySelector('.aionda-field-label'); this.groupEl = this.el.querySelector('.aionda-radiogroup-items'); this.errorEl = this.el.querySelector('.aionda-radiogroup-error'); this.radioInputs = this.el.querySelectorAll('.aionda-radio-input'); this.radioInputs.forEach((input, index) => { input.addEventListener('change', (e) => this.onRadioChange(e, index)); input.addEventListener('click', (e) => this.onRadioClick(e, index)); input.addEventListener('focus', (e) => this.onRadioFocus(e, index)); input.addEventListener('blur', (e) => this.onRadioBlur(e, index)); input.addEventListener('keydown', (e) => this.onRadioKeyDown(e, index));}); const labels = this.el.querySelectorAll('.aionda-radio-label'); labels.forEach((label, index) => { label.addEventListener('click', (e) => this.onLabelClick(e, index));});} onRadioChange(event, index) { if (this.readOnly || this.disabled) { event.preventDefault(); return;} const oldValue = this.value; this.value = event.target.value; this.focusedRadioIndex = index; this.updateDisplay(); this.emit('change', { field: this.name, value: this.value, oldValue: oldValue }); if (this.form && typeof this.form.emit === 'function') { this.form.emit('change', { field: this.name, value: this.value, oldValue: oldValue });} } onRadioClick(event, index) { if (this.readOnly || this.disabled) { event.preventDefault(); return;} const radio = event.target; if (!radio.checked) { radio.checked = true; const changeEvent = new Event('change', { bubbles: true }); radio.dispatchEvent(changeEvent);} } onLabelClick(event, index) { if (this.readOnly || this.disabled) { event.preventDefault(); return;} if (index >= 0 && index < this.radioInputs.length) { const radio = this.radioInputs[index]; if (!radio.disabled && !radio.checked) { radio.checked = true; const changeEvent = new Event('change', { bubbles: true }); radio.dispatchEvent(changeEvent);} } } onRadioFocus(event, index) { this.hasFocus = true; this.focusedRadioIndex = index; this.emit('focus', { event, field: this, index });} onRadioBlur(event, index) { this.hasFocus = false; this.emit('blur', { event, field: this, index });} onRadioKeyDown(event, index) { this.focusedRadioIndex = index; this.handleKeyNavigation(event, index); this.emit('keydown', { key: event.key, event, field: this, index });} getCurrentFocusedIndex() { if (!this.radioInputs) return -1; for (let i = 0; i < this.radioInputs.length; i++) { if (this.radioInputs[i] === document.activeElement) { return i;} } return this.focusedRadioIndex >= 0 ? this.focusedRadioIndex : 0;} handleKeyNavigation(event, currentIndex) { if (this.readOnly || this.disabled) return; let targetIndex = -1; switch (event.key) { case 'ArrowDown': case 'ArrowRight': event.preventDefault(); event.stopPropagation(); targetIndex = this.getNextRadioIndex(currentIndex); if (targetIndex >= 0) { this.selectRadio(targetIndex); this.focusRadio(targetIndex);} break; case 'ArrowUp': case 'ArrowLeft': event.preventDefault(); event.stopPropagation(); targetIndex = this.getPreviousRadioIndex(currentIndex); if (targetIndex >= 0) { this.selectRadio(targetIndex); this.focusRadio(targetIndex);} break; case ' ': case 'Enter': event.preventDefault(); event.stopPropagation(); if (currentIndex >= 0 && currentIndex < this.radioInputs.length) { this.selectRadio(currentIndex);} break; case 'Home': event.preventDefault(); event.stopPropagation(); targetIndex = this.getFirstEnabledRadioIndex(); if (targetIndex >= 0) { this.selectRadio(targetIndex); this.focusRadio(targetIndex);} break; case 'End': event.preventDefault(); event.stopPropagation(); targetIndex = this.getLastEnabledRadioIndex(); if (targetIndex >= 0) { this.selectRadio(targetIndex); this.focusRadio(targetIndex);} break;} } getNextRadioIndex(currentIndex) { if (!this.radioInputs || this.radioInputs.length === 0) return -1; for (let i = currentIndex + 1; i < this.radioInputs.length; i++) { if (!this.radioInputs[i].disabled) { return i;} } for (let i = 0; i < currentIndex; i++) { if (!this.radioInputs[i].disabled) { return i;} } return -1;} getPreviousRadioIndex(currentIndex) { if (!this.radioInputs || this.radioInputs.length === 0) return -1; for (let i = currentIndex - 1; i >= 0; i--) { if (!this.radioInputs[i].disabled) { return i;} } for (let i = this.radioInputs.length - 1; i > currentIndex; i--) { if (!this.radioInputs[i].disabled) { return i;} } return -1;} getFirstEnabledRadioIndex() { if (!this.radioInputs || this.radioInputs.length === 0) return -1; for (let i = 0; i < this.radioInputs.length; i++) { if (!this.radioInputs[i].disabled) { return i;} } return -1;} getLastEnabledRadioIndex() { if (!this.radioInputs || this.radioInputs.length === 0) return -1; for (let i = this.radioInputs.length - 1; i >= 0; i--) { if (!this.radioInputs[i].disabled) { return i;} } return -1;} focusRadio(index) { if (index >= 0 && index < this.radioInputs.length) { this.radioInputs[index].focus(); this.focusedRadioIndex = index;} } selectRadio(index) { if (index >= 0 && index < this.radioInputs.length) { const radio = this.radioInputs[index]; if (!radio.disabled && !this.readOnly) { this.radioInputs.forEach(r => { if (r !== radio) { r.checked = false;} }); radio.checked = true; this.focusedRadioIndex = index; const changeEvent = new Event('change', { bubbles: true }); radio.dispatchEvent(changeEvent);} } } getValue() { return this.value;} setValue(value) { const validItem = this.items.find(item => item.inputValue === value); if (validItem || value === '' || value === null || value === undefined) { const oldValue = this.value; this.value = value || ''; this.updateDisplay(); if (this.form && typeof this.form.emit === 'function') { this.form.emit('change', { field: this.name, value: this.value, oldValue: oldValue });} } return this;} updateDisplay() { if (this.radioInputs) { this.radioInputs.forEach((input) => { input.checked = input.value === this.value;});} } getSelectedItem() { if (this.value === null || this.value === undefined) { return null;} return this.items.find(item => item.inputValue === this.value) || null;} getSelectedIndex() { if (this.value === null || this.value === undefined) { return -1;} return this.items.findIndex(item => item.inputValue === this.value);} selectByIndex(index) { if (index >= 0 && index < this.items.length) { this.setValue(this.items[index].inputValue);} return this;} clearSelection() { this.setValue(''); return this;} addItem(item) { this.items.push(item); if (this.el) { this.updateDOM();} return this;} removeItem(inputValue) { const index = this.items.findIndex(item => item.inputValue === inputValue); if (index >= 0) { this.items.splice(index, 1); if (this.value === inputValue) { this.clearSelection();} if (this.el) { this.updateDOM();} } return this;} setItems(items) { this.items = items || []; if (this.value !== null && !this.items.find(item => item.inputValue === this.value)) { this.clearSelection();} if (this.el) { this.updateDOM();} return this;} clearItems() { this.items = []; this.clearSelection(); if (this.el) { this.updateDOM();} return this;} updateDOM() { if (this.el && this.el.parentNode) { const parentNode = this.el.parentNode; const nextSibling = this.el.nextSibling; const oldEl = this.el; this.rendered = false; this.el = null; const newEl = this.render(); parentNode.removeChild(oldEl); if (nextSibling) { parentNode.insertBefore(newEl, nextSibling);} else { parentNode.appendChild(newEl);} this.el = newEl; this.setupEventListeners();} } reset() { this.setValue(this.originalValue); this.clearInvalid(); return this;} isDirty() { return this.value !== this.originalValue;} validate() { if (this.validators && Array.isArray(this.validators)) { for (const validator of this.validators) { if (validator.type === 'required' && (this.value === null || this.value === undefined || this.value === '')) { this.markInvalid(validator.message || 'This field is required'); return false;} } } if (!this.allowBlank && (this.value === null || this.value === undefined || this.value === '')) { this.markInvalid('This field is required'); return false;} this.clearInvalid(); return true;} isValid() { return this.validate();} markInvalid(message) { this.valid = false; this.errorMessage = message; if (this.errorEl) { this.errorEl.textContent = message; this.errorEl.classList.remove('hidden');} this.emit('invalid', { message, field: this }); return this;} clearInvalid() { this.valid = true; this.errorMessage = ''; if (this.errorEl) { this.errorEl.textContent = ''; this.errorEl.classList.add('hidden');} this.emit('valid', { field: this }); return this;} focus() { const selectedIndex = this.getSelectedIndex(); const targetIndex = selectedIndex >= 0 ? selectedIndex : this.getFirstEnabledRadioIndex(); if (targetIndex >= 0) { this.focusRadio(targetIndex);} return this;} blur() { if (this.focusedRadioIndex >= 0 && this.focusedRadioIndex < this.radioInputs.length) { this.radioInputs[this.focusedRadioIndex].blur();} return this;} setReadOnly(readOnly) { this.readOnly = readOnly; if (this.radioInputs) { this.radioInputs.forEach(input => { if (readOnly) { input.setAttribute('readonly', '');} else { input.removeAttribute('readonly');} });} return this;} disable() { return this.setDisabled(true);} enable() { return this.setDisabled(false);} setDisabled(disabled) { this.disabled = disabled; if (this.radioInputs) { this.radioInputs.forEach(input => { if (disabled) { input.setAttribute('disabled', '');} else { input.removeAttribute('disabled');} });} return this;} } class Radio extends Component { constructor(config = {}) { super(config); config = config || {}; this.name = config.name || this.id; this.fieldLabel = config.fieldLabel || config.label || ''; this.boxLabel = config.boxLabel || config.text || ''; this.checked = config.checked !== undefined ? config.checked : false; this.inputValue = config.inputValue || 'on'; this.uncheckedValue = config.uncheckedValue || ''; this.readOnly = config.readOnly || false; this.allowBlank = config.allowBlank !== false; this.submitValue = config.submitValue !== false; this.validators = config.validators || []; this.labelAlign = config.labelAlign || 'top'; this.labelWidth = config.labelWidth || 120; this.boxLabelAlign = config.boxLabelAlign || 'after'; this.radioCls = config.radioCls || ''; this.focusCls = config.focusCls || 'ring-2 ring-blue-500'; this.ariaLabel = config.ariaLabel || ''; this.radioGroup = config.radioGroup || null; this.size = config.size || 'md'; this.originalValue = this.checked; this.lastValue = this.checked; this.valid = true; this.errorMessage = ''; this.hasFocus = false; this.inputEl = null; this.labelEl = null; this.boxLabelEl = null; this.errorEl = null; this.form = null;} createTemplate() { const labelTemplate = this.createLabelTemplate(); const radioTemplate = this.createRadioTemplate(); const errorTemplate = this.createErrorTemplate(); return ` <div class="${this.getFieldClasses().join(' ')}"> ${labelTemplate} <div class="aionda-radio-input-wrap"> ${radioTemplate} ${errorTemplate} </div> </div> `;} createLabelTemplate() { if (!this.fieldLabel) return ''; const labelClasses = [ 'aionda-field-label', 'block', 'text-sm', 'font-medium', 'text-gray-700' ]; if (this.labelAlign === 'top') { labelClasses.push('mb-2');} const labelStyle = this.labelWidth ? `style="width: ${this.labelWidth}px"` : ''; return ` <label class="${labelClasses.join(' ')}" ${labelStyle}> ${this.fieldLabel} </label> `;} createRadioTemplate() { const wrapperClasses = [ 'aionda-radio-wrap', 'flex', 'items-center' ]; if (this.boxLabelAlign === 'before') { wrapperClasses.push('flex-row-reverse', 'justify-end');} const radioHtml = this.createDefaultRadioTemplate(); const boxLabelHtml = this.boxLabel ? this.createBoxLabelTemplate() : ''; return ` <div class="${wrapperClasses.join(' ')}"> ${radioHtml} ${boxLabelHtml} </div> `;} createDefaultRadioTemplate() { const sizeClasses = this.getSizeClasses(); const radioClasses = [ 'aionda-radio-input', 'border-gray-300', 'text-blue-600', 'focus:ring-blue-500', 'focus:ring-2', 'focus:ring-offset-0', 'transition-colors', 'duration-200', ...sizeClasses ]; if (this.radioCls) { radioClasses.push(...this.radioCls.split(' '));} if (this.readOnly) { radioClasses.push('bg-gray-50', 'cursor-default');} const attributes = [ `id="${this.id}-input"`, `name="${this.name}"`, `type="radio"`, `role="radio"`, `aria-checked="${this.checked}"`, `value="${this.inputValue}"`, this.ariaLabel ? `aria-label="${this.ariaLabel}"` : '', this.checked ? 'checked' : '', this.readOnly ? 'readonly' : '', this.disabled ? 'disabled' : '' ].filter(Boolean); return ` <input class="${radioClasses.join(' ')}" ${attributes.join(' ')}> `;} createBoxLabelTemplate() { const labelClasses = [ 'aionda-radio-label', 'text-sm', 'text-gray-700', 'select-none' ]; if (this.boxLabelAlign === 'after') { labelClasses.push('ml-2');} else { labelClasses.push('mr-2');} if (this.readOnly) { labelClasses.push('cursor-default');} else { labelClasses.push('cursor-pointer');} return ` <label class="${labelClasses.join(' ')}" for="${this.id}-input"> ${this.boxLabel} </label> `;} createErrorTemplate() { return ` <div class="aionda-radio-error text-sm text-red-600 mt-1 hidden"> <!-- Error message will be inserted here --> </div> `;} getSizeClasses() { switch (this.size) { case 'sm': return ['h-4', 'w-4']; case 'lg': return ['h-6', 'w-6']; default: return ['h-5', 'w-5'];} } getFieldClasses() { const classes = [ ...this.getBaseClasses(), 'aionda-radio', 'aionda-field' ]; if (this.size) { classes.push(`aionda-radio-${this.size}`);} if (!this.valid) { classes.push('aionda-field-invalid');} if (this.disabled) { classes.push('aionda-field-disabled');} if (this.readOnly) { classes.push('aionda-field-readonly');} return classes;} setupEventListeners() { super.setupEventListeners(); this.inputEl = this.el.querySelector('.aionda-radio-input'); this.labelEl = this.el.querySelector('.aionda-field-label'); this.boxLabelEl = this.el.querySelector('.aionda-radio-label'); this.errorEl = this.el.querySelector('.aionda-radio-error'); this.inputEl.addEventListener('change', (e) => this.onChange(e)); this.inputEl.addEventListener('click', (e) => this.onClick(e)); this.inputEl.addEventListener('focus', (e) => this.onFocus(e)); this.inputEl.addEventListener('blur', (e) => this.onBlur(e)); this.inputEl.addEventListener('keydown', (e) => this.onKeyDown(e)); if (this.boxLabelEl) { this.boxLabelEl.addEventListener('click', (e) => this.onLabelClick(e));} } onClick(event) { if (this.readOnly || this.disabled) { event.preventDefault(); return;} if (!event.isTrusted) { this.inputEl.checked = true; const changeEvent = new Event('change', { bubbles: true }); this.inputEl.dispatchEvent(changeEvent);} } onChange(event) { const oldValue = this.checked; this.checked = event.target.checked; this.updateValue(); if (this.radioGroup) { this.radioGroup.onRadioChange(this);} this.emit('change', { field: this.name, checked: this.checked, value: this.getValue() });} onFocus(event) { this.hasFocus = true; if (this.focusCls && this.inputEl) { this.inputEl.classList.add(...this.focusCls.split(' '));} this.emit('focus', { event, field: this });} onBlur(event) { this.hasFocus = false; if (this.focusCls && this.inputEl) { this.inputEl.classList.remove(...this.focusCls.split(' '));} this.emit('blur', { event, field: this });} onKeyDown(event) { if (event.key === ' ' || event.key === 'Enter') { if (!this.readOnly && !this.disabled) { event.preventDefault(); this.setChecked(true);} } if (this.radioGroup) { this.radioGroup.onRadioKeyDown(this, event);} this.emit('keydown', { key: event.key, event, field: this });} onLabelClick(event) { if (this.readOnly || this.disabled) return; event.preventDefault(); this.setChecked(true);} getValue() { return this.checked ? this.inputValue : this.uncheckedValue;} setValue(value) { this.checked = this.valueToChecked(value); this.updateValue(); this.updateDisplay(); return this;} valueToChecked(value) { if (typeof value === 'boolean') { return value;} return value === this.inputValue;} updateValue() { this.value = this.getValue();} updateDisplay() { if (this.inputEl) { this.inputEl.checked = this.checked; this.inputEl.setAttribute('aria-checked', this.checked.toString());} } setChecked(checked) { const oldValue = this.checked; this.checked = !!checked; this.lastValue = this.checked; this.updateValue(); this.updateDisplay(); if (oldValue !== this.checked) { if (this.radioGroup && typeof this.radioGroup.emit === 'function') { this.radioGroup.emit('change', { field: this.name, value: this.getValue(), oldValue: oldValue ? this.inputValue : this.uncheckedValue });} this.emit('change', { field: this.name, checked: this.checked, value: this.getValue() });} return this;} isChecked() { return this.checked;} reset() { this.setChecked(this.originalValue); this.clearInvalid(); return this;} isDirty() { return this.checked !== this.originalValue;} validate() { let isValid = true; if (this.validators && Array.isArray(this.validators)) { for (const validator of this.validators) { if (validator.type === 'required' && !this.checked) { this.markInvalid(validator.message || 'This field is required'); isValid = false; break;} } } if (isValid && !this.allowBlank && !this.checked) { this.markInvalid('This field is required'); isValid = false;} if (isValid) { this.clearInvalid();} this._lastValidationResult = isValid; return isValid;} checkValidation() { return this._lastValidationResult !== undefined ? this._lastValidationResult : this.valid;} isValid() { return this.valid;} markInvalid(message) { this.valid = false; this.errorMessage = message; if (this.el) { this.el.classList.add('aionda-field-invalid');} if (this.errorEl) { this.errorEl.textContent = message; this.errorEl.classList.remove('hidden');} this.emit('invalid', { message, field: this }); return this;} clearInvalid() { this.valid = true; this.errorMessage = ''; if (this.el) { this.el.classList.remove('aionda-field-invalid');} if (this.errorEl) { this.errorEl.textContent = ''; this.errorEl.classList.add('hidden');} this.emit('valid', { field: this }); return this;} focus() { if (this.inputEl) { this.inputEl.focus();} return this;} blur() { if (this.inputEl) { this.inputEl.blur();} return this;} setReadOnly(readOnly) { this.readOnly = readOnly; if (this.inputEl) { if (readOnly) { this.inputEl.setAttribute('readonly', '');} else { this.inputEl.removeAttribute('readonly');} } return this;} disable() { return this.setDisabled(true);} enable() { return this.setDisabled(false);} setDisabled(disabled) { this.disabled = disabled; if (this.inputEl) { if (disabled) { this.inputEl.setAttribute('disabled', '');} else { this.inputEl.removeAttribute('disabled');} } return this;} destroy() { if (this.inputEl) { this.inputEl.removeEventListener('change', (e) => this.onChange(e)); this.inputEl.removeEventListener('click', (e) => this.onClick(e)); this.inputEl.removeEventListener('focus', (e) => this.onFocus(e)); this.inputEl.removeEventListener('blur', (e) => this.onBlur(e)); this.inputEl.removeEventListener('keydown', (e) => this.onKeyDown(e));} if (this.boxLabelEl) { this.boxLabelEl.removeEventListener('click', (e) => this.onLabelClick(e));} this.inputEl = null; this.labelEl = null; this.boxLabelEl = null; this.errorEl = null; super.destroy();} } class ThemeToggle extends Component { constructor(config = {}) { super(config); this.config = { type: 'button', size: 'medium', showLabels: true, showIcons: true, animated: false, dynamicAriaLabel: false, lightLabel: 'Light', darkLabel: 'Dark', lightIcon: '☀️', darkIcon: '🌙', buttonText: null, cssClass: null, iconOnly: false, themeClasses: null, animationDuration: 200, themeManager: null, ...config }; this.themeManager = this.config.themeManager || new ThemeManager({ autoInit: false }); if (!this.themeManager.getCurrentTheme()) { this.themeManager.init();} this.currentTheme = this.themeManager.getCurrentTheme() || 'light'; this.isDark = this.currentTheme === 'dark'; this.setupThemeListener();} setupThemeListener() { if (this.themeManager && this.themeManager.on) { this.themeManager.on('themeChanged', (event) => { this.currentTheme = event.theme; this.isDark = event.theme === 'dark'; if (this.rendered) { this.updateAppearance();} });} } createTemplate() { if (this.config.type === 'switch') { return this.createSwitchTemplate();} return this.createButtonTemplate();} createButtonTemplate() { const ariaLabel = this.getAriaLabel(); const content = this.getButtonContent(); return ` <button class="${this.getButtonClasses()}" role="switch" aria-pressed="${this.isDark}" aria-label="${ariaLabel}" tabindex="0" type="button"> ${content} </button> `;} getButtonContent() { if (this.config.buttonText) { return this.config.buttonText;} if (this.config.iconOnly) { return this.config.showIcons ? `${this.config.lightIcon} ${this.config.darkIcon}` : '';} let content = ''; if (this.config.showIcons && this.config.showLabels) { content = `${this.config.lightIcon} ${this.config.lightLabel} / ${this.config.darkIcon} ${this.config.darkLabel}`;} else if (this.config.showIcons) { content = `${this.config.lightIcon} ${this.config.darkIcon}`;} else if (this.config.showLabels) { content = `${this.config.lightLabel} / ${this.config.darkLabel}`;} return content;} createSwitchTemplate() { const ariaLabel = this.getAriaLabel(); return ` <div class="${this.getSwitchContainerClasses()}"> <input type="checkbox" class="aionda-theme-toggle-switch-input sr-only" ${this.isDark ? 'checked' : ''} aria-label="${ariaLabel}"> <div class="aionda-theme-toggle-switch-track"> <div class="aionda-theme-toggle-switch-thumb"> ${this.config.showIcons ? (this.isDark ? this.config.darkIcon : this.config.lightIcon) : ''} </div> </div> ${this.config.showLabels ? ` <span class="aionda-theme-toggle-switch-label"> ${this.isDark ? this.config.darkLabel : this.config.lightLabel} </span> ` : ''} </div> `;} getButtonClasses() { const classes = [ 'theme-toggle', 'inline-flex', 'items-center', 'gap-2', 'px-4', 'py-2', 'rounded', 'border', 'cursor-pointer', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500' ]; if (this.config.cssClass) { classes.push(this.config.cssClass);} if (this.config.size === 'large') { classes.push('theme-toggle-large', 'text-lg', 'px-6', 'py-3');} else if (this.config.size === 'small') { classes.push('theme-toggle-small', 'text-sm', 'px-2', 'py-1');} if (this.config.animated) { classes.push('transition-all', 'duration-200');} const themeClass = this.isDark ? 'theme-toggle-dark' : 'theme-toggle-light'; classes.push(themeClass); if (this.config.themeClasses) { const customThemeClass = this.isDark ? this.config.themeClasses.dark : this.config.themeClasses.light; if (customThemeClass) { classes.push(customThemeClass);} } return classes.join(' ');} getSwitchContainerClasses() { const classes = [ 'aionda-theme-toggle-switch', 'inline-flex', 'items-center', 'gap-3', 'cursor-pointer' ]; if (this.config.cssClass) { classes.push(this.config.cssClass);} return classes.join(' ');} getAriaLabel() { if (this.config.dynamicAriaLabel) { return this.isDark ? `Switch to ${this.config.lightLabel.toLowerCase()} theme` : `Switch to ${this.config.darkLabel.toLowerCase()} theme`;} return 'Toggle theme';} render() { if (this.destroyed) { throw new Error('Cannot render destroyed component');} if (this.rendered && this.el) { return this.el;} const template = this.createTemplate(); const wrapper = document.createElement('div'); wrapper.innerHTML = template.trim(); this.el = wrapper.firstElementChild; if (!this.el) { throw new Error('Component template must return a valid HTML element');} this.el.id = this.id; this.applyStyles(); this.setupEventListeners(); this.rendered = true; this.emit('render'); return this.el;} setupEventListeners() { super.setupEventListeners(); if (this.config.type === 'switch') { const checkbox = this.el.querySelector('input[type="checkbox"]'); if (checkbox) { checkbox.addEventListener('change', (event) => this.onSwitchChange(event));} } else { this.el.addEventListener('click', (event) => this.onClick(event));} this.el.addEventListener('keydown', (event) => this.onKeyDown(event)); this.el.addEventListener('focus', (event) => this.onFocus(event)); this.el.addEventListener('blur', (event) => this.onBlur(event));} onSwitchChange(event) { if (this.disabled) { event.preventDefault(); return;} this.toggle();} onClick(event) { if (this.disabled) { event.preventDefault(); return;} this.toggle();} onKeyDown(event) { if (this.disabled) return; if (event.key === ' ' || event.key === 'Enter') { event.preventDefault(); this.toggle();} } onFocus(event) { this.emit('focus', { themeToggle: this, event });} onBlur(event) { this.emit('blur', { themeToggle: this, event });} toggle() { if (!this.themeManager || this.themeManager.destroyed) { return;} const previousTheme = this.themeManager.getCurrentTheme(); if (this.config.animated && this.el) { this.el.classList.add('theme-toggle-animating'); setTimeout(() => { if (this.el && !this.destroyed) { this.el.classList.remove('theme-toggle-animating');} }, this.config.animationDuration);} this.themeManager.toggleTheme(); const newTheme = this.themeManager.getCurrentTheme(); this.emit('toggle', { theme: newTheme, previousTheme: previousTheme });} updateAppearance() { if (!this.rendered || !this.el) return; this.currentTheme = this.themeManager.getCurrentTheme() || 'light'; this.isDark = this.currentTheme === 'dark'; if (this.config.type === 'switch') { const checkbox = this.el.querySelector('input[type="checkbox"]'); if (checkbox) { checkbox.checked = this.isDark;} } else { this.el.setAttribute('aria-pressed', this.isDark.toString()); if (this.config.dynamicAriaLabel) { this.el.setAttribute('aria-label', this.getAriaLabel());} const hasAnimatingClass = this.el.classList.contains('theme-toggle-animating'); this.el.className = this.getButtonClasses(); if (hasAnimatingClass) { this.el.classList.add('theme-toggle-animating');} this.el.innerHTML = this.getButtonContent();} this.emit('statechange', { themeToggle: this, theme: this.currentTheme, isDark: this.isDark });} updateToggleState() { this.updateAppearance();} setTheme(theme) { if (this.themeManager && !this.themeManager.destroyed) { this.themeManager.setTheme(theme);} return this;} getTheme() { return this.currentTheme;} setSize(size) { this.config.size = size; if (this.rendered) { this.updateAppearance();} return this;} focus() { this.el?.focus(); return this;} blur() { this.el?.blur(); return this;} destroy() { if (this.themeManager && this.themeManager.off) { this.themeManager.off('themeChanged');} super.destroy();} } class RichTextField extends Component { constructor(config = {}) { super(config); this.fieldLabel = config.fieldLabel || ''; this.value = config.value || ''; this.height = config.height || 200; this.allowHtml = config.allowHtml !== undefined ? config.allowHtml : true; this.required = config.required || false; this.disabled = config.disabled || false; this.placeholder = config.placeholder || 'Enter text...'; this.validators = config.validators || []; this.toolbar = config.toolbar || [ 'bold', 'italic', 'underline', 'strikethrough', 'separator', 'foreColor', 'backColor', 'separator', 'fontSize', 'fontName', 'separator', 'justifyLeft', 'justifyCenter', 'justifyRight', 'separator', 'insertUnorderedList', 'insertOrderedList', 'separator', 'createLink', 'unlink', 'separator', 'undo', 'redo' ]; this.editorEl = null; this.toolbarEl = null; this.isValid = true; this.validationMessage = '';} createTemplate() { const fieldLabelHtml = this.fieldLabel ? `<label class="block text-sm font-medium text-gray-700 mb-2">${this.fieldLabel}${this.required ? ' *' : ''}</label>` : ''; const toolbarHtml = this.createToolbarHtml(); return ` <div class="aionda-richtext-field"> ${fieldLabelHtml} <div class="border border-gray-300 rounded-lg overflow-hidden ${this.disabled ? 'bg-gray-100' : 'bg-white'}"> ${toolbarHtml} <div class="aionda-richtext-editor p-3 focus-within:ring-2 focus-within:ring-blue-500 focus-within:border-blue-500" style="height: ${this.height}px; overflow-y: auto;" contenteditable="${this.disabled ? 'false' : 'true'}" data-placeholder="${this.placeholder}"> ${this.value} </div> </div> <div class="aionda-richtext-validation mt-1 text-sm text-red-600 hidden"></div> </div> `;} createToolbarHtml() { let toolbarItems = ''; this.toolbar.forEach(item => { if (item === 'separator') { toolbarItems += '<div class="w-px h-6 bg-gray-300 mx-1"></div>';} else { toolbarItems += this.createToolbarButton(item);} }); return ` <div class="aionda-richtext-toolbar flex items-center space-x-1 p-2 bg-gray-50 border-b border-gray-300"> ${toolbarItems} </div> `;} createToolbarButton(command) { const buttonConfigs = { bold: { icon: 'B', title: 'Bold', class: 'font-bold' }, italic: { icon: 'I', title: 'Italic', class: 'italic' }, underline: { icon: 'U', title: 'Underline', class: 'underline' }, strikethrough: { icon: 'S', title: 'Strikethrough', class: 'line-through' }, justifyLeft: { icon: '⫷', title: 'Align Left' }, justifyCenter: { icon: '≡', title: 'Align Center' }, justifyRight: { icon: '⫸', title: 'Align Right' }, insertUnorderedList: { icon: '•', title: 'Bullet List' }, insertOrderedList: { icon: '1.', title: 'Numbered List' }, createLink: { icon: '🔗', title: 'Insert Link' }, unlink: { icon: '🔗⃠', title: 'Remove Link' }, undo: { icon: '↶', title: 'Undo' }, redo: { icon: '↷', title: 'Redo' }, foreColor: { icon: 'A', title: 'Text Color', type: 'color' }, backColor: { icon: '🎨', title: 'Background Color', type: 'color' }, fontSize: { icon: '📏', title: 'Font Size', type: 'select', options: ['1', '2', '3', '4', '5', '6', '7'] }, fontName: { icon: 'F', title: 'Font Family', type: 'select', options: ['Arial', 'Helvetica', 'Times New Roman', 'Courier New', 'Georgia'] } }; const config = buttonConfigs[command]; if (!config) return ''; if (config.type === 'color') { return ` <div class="relative"> <button class="inline-flex items-center justify-center w-8 h-8 text-sm border border-gray-300 rounded hover:bg-gray-100 cursor-pointer" title="${config.title}" data-command="${command}"> <span class="${config.class || ''}">${config.icon}</span> </button> <input type="color" class="absolute inset-0 opacity-0 cursor-pointer" data-command="${command}" title="${config.title}"> </div> `;} else if (config.type === 'select') { return ` <select class="px-2 py-1 text-sm border border-gray-300 rounded hover:bg-gray-100" data-command="${command}" title="${config.title}"> <option value="">${config.title}</option> ${config.options.map(opt => `<option value="${opt}">${opt}</option>`).join('')} </select> `;} else { return ` <button class="inline-flex items-center justify-center w-8 h-8 text-sm border border-gray-300 rounded hover:bg-gray-100 ${config.class || ''}" data-command="${command}" title="${config.title}"> ${config.icon} </button> `;} } setupEventListeners() { super.setupEventListeners(); this.editorEl = this.el.querySelector('.aionda-richtext-editor'); this.toolbarEl = this.el.querySelector('.aionda-richtext-toolbar'); this.toolbarEl.addEventListener('click', (e) => { const button = e.target.closest('[data-command]'); if (button) { e.preventDefault(); this.executeCommand(button.dataset.command, button);} }); this.toolbarEl.addEventListener('change', (e) => { if (e.target.type === 'color') { this.executeCommand(e.target.dataset.command, null, e.target.value);} else if (e.target.tagName === 'SELECT') { this.executeCommand(e.target.dataset.command, null, e.target.value); e.target.selectedIndex = 0;} }); this.editorEl.addEventListener('input', () => { this.value = this.editorEl.innerHTML; this.validate(); this.emit('change', { value: this.value, component: this });}); this.editorEl.addEventListener('focus', () => { this.emit('focus', { component: this });}); this.editorEl.addEventListener('blur', () => { this.validate(); this.emit('blur', { component: this });}); this.updatePlaceholder(); this.editorEl.addEventListener('input', () => this.updatePlaceholder()); this.editorEl.addEventListener('focus', () => this.updatePlaceholder()); this.editorEl.addEventListener('blur', () => this.updatePlaceholder());} executeCommand(command, button, value) { this.editorEl.focus(); if (['bold', 'italic', 'underline', 'strikethrough', 'foreColor', 'backColor'].includes(command)) { const selection = window.getSelection(); if (selection.rangeCount === 0 || selection.isCollapsed) { const range = document.createRange(); range.selectNodeContents(this.editorEl); selection.removeAllRanges(); selection.addRange(range);} } try { document.execCommand('styleWithCSS', false, true); if (command === 'createLink') { const url = prompt('Enter URL:'); if (url) { document.execCommand(command, false, url);} } else if (command === 'fontSize') { if (value) { document.execCommand(command, false, value);} } else if (command === 'fontName') { if (value) { document.execCommand(command, false, value);} } else if (command === 'foreColor') { if (value) { const success = document.execCommand('foreColor', false, value); if (!success) { this.applyColorStyle('color', value);} } } else if (command === 'backColor' || command === 'hiliteColor') { if (value) { const success = document.execCommand('hiliteColor', false, value) || document.execCommand('backColor', false, value); if (!success) { this.applyColorStyle('background-color', value);} } } else { document.execCommand(command, false, value);} setTimeout(() => this.updateToolbarState(), 50); this.value = this.editorEl.innerHTML; this.emit('change', { value: this.value, component: this });} catch (error) { console.warn('RichTextField command failed:', command, error);} } applyColorStyle(property, value) { const selection = window.getSelection(); if (selection.rangeCount > 0) { const range = selection.getRangeAt(0); const selectedContent = range.extractContents(); const span = document.createElement('span'); span.style[property] = value; span.appendChild(selectedContent); range.insertNode(span); selection.removeAllRanges(); selection.addRange(range);} } updateToolbarState() { const buttons = this.toolbarEl.querySelectorAll('[data-command]'); buttons.forEach(button => { const command = button.dataset.command; try { if (document.queryCommandState(command)) { button.classList.add('bg-blue-100', 'text-blue-700');} else { button.classList.remove('bg-blue-100', 'text-blue-700');} } catch (e) { } });} updatePlaceholder() { const isEmpty = this.editorEl.textContent.trim() === '' && this.editorEl.innerHTML.trim() === ''; if (isEmpty) { this.editorEl.classList.add('empty'); if (!this.el.querySelector('.placeholder-style')) { const style = document.createElement('style'); style.className = 'placeholder-style'; style.textContent = ` .aionda-richtext-editor.empty:before { content: attr(data-placeholder); color: #9CA3AF; pointer-events: none; position: absolute;} `; this.el.appendChild(style);} } else { this.editorEl.classList.remove('empty');} } getValue() { return this.allowHtml ? this.editorEl.innerHTML : this.editorEl.textContent;} setValue(value) { this.value = value || ''; if (this.editorEl) { this.editorEl.innerHTML = this.value; this.updatePlaceholder(); this.validate();} } getTextContent() { return this.editorEl ? this.editorEl.textContent : '';} clear() { this.setValue('');} focus() { if (this.editorEl) { this.editorEl.focus();} } setDisabled(disabled) { this.disabled = disabled; if (this.editorEl) { this.editorEl.contentEditable = disabled ? 'false' : 'true'; this.el.classList.toggle('opacity-50', disabled); const buttons = this.toolbarEl.querySelectorAll('button, select, input'); buttons.forEach(btn => btn.disabled = disabled);} } validate() { this.isValid = true; this.validationMessage = ''; const textContent = this.getTextContent().trim(); if (this.required && textContent === '') { this.isValid = false; this.validationMessage = 'This field is required';} if (this.isValid && this.validators.length > 0) { for (const validator of this.validators) { const result = validator(this.getValue(), this); if (result !== true) { this.isValid = false; this.validationMessage = result || 'Invalid value'; break;} } } this.updateValidationDisplay(); return this.isValid;} updateValidationDisplay() { const validationEl = this.el.querySelector('.aionda-richtext-validation'); const editorContainer = this.el.querySelector('.border'); if (this.isValid) { validationEl.classList.add('hidden'); editorContainer.classList.remove('border-red-300'); editorContainer.classList.add('border-gray-300');} else { validationEl.textContent = this.validationMessage; validationEl.classList.remove('hidden'); editorContainer.classList.remove('border-gray-300'); editorContainer.classList.add('border-red-300');} } isValidField() { return this.validate();} insertHtml(html) { this.editorEl.focus(); try { document.execCommand('insertHTML', false, html); this.value = this.editorEl.innerHTML; this.emit('change', { value: this.value, component: this });} catch (error) { console.warn('Failed to insert HTML:', error);} } getWordCount() { const text = this.getTextContent(); return text.trim() === '' ? 0 : text.trim().split(/\s+/).length;} getCharacterCount() { return this.getTextContent().length;} } const AiondaWebUI = { EventEmitter, Component, Store, ThemeManager, themeManager, Panel, Button, Grid, Form, TextField, NumberField, ComboBox, Checkbox, Tree, Menu, MenuItem, Toolbar, Window, MessageBox, Toast, DateField, TextArea, RadioGroup, Radio, ThemeToggle, RichTextField, version: '0.2.0', create(componentClass, config) { return new componentClass(config);} }; if (typeof module !== 'undefined' && module.exports) { module.exports = AiondaWebUI;} else if (typeof define === 'function' && define.amd) { define(function() { return AiondaWebUI;});} else { global.AiondaWebUI = AiondaWebUI; global.TypeUI = AiondaWebUI;} })(typeof window !== 'undefined' ? window : this);